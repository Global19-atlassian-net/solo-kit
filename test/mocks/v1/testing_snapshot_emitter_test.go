// Code generated by solo-kit. DO NOT EDIT.

// +build solokit

package v1

import (
	"context"
	"os"
	"time"

	github_com_solo_io_solo_kit_pkg_api_v1_resources_common_kubernetes "github.com/solo-io/solo-kit/pkg/api/v1/resources/common/kubernetes"

	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
	"github.com/solo-io/go-utils/kubeutils"
	"github.com/solo-io/solo-kit/pkg/api/v1/clients"
	"github.com/solo-io/solo-kit/pkg/api/v1/clients/factory"
	kuberc "github.com/solo-io/solo-kit/pkg/api/v1/clients/kube"
	"github.com/solo-io/solo-kit/pkg/api/v1/clients/memory"
	"github.com/solo-io/solo-kit/pkg/utils/log"
	"github.com/solo-io/solo-kit/pkg/utils/stringutils"
	"github.com/solo-io/solo-kit/test/helpers"
	"github.com/solo-io/solo-kit/test/setup"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"

	// Needed to run tests in GKE
	_ "k8s.io/client-go/plugin/pkg/client/auth"
)

var _ = Describe("V1Emitter", func() {
	if os.Getenv("RUN_KUBE_TESTS") != "1" {
		log.Printf("This test creates kubernetes resources and is disabled by default. To enable, set RUN_KUBE_TESTS=1 in your env.")
		return
	}
	var (
		namespace0            string
		namespace1            string
		namespace2            string
		namespace3            string
		namespace4            string
		name0                 = helpers.RandString(8)
		name1                 = helpers.RandString(8)
		name2                 = helpers.RandString(8)
		name3                 = helpers.RandString(8)
		name4                 = helpers.RandString(8)
		cfg                   *rest.Config
		emitter               TestingEmitter
		kube                  kubernetes.Interface
		mockResourceClient    MockResourceClient
		fakeResourceClient    FakeResourceClient
		clusterResourceClient ClusterResourceClient
		mockCustomTypeClient  MockCustomTypeClient
		podClient             github_com_solo_io_solo_kit_pkg_api_v1_resources_common_kubernetes.PodClient
	)

	BeforeEach(func() {
		namespace0 = helpers.RandString(8)
		namespace1 = helpers.RandString(8)
		namespace2 = helpers.RandString(8)
		namespace3 = helpers.RandString(8)
		namespace4 = helpers.RandString(8)
		var err error
		cfg, err = kubeutils.GetConfig("", "")
		Expect(err).NotTo(HaveOccurred())
		kube = kubernetes.NewForConfigOrDie(cfg)
		err = setup.CreateNamespacesInParallel(kube, namespace0, namespace1, namespace2, namespace3, namespace4)
		Expect(err).NotTo(HaveOccurred())
		// MockResource Constructor
		mockResourceClientFactory := &factory.KubeResourceClientFactory{
			Crd:         MockResourceCrd,
			Cfg:         cfg,
			SharedCache: kuberc.NewKubeCache(context.TODO()),
		}

		mockResourceClient, err = NewMockResourceClient(mockResourceClientFactory)
		Expect(err).NotTo(HaveOccurred())
		// FakeResource Constructor
		fakeResourceClientFactory := &factory.MemoryResourceClientFactory{
			Cache: memory.NewInMemoryResourceCache(),
		}

		fakeResourceClient, err = NewFakeResourceClient(fakeResourceClientFactory)
		Expect(err).NotTo(HaveOccurred())
		// ClusterResource Constructor
		clusterResourceClientFactory := &factory.KubeResourceClientFactory{
			Crd:         ClusterResourceCrd,
			Cfg:         cfg,
			SharedCache: kuberc.NewKubeCache(context.TODO()),
		}

		clusterResourceClient, err = NewClusterResourceClient(clusterResourceClientFactory)
		Expect(err).NotTo(HaveOccurred())
		// MockCustomType Constructor
		mockCustomTypeClientFactory := &factory.MemoryResourceClientFactory{
			Cache: memory.NewInMemoryResourceCache(),
		}

		mockCustomTypeClient, err = NewMockCustomTypeClient(mockCustomTypeClientFactory)
		Expect(err).NotTo(HaveOccurred())
		// Pod Constructor
		podClientFactory := &factory.MemoryResourceClientFactory{
			Cache: memory.NewInMemoryResourceCache(),
		}

		podClient, err = github_com_solo_io_solo_kit_pkg_api_v1_resources_common_kubernetes.NewPodClient(podClientFactory)
		Expect(err).NotTo(HaveOccurred())
		emitter = NewTestingEmitter(mockResourceClient, fakeResourceClient, clusterResourceClient, mockCustomTypeClient, podClient)
	})
	AfterEach(func() {
		err := setup.DeleteNamespacesInParallelBlocking(kube, namespace0, namespace1, namespace2, namespace3, namespace4)
		Expect(err).NotTo(HaveOccurred())

	})

	var getAllNamespaces = func() []string {
		return []string{
			namespace0,
			namespace1,
			namespace2,
			namespace3,
			namespace4,
		}
	}

	var getAllNames = func() []string {
		return []string{
			name0,
			name1,
			name2,
			name3,
			name4,
		}
	}

	var testingEmitterTest = func(watchNamespaces *clients.NamespacesByResourceWatcher) {
		var (
			namespaces []string
			ok         bool
		)
		ctx := context.Background()
		err := emitter.Register()
		Expect(err).NotTo(HaveOccurred())

		snapshots, errs, err := emitter.Snapshots(watchNamespaces, clients.WatchOpts{
			Ctx:         ctx,
			RefreshRate: time.Second,
		})
		Expect(err).NotTo(HaveOccurred())

		var snap *TestingSnapshot

		if watchNamespaces == nil {
			watchNamespaces = clients.NewNamespacesByResourceWatcher()
		}

		/*
			MockResource
		*/

		namespaces, ok = watchNamespaces.Get(mockResourceClient.BaseWatcher())
		if !ok || namespaces == nil {
			namespaces = []string{""}
		}

		assertSnapshotMocks := func(expectMocks MockResourceList, unexpectMocks MockResourceList) {
		drain:
			for {
				select {
				case snap = <-snapshots:
					for _, expected := range expectMocks {
						if _, err := snap.Mocks.List().Find(expected.GetMetadata().Ref().Strings()); err != nil {
							continue drain
						}
					}
					for _, unexpected := range unexpectMocks {
						if _, err := snap.Mocks.List().Find(unexpected.GetMetadata().Ref().Strings()); err == nil {
							continue drain
						}
					}
					break drain
				case err := <-errs:
					Expect(err).NotTo(HaveOccurred())
				case <-time.After(time.Second * 10):
					combined := make(MocksByNamespace)
					for _, namespace := range namespaces {
						nsList, err := mockResourceClient.List(namespace, clients.ListOpts{})
						Expect(err).NotTo(HaveOccurred())
						combined[namespace] = nsList
					}
					Fail("expected final snapshot before 10 seconds. expected " + log.Sprintf("%v", combined))
				}
			}
		}

		var expectedMockResources MockResourceList
		for _, name := range getAllNames() {
			for _, namespace := range getAllNamespaces() {

				mockResource, err := mockResourceClient.Write(NewMockResource(namespace, name), clients.WriteOpts{Ctx: ctx})
				Expect(err).NotTo(HaveOccurred())
				if stringutils.ContainsString(namespace, namespaces) || (len(namespaces) == 1 && namespaces[0] == "") {
					expectedMockResources = append(expectedMockResources, mockResource)
				}
			}
		}
		assertSnapshotMocks(expectedMockResources, nil)

		for _, expectedVal := range expectedMockResources {
			err = mockResourceClient.Delete(expectedVal.GetMetadata().Namespace, expectedVal.GetMetadata().Name, clients.DeleteOpts{Ctx: ctx})
			Expect(err).NotTo(HaveOccurred())
		}
		assertSnapshotMocks(nil, expectedMockResources)

		/*
			FakeResource
		*/

		namespaces, ok = watchNamespaces.Get(fakeResourceClient.BaseWatcher())
		if !ok || namespaces == nil {
			namespaces = []string{""}
		}

		assertSnapshotFakes := func(expectFakes FakeResourceList, unexpectFakes FakeResourceList) {
		drain:
			for {
				select {
				case snap = <-snapshots:
					for _, expected := range expectFakes {
						if _, err := snap.Fakes.List().Find(expected.GetMetadata().Ref().Strings()); err != nil {
							continue drain
						}
					}
					for _, unexpected := range unexpectFakes {
						if _, err := snap.Fakes.List().Find(unexpected.GetMetadata().Ref().Strings()); err == nil {
							continue drain
						}
					}
					break drain
				case err := <-errs:
					Expect(err).NotTo(HaveOccurred())
				case <-time.After(time.Second * 10):
					combined := make(FakesByNamespace)
					for _, namespace := range namespaces {
						nsList, err := fakeResourceClient.List(namespace, clients.ListOpts{})
						Expect(err).NotTo(HaveOccurred())
						combined[namespace] = nsList
					}
					Fail("expected final snapshot before 10 seconds. expected " + log.Sprintf("%v", combined))
				}
			}
		}

		var expectedFakeResources FakeResourceList
		for _, name := range getAllNames() {
			for _, namespace := range getAllNamespaces() {

				fakeResource, err := fakeResourceClient.Write(NewFakeResource(namespace, name), clients.WriteOpts{Ctx: ctx})
				Expect(err).NotTo(HaveOccurred())
				if stringutils.ContainsString(namespace, namespaces) || (len(namespaces) == 1 && namespaces[0] == "") {
					expectedFakeResources = append(expectedFakeResources, fakeResource)
				}
			}
		}
		assertSnapshotFakes(expectedFakeResources, nil)

		for _, expectedVal := range expectedFakeResources {
			err = fakeResourceClient.Delete(expectedVal.GetMetadata().Namespace, expectedVal.GetMetadata().Name, clients.DeleteOpts{Ctx: ctx})
			Expect(err).NotTo(HaveOccurred())
		}
		assertSnapshotFakes(nil, expectedFakeResources)

		/*
			ClusterResource
		*/

		namespaces, ok = watchNamespaces.Get(clusterResourceClient.BaseWatcher())
		if !ok || namespaces == nil {
			namespaces = []string{""}
		}

		assertSnapshotClusterresources := func(expectClusterresources ClusterResourceList, unexpectClusterresources ClusterResourceList) {
		drain:
			for {
				select {
				case snap = <-snapshots:
					for _, expected := range expectClusterresources {
						if _, err := snap.Clusterresources.Find(expected.GetMetadata().Ref().Strings()); err != nil {
							continue drain
						}
					}
					for _, unexpected := range unexpectClusterresources {
						if _, err := snap.Clusterresources.Find(unexpected.GetMetadata().Ref().Strings()); err == nil {
							continue drain
						}
					}
					break drain
				case err := <-errs:
					Expect(err).NotTo(HaveOccurred())
				case <-time.After(time.Second * 10):
					nsList, _ := clusterResourceClient.List(clients.ListOpts{})
					combined := ClusterresourcesByNamespace{
						"": nsList,
					}
					Fail("expected final snapshot before 10 seconds. expected " + log.Sprintf("%v", combined))
				}
			}
		}

		var expectedClusterResources ClusterResourceList
		for _, name := range getAllNames() {
			namespace := ""
			clusterResource, err := clusterResourceClient.Write(NewClusterResource(namespace, name), clients.WriteOpts{Ctx: ctx})
			Expect(err).NotTo(HaveOccurred())
			if stringutils.ContainsString(namespace, namespaces) || (len(namespaces) == 1 && namespaces[0] == "") {
				expectedClusterResources = append(expectedClusterResources, clusterResource)
			}
		}
		assertSnapshotClusterresources(expectedClusterResources, nil)

		for _, expectedVal := range expectedClusterResources {
			err = clusterResourceClient.Delete(expectedVal.GetMetadata().Name, clients.DeleteOpts{Ctx: ctx})

			Expect(err).NotTo(HaveOccurred())
		}
		assertSnapshotClusterresources(nil, expectedClusterResources)

		/*
			MockCustomType
		*/

		namespaces, ok = watchNamespaces.Get(mockCustomTypeClient.BaseWatcher())
		if !ok || namespaces == nil {
			namespaces = []string{""}
		}

		assertSnapshotmcts := func(expectmcts MockCustomTypeList, unexpectmcts MockCustomTypeList) {
		drain:
			for {
				select {
				case snap = <-snapshots:
					for _, expected := range expectmcts {
						if _, err := snap.Mcts.List().Find(expected.GetMetadata().Ref().Strings()); err != nil {
							continue drain
						}
					}
					for _, unexpected := range unexpectmcts {
						if _, err := snap.Mcts.List().Find(unexpected.GetMetadata().Ref().Strings()); err == nil {
							continue drain
						}
					}
					break drain
				case err := <-errs:
					Expect(err).NotTo(HaveOccurred())
				case <-time.After(time.Second * 10):
					combined := make(MctsByNamespace)
					for _, namespace := range namespaces {
						nsList, err := mockCustomTypeClient.List(namespace, clients.ListOpts{})
						Expect(err).NotTo(HaveOccurred())
						combined[namespace] = nsList
					}
					Fail("expected final snapshot before 10 seconds. expected " + log.Sprintf("%v", combined))
				}
			}
		}

		var expectedMockCustomTypes MockCustomTypeList
		for _, name := range getAllNames() {
			for _, namespace := range getAllNamespaces() {

				mockCustomType, err := mockCustomTypeClient.Write(NewMockCustomType(namespace, name), clients.WriteOpts{Ctx: ctx})
				Expect(err).NotTo(HaveOccurred())
				if stringutils.ContainsString(namespace, namespaces) || (len(namespaces) == 1 && namespaces[0] == "") {
					expectedMockCustomTypes = append(expectedMockCustomTypes, mockCustomType)
				}
			}
		}
		assertSnapshotmcts(expectedMockCustomTypes, nil)

		for _, expectedVal := range expectedMockCustomTypes {
			err = mockCustomTypeClient.Delete(expectedVal.GetMetadata().Namespace, expectedVal.GetMetadata().Name, clients.DeleteOpts{Ctx: ctx})
			Expect(err).NotTo(HaveOccurred())
		}
		assertSnapshotmcts(nil, expectedMockCustomTypes)

		/*
			Pod
		*/

		namespaces, ok = watchNamespaces.Get(podClient.BaseWatcher())
		if !ok || namespaces == nil {
			namespaces = []string{""}
		}

		assertSnapshotpods := func(expectpods github_com_solo_io_solo_kit_pkg_api_v1_resources_common_kubernetes.PodList, unexpectpods github_com_solo_io_solo_kit_pkg_api_v1_resources_common_kubernetes.PodList) {
		drain:
			for {
				select {
				case snap = <-snapshots:
					for _, expected := range expectpods {
						if _, err := snap.Pods.List().Find(expected.GetMetadata().Ref().Strings()); err != nil {
							continue drain
						}
					}
					for _, unexpected := range unexpectpods {
						if _, err := snap.Pods.List().Find(unexpected.GetMetadata().Ref().Strings()); err == nil {
							continue drain
						}
					}
					break drain
				case err := <-errs:
					Expect(err).NotTo(HaveOccurred())
				case <-time.After(time.Second * 10):
					combined := make(github_com_solo_io_solo_kit_pkg_api_v1_resources_common_kubernetes.PodsByNamespace)
					for _, namespace := range namespaces {
						nsList, err := podClient.List(namespace, clients.ListOpts{})
						Expect(err).NotTo(HaveOccurred())
						combined[namespace] = nsList
					}
					Fail("expected final snapshot before 10 seconds. expected " + log.Sprintf("%v", combined))
				}
			}
		}

		var expectedPods github_com_solo_io_solo_kit_pkg_api_v1_resources_common_kubernetes.PodList
		for _, name := range getAllNames() {
			for _, namespace := range getAllNamespaces() {

				pod, err := podClient.Write(github_com_solo_io_solo_kit_pkg_api_v1_resources_common_kubernetes.NewPod(namespace, name), clients.WriteOpts{Ctx: ctx})
				Expect(err).NotTo(HaveOccurred())
				if stringutils.ContainsString(namespace, namespaces) || (len(namespaces) == 1 && namespaces[0] == "") {
					expectedPods = append(expectedPods, pod)
				}
			}
		}
		assertSnapshotpods(expectedPods, nil)

		for _, expectedVal := range expectedPods {
			err = podClient.Delete(expectedVal.GetMetadata().Namespace, expectedVal.GetMetadata().Name, clients.DeleteOpts{Ctx: ctx})
			Expect(err).NotTo(HaveOccurred())
		}
		assertSnapshotpods(nil, expectedPods)
	}

	It("tracks snapshots on changes to any resource", func() {
		namespaces := clients.NewNamespacesByResourceWatcher()
		namespaces.Set(mockResourceClient.BaseWatcher(), getAllNamespaces())
		namespaces.Set(fakeResourceClient.BaseWatcher(), getAllNamespaces())
		namespaces.Set(mockCustomTypeClient.BaseWatcher(), getAllNamespaces())
		namespaces.Set(podClient.BaseWatcher(), getAllNamespaces())

		testingEmitterTest(namespaces)

	})

	It("tracks snapshots on changes to different resources in different namespaces", func() {
		namespaces := clients.NewNamespacesByResourceWatcher()
		namespaces.Set(mockResourceClient.BaseWatcher(), []string{namespace0})
		namespaces.Set(fakeResourceClient.BaseWatcher(), []string{namespace1})
		namespaces.Set(mockCustomTypeClient.BaseWatcher(), []string{namespace3})
		namespaces.Set(podClient.BaseWatcher(), []string{namespace4})

		testingEmitterTest(namespaces)

	})

	It("tracks snapshots on changes to any resource using AllNamespace", func() {
		testingEmitterTest(nil)
	})

})
