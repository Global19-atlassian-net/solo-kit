package cligen

import (
	"bytes"
	"fmt"
	"github.com/spf13/cobra"
	"path"
	"strings"
	"text/template"

	"github.com/solo-io/solo-kit/pkg/code-generator/cligen/templates"
	"github.com/solo-io/solo-kit/pkg/code-generator/model"
	"github.com/solo-io/solo-kit/pkg/utils/log"
)

const fileHeader = `// Code template generated by solo-kit. Feel free to Edit.

`

type File struct {
	Filename string
	Content  string
}

type Files []File

func GenerateFiles(project *model.Project, cliDir string,  skipOutOfPackageFiles bool) (Files, error) {

	files, err := generateFilesForProject(project)
	if err != nil {
		return nil, err
	}
	for _, res := range project.Resources {
		// only generate files for the resources in our group, otherwise we import
		if res.GroupName != project.GroupName {
			log.Printf("not generating solo-kit "+
				"clients for resource %v, group name must match package name %v", res.GroupName, project.GroupName)
			continue
		}
		fs, err := generateFilesForResource(res)
		if err != nil {
			return nil, err
		}
		files = append(files, fs...)
	}
	clientHelpers, err := generateClientHelpers(project)
	if err != nil {
		return files, err
	}
	files = append(files, clientHelpers)
	printers, err := generatePrinters(project)
	if err != nil {
		return files, err
	}
	files = append(files, printers...)
	for i := range files {
		files[i].Content = fileHeader + files[i].Content
	}
	return files, nil
}

func generateFilesForResource(resource *model.Resource) (Files, error) {
	var files Files
	for _, commandType := range []string{"root", "get"} {
		commandFileInfo := &model.CliResourceFile{
			CliFile: model.CliFile{
				Filename: fmt.Sprintf("cmd/%s/%s.go", strings.ToLower(resource.Name), commandType),
			},
			IsRoot: false,
			Resource: resource,
			CmdName: strings.Title(commandType),
			Cmd: &cobra.Command{
				Use: strings.ToLower(resource.Name),
				Short: commandType+" command short description",
				Long: commandType+" command long description",
			},
		}
		err := commandFileInfo.AddImport("cli/options")
		if err != nil {
			return files, err
		}
		f, err := generateCliResourceFile(commandFileInfo, templates.CommandTemplate)
		if err != nil {
			return nil, err
		}
		files = append(files, f)
	}

	return files, nil
}


func generateFilesForProject(project *model.Project) (Files, error) {
	var v Files
	optionsFileInfo := &model.CliFile{
		Filename: "options/options.go",
		Resources: project.Resources,
	}
	mainFileInfo := &model.CliFile{
		Filename: "main.go",
		Resources: project.Resources,
	}
	err := mainFileInfo.AddImport("cli/options", "cli/cmd")
	if err != nil {
		return nil, err
	}
	rootCommandFileInfo := &model.CliResourceFile{
		CliFile: model.CliFile{
			Filename: "cmd/root.go",
			Resources: project.Resources,
			PackageName: "cmd",
		},
		IsRoot: true,
		CmdName: "Root",
		Cmd: &cobra.Command{
			Use: project.Name,
			Short: "Short description for application",
			Long: "Long description",
		},
	}
	var cmdImports []string
	cmdImports = append(cmdImports, "cli/options")
	for _,v := range project.Resources {
		cmdImports = append(cmdImports, "cli/cmd/"+v.Name)
	}
	err = rootCommandFileInfo.AddImport(cmdImports...)
	if err != nil {
		return nil, err
	}
	for opt,tmpl := range map[*model.CliFile]*template.Template{
		optionsFileInfo: templates.OptionsTemplate,
		mainFileInfo: templates.MainTemplate,
	} {
		f, err := generateCliFile(opt, tmpl)
		if err != nil {
			return nil, err
		}
		v = append(v, f)
	}
	for opt,tmpl := range map[*model.CliResourceFile]*template.Template{
		rootCommandFileInfo: templates.CommandTemplate,
	} {
		f, err := generateCliResourceFile(opt, tmpl)
		if err != nil {
			return nil, err
		}
		v = append(v, f)
	}
	return v, nil
}

func generateClientHelpers(project *model.Project) (File, error) {
	var file File
	var err error
	clientHelpersInfo := &model.CliFile{
		Resources: project.Resources,
		PackageName: "helpers",
		Filename: "helpers/client.go",
	}
	err = clientHelpersInfo.AddImport("v1")
	if err != nil {
		return file, err
	}
	file, err = generateCliFile(clientHelpersInfo, templates.ClientHelperTemplate)
	if err != nil {
		return file, nil
	}
	return file, nil
}

func generatePrinters(project *model.Project) (Files, error) {
	var files Files
	var err error
	for _, res := range project.Resources {
		printerFileInfo := &model.CliResourceFile{
			CliFile: model.CliFile{
				Filename: path.Join("cmd", strings.ToLower(res.Name), "printer.go"),
			},
			Resource: res,
		}
		err = printerFileInfo.AddImport("v1")
		if err != nil {
			return files, err
		}
		file, err := generateCliResourceFile(printerFileInfo, templates.PrinterTemplate)
		if err != nil {
			return files, err
		}
		files = append(files, file)
	}

	return files, nil
}

func generateCliFile(cfg *model.CliFile, tmpl *template.Template) (File, error) {
	var file File
	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, cfg); err != nil {
		return file, err
	}
	file = File{
		Filename: cfg.Filename,
		Content: buf.String(),
	}
	return file, nil
}

func generateCliResourceFile(cfg *model.CliResourceFile, tmpl *template.Template) (File, error) {
	var file File
	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, cfg); err != nil {
		return file, err
	}
	file = File{
		Filename: cfg.Filename,
		Content: buf.String(),
	}
	return file, nil
}
