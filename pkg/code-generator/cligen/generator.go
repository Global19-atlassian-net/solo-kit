package cligen

import (
	"bytes"
	"fmt"
	"github.com/spf13/cobra"
	"strings"
	"text/template"

	"github.com/solo-io/solo-kit/pkg/code-generator/cligen/templates"
	"github.com/solo-io/solo-kit/pkg/code-generator/model"
	"github.com/solo-io/solo-kit/pkg/utils/log"
)

const fileHeader = `// Code template generated by solo-kit. Feel free to Edit.

`

type File struct {
	Filename string
	Content  string
}

type Files []File

func GenerateFiles(project *model.Project, cliDir string,  skipOutOfPackageFiles bool) (Files, error) {

	files, err := generateFilesForProject(project)
	if err != nil {
		return nil, err
	}
	for _, res := range project.Resources {
		// only generate files for the resources in our group, otherwise we import
		if res.GroupName != project.GroupName {
			log.Printf("not generating solo-kit "+
				"clients for resource %v, group name must match package name %v", res.GroupName, project.GroupName)
			continue
		}
		fs, err := generateFilesForResource(res)
		if err != nil {
			return nil, err
		}
		files = append(files, fs...)
	}
	//for _, grp := range project.ResourceGroups {
	//	if skipOutOfPackageFiles && !strings.HasSuffix(grp.Name, "."+project.GroupName) {
	//		continue
	//	}
	//	fs, err := generateFilesForResourceGroup(grp)
	//	if err != nil {
	//		return nil, err
	//	}
	//	files = append(files, fs...)
	//}
	for i := range files {
		files[i].Content = fileHeader + files[i].Content
	}
	return files, nil
}

func generateFilesForResource(resource *model.Resource) (Files, error) {
	var v Files
	commandFileInfo := &model.CliCommandFile{
		CliFile: model.CliFile{
			Filename: fmt.Sprintf("cmd/%s/root.go", strings.ToLower(resource.Name)),
		},
		IsRoot: false,
		Resource: resource,
		Cmd: &cobra.Command{
			Use: strings.ToLower(resource.Name),
			Short: "short description",
			Long: "long description",
		},
	}
	err := commandFileInfo.AddImport("cli/options")
	if err != nil {
		return v, err
	}
	f, err := generateCommandFile(commandFileInfo, templates.CommandTemplate)
	if err != nil {
		return nil, err
	}
	v = append(v, f)
	return v, nil
}


func generateFilesForProject(project *model.Project) (Files, error) {
	var v Files
	optionsFileInfo := &model.CliFile{
		Filename: "options/options.go",
		Resources: project.Resources,
	}
	mainFileInfo := &model.CliFile{
		Filename: "main.go",
		Resources: project.Resources,
	}
	err := mainFileInfo.AddImport("cli/options", "cli/cmd")
	if err != nil {
		return nil, err
	}
	rootCommandFileInfo := &model.CliCommandFile{
		CliFile: model.CliFile{
			Filename: "cmd/root.go",
			Resources: project.Resources,
			PackageName: "cmd",
		},
		IsRoot: true,
		Cmd: &cobra.Command{
			Use: project.Name,
			Short: "Short description for application",
			Long: "Long description",
		},
	}
	var cmdImports []string
	cmdImports = append(cmdImports, "cli/options")
	for _,v := range project.Resources {
		cmdImports = append(cmdImports, "cli/cmd/"+v.Name)
	}
	err = rootCommandFileInfo.AddImport(cmdImports...)
	if err != nil {
		return nil, err
	}
	log.Printf("%v", rootCommandFileInfo)
	for opt,tmpl := range map[*model.CliFile]*template.Template{
		optionsFileInfo: templates.OptionsTemplate,
		mainFileInfo: templates.MainTemplate,
	} {
		f, err := generateCliFile(opt, tmpl)
		if err != nil {
			return nil, err
		}
		v = append(v, f)
	}
	for opt,tmpl := range map[*model.CliCommandFile]*template.Template{
		rootCommandFileInfo: templates.CommandTemplate,
	} {
		f, err := generateCommandFile(opt, tmpl)
		if err != nil {
			return nil, err
		}
		v = append(v, f)
	}
	return v, nil
}


func generateCliFile(cfg *model.CliFile, tmpl *template.Template) (File, error) {
	var file File
	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, cfg); err != nil {
		return file, err
	}
	file = File{
		Filename: cfg.Filename,
		Content: buf.String(),
	}
	return file, nil
}

func generateCommandFile(cfg *model.CliCommandFile, tmpl *template.Template) (File, error) {
	var file File
	buf := &bytes.Buffer{}
	if err := tmpl.Execute(buf, cfg); err != nil {
		return file, err
	}
	file = File{
		Filename: cfg.Filename,
		Content: buf.String(),
	}
	return file, nil
}
