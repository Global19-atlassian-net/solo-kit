// Code generated by solo-kit. DO NOT EDIT.

// +build solokit

package v1

import (
	"context"
	"os"
	"time"

	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
	"github.com/solo-io/solo-kit/pkg/api/v1/clients"
	"github.com/solo-io/solo-kit/pkg/api/v1/clients/factory"
	"github.com/solo-io/solo-kit/pkg/api/v1/clients/memory"
	"github.com/solo-io/solo-kit/pkg/utils/log"
	"github.com/solo-io/solo-kit/pkg/utils/stringutils"
	"github.com/solo-io/solo-kit/test/helpers"
	"github.com/solo-io/solo-kit/test/setup"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"

	// Needed to run tests in GKE
	_ "k8s.io/client-go/plugin/pkg/client/auth"
)

var _ = Describe("V1Emitter", func() {
	if os.Getenv("RUN_KUBE_TESTS") != "1" {
		log.Printf("This test creates kubernetes resources and is disabled by default. To enable, set RUN_KUBE_TESTS=1 in your env.")
		return
	}
	var (
		namespace0       string
		name0            = helpers.RandString(8)
		cfg              *rest.Config
		emitter          KubeconfigsEmitter
		kube             kubernetes.Interface
		kubeConfigClient KubeConfigClient
	)

	BeforeEach(func() {
		namespace0 = helpers.RandString(8)
		var err error

		kube = kubernetes.NewForConfigOrDie(cfg)
		err = setup.CreateNamespacesInParallel(kube, namespace0)
		Expect(err).NotTo(HaveOccurred())
		// KubeConfig Constructor
		kubeConfigClientFactory := &factory.MemoryResourceClientFactory{
			Cache: memory.NewInMemoryResourceCache(),
		}

		kubeConfigClient, err = NewKubeConfigClient(kubeConfigClientFactory)
		Expect(err).NotTo(HaveOccurred())
		emitter = NewKubeconfigsEmitter(kubeConfigClient)
	})
	AfterEach(func() {
		setup.DeleteNamespacesInParallel(kube, namespace0)
	})

	var getAllNamespaces = func() []string {
		return []string{
			namespace0,
		}
	}

	var getAllNames = func() []string {
		return []string{
			name0,
		}
	}

	var kubeconfigsEmitterTest = func(watchNamespaces *clients.NamespacesByResourceWatcher) {
		var (
			namespaces []string
			ok         bool
		)
		ctx := context.Background()
		err := emitter.Register()
		Expect(err).NotTo(HaveOccurred())

		snapshots, errs, err := emitter.Snapshots(watchNamespaces, clients.WatchOpts{
			Ctx:         ctx,
			RefreshRate: time.Second,
		})
		Expect(err).NotTo(HaveOccurred())

		var snap *KubeconfigsSnapshot

		if watchNamespaces == nil {
			watchNamespaces = clients.NewNamespacesByResourceWatcher()
		}

		/*
			KubeConfig
		*/

		namespaces, ok = watchNamespaces.Get(kubeConfigClient.BaseWatcher())
		if !ok || namespaces == nil {
			namespaces = []string{""}
		}

		assertSnapshotkubeconfigs := func(expectkubeconfigs KubeConfigList, unexpectkubeconfigs KubeConfigList) {
		drain:
			for {
				select {
				case snap = <-snapshots:
					for _, expected := range expectkubeconfigs {
						if _, err := snap.Kubeconfigs.List().Find(expected.GetMetadata().Ref().Strings()); err != nil {
							continue drain
						}
					}
					for _, unexpected := range unexpectkubeconfigs {
						if _, err := snap.Kubeconfigs.List().Find(unexpected.GetMetadata().Ref().Strings()); err == nil {
							continue drain
						}
					}
					break drain
				case err := <-errs:
					Expect(err).NotTo(HaveOccurred())
				case <-time.After(time.Second * 10):
					combined := make(KubeconfigsByNamespace)
					for _, namespace := range namespaces {
						nsList, err := kubeConfigClient.List(namespace, clients.ListOpts{})
						Expect(err).NotTo(HaveOccurred())
						combined[namespace] = nsList
					}
					Fail("expected final snapshot before 10 seconds. expected " + log.Sprintf("%v", combined))
				}
			}
		}

		var expectedKubeConfigs KubeConfigList
		for _, name := range getAllNames() {
			for _, namespace := range getAllNamespaces() {

				kubeConfig, err := kubeConfigClient.Write(NewKubeConfig(namespace, name), clients.WriteOpts{Ctx: ctx})
				Expect(err).NotTo(HaveOccurred())
				if stringutils.ContainsString(namespace, namespaces) || (len(namespaces) == 1 && namespaces[0] == "") {
					expectedKubeConfigs = append(expectedKubeConfigs, kubeConfig)
				}
			}
		}
		assertSnapshotkubeconfigs(expectedKubeConfigs, nil)

		for _, expectedVal := range expectedKubeConfigs {
			err = kubeConfigClient.Delete(expectedVal.GetMetadata().Namespace, expectedVal.GetMetadata().Name, clients.DeleteOpts{Ctx: ctx})
			Expect(err).NotTo(HaveOccurred())
		}
		assertSnapshotkubeconfigs(nil, expectedKubeConfigs)
	}

	It("tracks snapshots on changes to any resource", func() {
		namespaces := clients.NewNamespacesByResourceWatcher()
		namespaces.Set(kubeConfigClient.BaseWatcher(), getAllNamespaces())

		kubeconfigsEmitterTest(namespaces)

	})

	It("tracks snapshots on changes to different resources in different namespaces", func() {
		namespaces := clients.NewNamespacesByResourceWatcher()
		namespaces.Set(kubeConfigClient.BaseWatcher(), []string{namespace0})

		kubeconfigsEmitterTest(namespaces)

	})

	It("tracks snapshots on changes to any resource using AllNamespace", func() {
		kubeconfigsEmitterTest(nil)
	})

})
