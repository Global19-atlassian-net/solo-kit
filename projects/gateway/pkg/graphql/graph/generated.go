// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	context "context"
	fmt "fmt"
	strconv "strconv"
	sync "sync"

	graphql "github.com/99designs/gqlgen/graphql"
	introspection "github.com/99designs/gqlgen/graphql/introspection"
	customtypes "github.com/solo-io/solo-kit/projects/gateway/pkg/graphql/customtypes"
	models "github.com/solo-io/solo-kit/projects/gateway/pkg/graphql/models"
	gqlparser "github.com/vektah/gqlparser"
	ast "github.com/vektah/gqlparser/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
	ResolverMapMutation() ResolverMapMutationResolver
	ResolverMapQuery() ResolverMapQueryResolver
	UpstreamMutation() UpstreamMutationResolver
	UpstreamQuery() UpstreamQueryResolver
	VirtualServiceMutation() VirtualServiceMutationResolver
	VirtualServiceQuery() VirtualServiceQueryResolver
}

type DirectiveRoot struct {
}
type MutationResolver interface {
	Upstreams(ctx context.Context, namespace string) (customtypes.UpstreamMutation, error)
	VirtualServices(ctx context.Context, namespace string) (customtypes.VirtualServiceMutation, error)
	ResolverMaps(ctx context.Context, namespace string) (customtypes.ResolverMapMutation, error)
}
type QueryResolver interface {
	Upstreams(ctx context.Context, namespace string) (customtypes.UpstreamQuery, error)
	VirtualServices(ctx context.Context, namespace string) (customtypes.VirtualServiceQuery, error)
	ResolverMaps(ctx context.Context, namespace string) (customtypes.ResolverMapQuery, error)
}
type ResolverMapMutationResolver interface {
	Create(ctx context.Context, obj *customtypes.ResolverMapMutation, resolverMap models.InputResolverMap) (*models.ResolverMap, error)
	Update(ctx context.Context, obj *customtypes.ResolverMapMutation, resolverMap models.InputResolverMap) (*models.ResolverMap, error)
	Delete(ctx context.Context, obj *customtypes.ResolverMapMutation, name string) (*models.ResolverMap, error)
}
type ResolverMapQueryResolver interface {
	List(ctx context.Context, obj *customtypes.ResolverMapQuery, selector *customtypes.MapStringString) ([]*models.ResolverMap, error)
	Get(ctx context.Context, obj *customtypes.ResolverMapQuery, name string) (*models.ResolverMap, error)
}
type UpstreamMutationResolver interface {
	Create(ctx context.Context, obj *customtypes.UpstreamMutation, upstream models.InputUpstream) (*models.Upstream, error)
	Update(ctx context.Context, obj *customtypes.UpstreamMutation, upstream models.InputUpstream) (*models.Upstream, error)
	Delete(ctx context.Context, obj *customtypes.UpstreamMutation, name string) (*models.Upstream, error)
}
type UpstreamQueryResolver interface {
	List(ctx context.Context, obj *customtypes.UpstreamQuery, selector *customtypes.MapStringString) ([]*models.Upstream, error)
	Get(ctx context.Context, obj *customtypes.UpstreamQuery, name string) (*models.Upstream, error)
}
type VirtualServiceMutationResolver interface {
	Create(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualService models.InputVirtualService) (*models.VirtualService, error)
	Update(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualService models.InputVirtualService) (*models.VirtualService, error)
	Delete(ctx context.Context, obj *customtypes.VirtualServiceMutation, name string) (*models.VirtualService, error)
	AddRoute(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualServiceName string, resourceVersion string, index int, route models.InputRoute) (*models.VirtualService, error)
	UpdateRoute(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualServiceName string, resourceVersion string, index int, route models.InputRoute) (*models.VirtualService, error)
	DeleteRoute(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualServiceName string, resourceVersion string, index int) (*models.VirtualService, error)
	SwapRoutes(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualServiceName string, resourceVersion string, index1 int, index2 int) (*models.VirtualService, error)
}
type VirtualServiceQueryResolver interface {
	List(ctx context.Context, obj *customtypes.VirtualServiceQuery, selector *customtypes.MapStringString) ([]*models.VirtualService, error)
	Get(ctx context.Context, obj *customtypes.VirtualServiceQuery, name string) (*models.VirtualService, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:   buf,
		Errors: ec.Errors,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:   buf,
		Errors: ec.Errors,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

var awsDestinationSpecImplementors = []string{"AwsDestinationSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AwsDestinationSpec(ctx context.Context, sel ast.SelectionSet, obj *models.AwsDestinationSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, awsDestinationSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AwsDestinationSpec")
		case "logicalName":
			out.Values[i] = ec._AwsDestinationSpec_logicalName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "invocationStyle":
			out.Values[i] = ec._AwsDestinationSpec_invocationStyle(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _AwsDestinationSpec_logicalName(ctx context.Context, field graphql.CollectedField, obj *models.AwsDestinationSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AwsDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.LogicalName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _AwsDestinationSpec_invocationStyle(ctx context.Context, field graphql.CollectedField, obj *models.AwsDestinationSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AwsDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.InvocationStyle, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.AwsLambdaInvocationStyle)
	return res
}

var awsLambdaFunctionImplementors = []string{"AwsLambdaFunction"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AwsLambdaFunction(ctx context.Context, sel ast.SelectionSet, obj *models.AwsLambdaFunction) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, awsLambdaFunctionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AwsLambdaFunction")
		case "logicalName":
			out.Values[i] = ec._AwsLambdaFunction_logicalName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "functionName":
			out.Values[i] = ec._AwsLambdaFunction_functionName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "qualifier":
			out.Values[i] = ec._AwsLambdaFunction_qualifier(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _AwsLambdaFunction_logicalName(ctx context.Context, field graphql.CollectedField, obj *models.AwsLambdaFunction) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AwsLambdaFunction",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.LogicalName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _AwsLambdaFunction_functionName(ctx context.Context, field graphql.CollectedField, obj *models.AwsLambdaFunction) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AwsLambdaFunction",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.FunctionName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _AwsLambdaFunction_qualifier(ctx context.Context, field graphql.CollectedField, obj *models.AwsLambdaFunction) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AwsLambdaFunction",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Qualifier, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

var awsUpstreamSpecImplementors = []string{"AwsUpstreamSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AwsUpstreamSpec(ctx context.Context, sel ast.SelectionSet, obj *models.AwsUpstreamSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, awsUpstreamSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AwsUpstreamSpec")
		case "region":
			out.Values[i] = ec._AwsUpstreamSpec_region(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "secretRef":
			out.Values[i] = ec._AwsUpstreamSpec_secretRef(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "functions":
			out.Values[i] = ec._AwsUpstreamSpec_functions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _AwsUpstreamSpec_region(ctx context.Context, field graphql.CollectedField, obj *models.AwsUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AwsUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Region, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _AwsUpstreamSpec_secretRef(ctx context.Context, field graphql.CollectedField, obj *models.AwsUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AwsUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.SecretRef, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _AwsUpstreamSpec_functions(ctx context.Context, field graphql.CollectedField, obj *models.AwsUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AwsUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Functions, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.AwsLambdaFunction)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._AwsLambdaFunction(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var azureDestinationSpecImplementors = []string{"AzureDestinationSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AzureDestinationSpec(ctx context.Context, sel ast.SelectionSet, obj *models.AzureDestinationSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, azureDestinationSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AzureDestinationSpec")
		case "functionName":
			out.Values[i] = ec._AzureDestinationSpec_functionName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _AzureDestinationSpec_functionName(ctx context.Context, field graphql.CollectedField, obj *models.AzureDestinationSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AzureDestinationSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.FunctionName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

var azureFunctionImplementors = []string{"AzureFunction"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AzureFunction(ctx context.Context, sel ast.SelectionSet, obj *models.AzureFunction) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, azureFunctionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AzureFunction")
		case "functionName":
			out.Values[i] = ec._AzureFunction_functionName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "authLevel":
			out.Values[i] = ec._AzureFunction_authLevel(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _AzureFunction_functionName(ctx context.Context, field graphql.CollectedField, obj *models.AzureFunction) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AzureFunction",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.FunctionName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _AzureFunction_authLevel(ctx context.Context, field graphql.CollectedField, obj *models.AzureFunction) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AzureFunction",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.AuthLevel, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

var azureUpstreamSpecImplementors = []string{"AzureUpstreamSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AzureUpstreamSpec(ctx context.Context, sel ast.SelectionSet, obj *models.AzureUpstreamSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, azureUpstreamSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AzureUpstreamSpec")
		case "functionAppName":
			out.Values[i] = ec._AzureUpstreamSpec_functionAppName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "secretRef":
			out.Values[i] = ec._AzureUpstreamSpec_secretRef(ctx, field, obj)
		case "functions":
			out.Values[i] = ec._AzureUpstreamSpec_functions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _AzureUpstreamSpec_functionAppName(ctx context.Context, field graphql.CollectedField, obj *models.AzureUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AzureUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.FunctionAppName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _AzureUpstreamSpec_secretRef(ctx context.Context, field graphql.CollectedField, obj *models.AzureUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AzureUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.SecretRef, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) _AzureUpstreamSpec_functions(ctx context.Context, field graphql.CollectedField, obj *models.AzureUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "AzureUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Functions, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.AzureFunction)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._AzureFunction(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var fieldResolverImplementors = []string{"FieldResolver"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _FieldResolver(ctx context.Context, sel ast.SelectionSet, obj *models.FieldResolver) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, fieldResolverImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FieldResolver")
		case "fieldName":
			out.Values[i] = ec._FieldResolver_fieldName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "resolver":
			out.Values[i] = ec._FieldResolver_resolver(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _FieldResolver_fieldName(ctx context.Context, field graphql.CollectedField, obj *models.FieldResolver) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "FieldResolver",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.FieldName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _FieldResolver_resolver(ctx context.Context, field graphql.CollectedField, obj *models.FieldResolver) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "FieldResolver",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Resolver, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Resolver)
	return ec._Resolver(ctx, field.Selections, &res)
}

var gRPCServiceSpecImplementors = []string{"GRPCServiceSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _GRPCServiceSpec(ctx context.Context, sel ast.SelectionSet, obj *models.GRPCServiceSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, gRPCServiceSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GRPCServiceSpec")
		case "empty":
			out.Values[i] = ec._GRPCServiceSpec_empty(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _GRPCServiceSpec_empty(ctx context.Context, field graphql.CollectedField, obj *models.GRPCServiceSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "GRPCServiceSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Empty, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var glooResolverImplementors = []string{"GlooResolver"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _GlooResolver(ctx context.Context, sel ast.SelectionSet, obj *models.GlooResolver) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, glooResolverImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GlooResolver")
		case "empty":
			out.Values[i] = ec._GlooResolver_empty(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _GlooResolver_empty(ctx context.Context, field graphql.CollectedField, obj *models.GlooResolver) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "GlooResolver",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Empty, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var keyValueMatcherImplementors = []string{"KeyValueMatcher"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _KeyValueMatcher(ctx context.Context, sel ast.SelectionSet, obj *models.KeyValueMatcher) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, keyValueMatcherImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KeyValueMatcher")
		case "name":
			out.Values[i] = ec._KeyValueMatcher_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "value":
			out.Values[i] = ec._KeyValueMatcher_value(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isRegex":
			out.Values[i] = ec._KeyValueMatcher_isRegex(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _KeyValueMatcher_name(ctx context.Context, field graphql.CollectedField, obj *models.KeyValueMatcher) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "KeyValueMatcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _KeyValueMatcher_value(ctx context.Context, field graphql.CollectedField, obj *models.KeyValueMatcher) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "KeyValueMatcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Value, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _KeyValueMatcher_isRegex(ctx context.Context, field graphql.CollectedField, obj *models.KeyValueMatcher) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "KeyValueMatcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.IsRegex, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	return graphql.MarshalBoolean(res)
}

var kubeUpstreamSpecImplementors = []string{"KubeUpstreamSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _KubeUpstreamSpec(ctx context.Context, sel ast.SelectionSet, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, kubeUpstreamSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KubeUpstreamSpec")
		case "serviceName":
			out.Values[i] = ec._KubeUpstreamSpec_serviceName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "serviceNamespace":
			out.Values[i] = ec._KubeUpstreamSpec_serviceNamespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "servicePort":
			out.Values[i] = ec._KubeUpstreamSpec_servicePort(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "selector":
			out.Values[i] = ec._KubeUpstreamSpec_selector(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _KubeUpstreamSpec_serviceName(ctx context.Context, field graphql.CollectedField, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "KubeUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.ServiceName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _KubeUpstreamSpec_serviceNamespace(ctx context.Context, field graphql.CollectedField, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "KubeUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.ServiceNamespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _KubeUpstreamSpec_servicePort(ctx context.Context, field graphql.CollectedField, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "KubeUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.ServicePort, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	return graphql.MarshalInt(res)
}

func (ec *executionContext) _KubeUpstreamSpec_selector(ctx context.Context, field graphql.CollectedField, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "KubeUpstreamSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Selector, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*customtypes.MapStringString)

	if res == nil {
		return graphql.Null
	}
	return *res
}

var matcherImplementors = []string{"Matcher"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Matcher(ctx context.Context, sel ast.SelectionSet, obj *models.Matcher) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, matcherImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Matcher")
		case "pathMatch":
			out.Values[i] = ec._Matcher_pathMatch(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "pathMatchType":
			out.Values[i] = ec._Matcher_pathMatchType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "headers":
			out.Values[i] = ec._Matcher_headers(ctx, field, obj)
		case "queryParameters":
			out.Values[i] = ec._Matcher_queryParameters(ctx, field, obj)
		case "methods":
			out.Values[i] = ec._Matcher_methods(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _Matcher_pathMatch(ctx context.Context, field graphql.CollectedField, obj *models.Matcher) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Matcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.PathMatch, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Matcher_pathMatchType(ctx context.Context, field graphql.CollectedField, obj *models.Matcher) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Matcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.PathMatchType, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.PathMatchType)
	return res
}

func (ec *executionContext) _Matcher_headers(ctx context.Context, field graphql.CollectedField, obj *models.Matcher) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Matcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Headers, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.KeyValueMatcher)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._KeyValueMatcher(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _Matcher_queryParameters(ctx context.Context, field graphql.CollectedField, obj *models.Matcher) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Matcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.QueryParameters, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.KeyValueMatcher)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._KeyValueMatcher(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _Matcher_methods(ctx context.Context, field graphql.CollectedField, obj *models.Matcher) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Matcher",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Methods, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return graphql.MarshalString(res[idx1])
		}())
	}
	return arr1
}

var metadataImplementors = []string{"Metadata"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Metadata(ctx context.Context, sel ast.SelectionSet, obj *models.Metadata) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, metadataImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Metadata")
		case "name":
			out.Values[i] = ec._Metadata_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "namespace":
			out.Values[i] = ec._Metadata_namespace(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "resourceVersion":
			out.Values[i] = ec._Metadata_resourceVersion(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "labels":
			out.Values[i] = ec._Metadata_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._Metadata_annotations(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _Metadata_name(ctx context.Context, field graphql.CollectedField, obj *models.Metadata) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Metadata",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Metadata_namespace(ctx context.Context, field graphql.CollectedField, obj *models.Metadata) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Metadata",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Namespace, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Metadata_resourceVersion(ctx context.Context, field graphql.CollectedField, obj *models.Metadata) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Metadata",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.ResourceVersion, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Metadata_labels(ctx context.Context, field graphql.CollectedField, obj *models.Metadata) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Metadata",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Labels, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*customtypes.MapStringString)

	if res == nil {
		return graphql.Null
	}
	return *res
}

func (ec *executionContext) _Metadata_annotations(ctx context.Context, field graphql.CollectedField, obj *models.Metadata) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Metadata",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Annotations, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*customtypes.MapStringString)

	if res == nil {
		return graphql.Null
	}
	return *res
}

var multiDestinationImplementors = []string{"MultiDestination"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _MultiDestination(ctx context.Context, sel ast.SelectionSet, obj *models.MultiDestination) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, multiDestinationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MultiDestination")
		case "destinations":
			out.Values[i] = ec._MultiDestination_destinations(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _MultiDestination_destinations(ctx context.Context, field graphql.CollectedField, obj *models.MultiDestination) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "MultiDestination",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Destinations, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.WeightedDestination)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._WeightedDestination(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var mutationImplementors = []string{"Mutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, mutationImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "upstreams":
			out.Values[i] = ec._Mutation_upstreams(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "virtualServices":
			out.Values[i] = ec._Mutation_virtualServices(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "resolverMaps":
			out.Values[i] = ec._Mutation_resolverMaps(ctx, field)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _Mutation_upstreams(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["namespace"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation().Upstreams(ctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.UpstreamMutation)
	return ec._UpstreamMutation(ctx, field.Selections, &res)
}

func (ec *executionContext) _Mutation_virtualServices(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["namespace"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation().VirtualServices(ctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.VirtualServiceMutation)
	return ec._VirtualServiceMutation(ctx, field.Selections, &res)
}

func (ec *executionContext) _Mutation_resolverMaps(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["namespace"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "Mutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation().ResolverMaps(ctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.ResolverMapMutation)
	return ec._ResolverMapMutation(ctx, field.Selections, &res)
}

var nodeJSResolverImplementors = []string{"NodeJSResolver"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _NodeJSResolver(ctx context.Context, sel ast.SelectionSet, obj *models.NodeJSResolver) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, nodeJSResolverImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NodeJSResolver")
		case "empty":
			out.Values[i] = ec._NodeJSResolver_empty(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _NodeJSResolver_empty(ctx context.Context, field graphql.CollectedField, obj *models.NodeJSResolver) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "NodeJSResolver",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Empty, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var queryImplementors = []string{"Query"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "upstreams":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_upstreams(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "virtualServices":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_virtualServices(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "resolverMaps":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._Query_resolverMaps(ctx, field)
				if out.Values[i] == graphql.Null {
					invalid = true
				}
				wg.Done()
			}(i, field)
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _Query_upstreams(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["namespace"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Query().Upstreams(ctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.UpstreamQuery)
	return ec._UpstreamQuery(ctx, field.Selections, &res)
}

func (ec *executionContext) _Query_virtualServices(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["namespace"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Query().VirtualServices(ctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.VirtualServiceQuery)
	return ec._VirtualServiceQuery(ctx, field.Selections, &res)
}

func (ec *executionContext) _Query_resolverMaps(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["namespace"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Query().ResolverMaps(ctx, args["namespace"].(string))
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(customtypes.ResolverMapQuery)
	return ec._ResolverMapQuery(ctx, field.Selections, &res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.introspectType(args["name"].(string)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)

	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.introspectSchema(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)

	if res == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, field.Selections, res)
}

var resolverMapImplementors = []string{"ResolverMap"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResolverMap(ctx context.Context, sel ast.SelectionSet, obj *models.ResolverMap) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resolverMapImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResolverMap")
		case "types":
			out.Values[i] = ec._ResolverMap_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "metadata":
			out.Values[i] = ec._ResolverMap_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._ResolverMap_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _ResolverMap_types(ctx context.Context, field graphql.CollectedField, obj *models.ResolverMap) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "ResolverMap",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Types, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.TypeResolver)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._TypeResolver(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _ResolverMap_metadata(ctx context.Context, field graphql.CollectedField, obj *models.ResolverMap) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "ResolverMap",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Metadata, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Metadata)
	return ec._Metadata(ctx, field.Selections, &res)
}

func (ec *executionContext) _ResolverMap_status(ctx context.Context, field graphql.CollectedField, obj *models.ResolverMap) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "ResolverMap",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Status)
	return ec._Status(ctx, field.Selections, &res)
}

var resolverMapMutationImplementors = []string{"ResolverMapMutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResolverMapMutation(ctx context.Context, sel ast.SelectionSet, obj *customtypes.ResolverMapMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resolverMapMutationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResolverMapMutation")
		case "create":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ResolverMapMutation_create(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "update":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ResolverMapMutation_update(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "delete":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ResolverMapMutation_delete(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _ResolverMapMutation_create(ctx context.Context, field graphql.CollectedField, obj *customtypes.ResolverMapMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 models.InputResolverMap
	if tmp, ok := rawArgs["resolverMap"]; ok {
		var err error
		arg0, err = UnmarshalInputResolverMap(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["resolverMap"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "ResolverMapMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.ResolverMapMutation().Create(ctx, obj, args["resolverMap"].(models.InputResolverMap))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ResolverMap)

	if res == nil {
		return graphql.Null
	}
	return ec._ResolverMap(ctx, field.Selections, res)
}

func (ec *executionContext) _ResolverMapMutation_update(ctx context.Context, field graphql.CollectedField, obj *customtypes.ResolverMapMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 models.InputResolverMap
	if tmp, ok := rawArgs["resolverMap"]; ok {
		var err error
		arg0, err = UnmarshalInputResolverMap(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["resolverMap"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "ResolverMapMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.ResolverMapMutation().Update(ctx, obj, args["resolverMap"].(models.InputResolverMap))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ResolverMap)

	if res == nil {
		return graphql.Null
	}
	return ec._ResolverMap(ctx, field.Selections, res)
}

func (ec *executionContext) _ResolverMapMutation_delete(ctx context.Context, field graphql.CollectedField, obj *customtypes.ResolverMapMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "ResolverMapMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.ResolverMapMutation().Delete(ctx, obj, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ResolverMap)

	if res == nil {
		return graphql.Null
	}
	return ec._ResolverMap(ctx, field.Selections, res)
}

var resolverMapQueryImplementors = []string{"ResolverMapQuery"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResolverMapQuery(ctx context.Context, sel ast.SelectionSet, obj *customtypes.ResolverMapQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resolverMapQueryImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResolverMapQuery")
		case "list":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ResolverMapQuery_list(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "get":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._ResolverMapQuery_get(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _ResolverMapQuery_list(ctx context.Context, field graphql.CollectedField, obj *customtypes.ResolverMapQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 *customtypes.MapStringString
	if tmp, ok := rawArgs["selector"]; ok {
		var err error
		var ptr1 customtypes.MapStringString
		if tmp != nil {
			err = (&ptr1).UnmarshalGQL(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["selector"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "ResolverMapQuery",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.ResolverMapQuery().List(ctx, obj, args["selector"].(*customtypes.MapStringString))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.ResolverMap)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()

			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._ResolverMap(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _ResolverMapQuery_get(ctx context.Context, field graphql.CollectedField, obj *customtypes.ResolverMapQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "ResolverMapQuery",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.ResolverMapQuery().Get(ctx, obj, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ResolverMap)

	if res == nil {
		return graphql.Null
	}
	return ec._ResolverMap(ctx, field.Selections, res)
}

var routeImplementors = []string{"Route"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Route(ctx context.Context, sel ast.SelectionSet, obj *models.Route) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, routeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Route")
		case "matcher":
			out.Values[i] = ec._Route_matcher(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "destination":
			out.Values[i] = ec._Route_destination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "plugins":
			out.Values[i] = ec._Route_plugins(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _Route_matcher(ctx context.Context, field graphql.CollectedField, obj *models.Route) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Route",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Matcher, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Matcher)
	return ec._Matcher(ctx, field.Selections, &res)
}

func (ec *executionContext) _Route_destination(ctx context.Context, field graphql.CollectedField, obj *models.Route) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Route",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Destination, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Destination)
	return ec._Destination(ctx, field.Selections, &res)
}

func (ec *executionContext) _Route_plugins(ctx context.Context, field graphql.CollectedField, obj *models.Route) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Route",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Plugins, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.RoutePlugins)

	if res == nil {
		return graphql.Null
	}
	return ec._RoutePlugins(ctx, field.Selections, res)
}

var routePluginsImplementors = []string{"RoutePlugins"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _RoutePlugins(ctx context.Context, sel ast.SelectionSet, obj *models.RoutePlugins) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, routePluginsImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoutePlugins")
		case "empty":
			out.Values[i] = ec._RoutePlugins_empty(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _RoutePlugins_empty(ctx context.Context, field graphql.CollectedField, obj *models.RoutePlugins) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "RoutePlugins",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Empty, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var singleDestinationImplementors = []string{"SingleDestination"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SingleDestination(ctx context.Context, sel ast.SelectionSet, obj *models.SingleDestination) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, singleDestinationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SingleDestination")
		case "upstreamName":
			out.Values[i] = ec._SingleDestination_upstreamName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "destinationSpec":
			out.Values[i] = ec._SingleDestination_destinationSpec(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _SingleDestination_upstreamName(ctx context.Context, field graphql.CollectedField, obj *models.SingleDestination) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SingleDestination",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.UpstreamName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _SingleDestination_destinationSpec(ctx context.Context, field graphql.CollectedField, obj *models.SingleDestination) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SingleDestination",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.DestinationSpec, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.DestinationSpec)
	return ec._DestinationSpec(ctx, field.Selections, &res)
}

var sslConfigImplementors = []string{"SslConfig"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SslConfig(ctx context.Context, sel ast.SelectionSet, obj *models.SslConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, sslConfigImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SslConfig")
		case "secretRef":
			out.Values[i] = ec._SslConfig_secretRef(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _SslConfig_secretRef(ctx context.Context, field graphql.CollectedField, obj *models.SslConfig) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SslConfig",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.SecretRef, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

var statusImplementors = []string{"Status"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Status(ctx context.Context, sel ast.SelectionSet, obj *models.Status) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, statusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Status")
		case "state":
			out.Values[i] = ec._Status_state(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "reason":
			out.Values[i] = ec._Status_reason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _Status_state(ctx context.Context, field graphql.CollectedField, obj *models.Status) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Status",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.State, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.State)
	return res
}

func (ec *executionContext) _Status_reason(ctx context.Context, field graphql.CollectedField, obj *models.Status) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Status",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Reason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var swaggerServiceSpecImplementors = []string{"SwaggerServiceSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SwaggerServiceSpec(ctx context.Context, sel ast.SelectionSet, obj *models.SwaggerServiceSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, swaggerServiceSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SwaggerServiceSpec")
		case "empty":
			out.Values[i] = ec._SwaggerServiceSpec_empty(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _SwaggerServiceSpec_empty(ctx context.Context, field graphql.CollectedField, obj *models.SwaggerServiceSpec) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "SwaggerServiceSpec",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Empty, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var templateResolverImplementors = []string{"TemplateResolver"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _TemplateResolver(ctx context.Context, sel ast.SelectionSet, obj *models.TemplateResolver) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, templateResolverImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TemplateResolver")
		case "empty":
			out.Values[i] = ec._TemplateResolver_empty(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _TemplateResolver_empty(ctx context.Context, field graphql.CollectedField, obj *models.TemplateResolver) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "TemplateResolver",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Empty, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var typeResolverImplementors = []string{"TypeResolver"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _TypeResolver(ctx context.Context, sel ast.SelectionSet, obj *models.TypeResolver) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, typeResolverImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeResolver")
		case "typeName":
			out.Values[i] = ec._TypeResolver_typeName(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "fields":
			out.Values[i] = ec._TypeResolver_fields(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _TypeResolver_typeName(ctx context.Context, field graphql.CollectedField, obj *models.TypeResolver) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "TypeResolver",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.TypeName, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _TypeResolver_fields(ctx context.Context, field graphql.CollectedField, obj *models.TypeResolver) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "TypeResolver",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Fields, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]models.FieldResolver)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._FieldResolver(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var upstreamImplementors = []string{"Upstream"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Upstream(ctx context.Context, sel ast.SelectionSet, obj *models.Upstream) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, upstreamImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Upstream")
		case "spec":
			out.Values[i] = ec._Upstream_spec(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "metadata":
			out.Values[i] = ec._Upstream_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._Upstream_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _Upstream_spec(ctx context.Context, field graphql.CollectedField, obj *models.Upstream) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Upstream",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Spec, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.UpstreamSpec)
	return ec._UpstreamSpec(ctx, field.Selections, &res)
}

func (ec *executionContext) _Upstream_metadata(ctx context.Context, field graphql.CollectedField, obj *models.Upstream) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Upstream",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Metadata, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Metadata)
	return ec._Metadata(ctx, field.Selections, &res)
}

func (ec *executionContext) _Upstream_status(ctx context.Context, field graphql.CollectedField, obj *models.Upstream) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "Upstream",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Status)
	return ec._Status(ctx, field.Selections, &res)
}

var upstreamMutationImplementors = []string{"UpstreamMutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UpstreamMutation(ctx context.Context, sel ast.SelectionSet, obj *customtypes.UpstreamMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, upstreamMutationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpstreamMutation")
		case "create":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._UpstreamMutation_create(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "update":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._UpstreamMutation_update(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "delete":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._UpstreamMutation_delete(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _UpstreamMutation_create(ctx context.Context, field graphql.CollectedField, obj *customtypes.UpstreamMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 models.InputUpstream
	if tmp, ok := rawArgs["upstream"]; ok {
		var err error
		arg0, err = UnmarshalInputUpstream(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["upstream"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "UpstreamMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.UpstreamMutation().Create(ctx, obj, args["upstream"].(models.InputUpstream))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Upstream)

	if res == nil {
		return graphql.Null
	}
	return ec._Upstream(ctx, field.Selections, res)
}

func (ec *executionContext) _UpstreamMutation_update(ctx context.Context, field graphql.CollectedField, obj *customtypes.UpstreamMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 models.InputUpstream
	if tmp, ok := rawArgs["upstream"]; ok {
		var err error
		arg0, err = UnmarshalInputUpstream(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["upstream"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "UpstreamMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.UpstreamMutation().Update(ctx, obj, args["upstream"].(models.InputUpstream))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Upstream)

	if res == nil {
		return graphql.Null
	}
	return ec._Upstream(ctx, field.Selections, res)
}

func (ec *executionContext) _UpstreamMutation_delete(ctx context.Context, field graphql.CollectedField, obj *customtypes.UpstreamMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "UpstreamMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.UpstreamMutation().Delete(ctx, obj, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Upstream)

	if res == nil {
		return graphql.Null
	}
	return ec._Upstream(ctx, field.Selections, res)
}

var upstreamQueryImplementors = []string{"UpstreamQuery"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UpstreamQuery(ctx context.Context, sel ast.SelectionSet, obj *customtypes.UpstreamQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, upstreamQueryImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpstreamQuery")
		case "list":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._UpstreamQuery_list(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "get":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._UpstreamQuery_get(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _UpstreamQuery_list(ctx context.Context, field graphql.CollectedField, obj *customtypes.UpstreamQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 *customtypes.MapStringString
	if tmp, ok := rawArgs["selector"]; ok {
		var err error
		var ptr1 customtypes.MapStringString
		if tmp != nil {
			err = (&ptr1).UnmarshalGQL(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["selector"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "UpstreamQuery",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.UpstreamQuery().List(ctx, obj, args["selector"].(*customtypes.MapStringString))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.Upstream)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()

			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._Upstream(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _UpstreamQuery_get(ctx context.Context, field graphql.CollectedField, obj *customtypes.UpstreamQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "UpstreamQuery",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.UpstreamQuery().Get(ctx, obj, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.Upstream)

	if res == nil {
		return graphql.Null
	}
	return ec._Upstream(ctx, field.Selections, res)
}

var virtualServiceImplementors = []string{"VirtualService"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _VirtualService(ctx context.Context, sel ast.SelectionSet, obj *models.VirtualService) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, virtualServiceImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VirtualService")
		case "domains":
			out.Values[i] = ec._VirtualService_domains(ctx, field, obj)
		case "routes":
			out.Values[i] = ec._VirtualService_routes(ctx, field, obj)
		case "sslConfig":
			out.Values[i] = ec._VirtualService_sslConfig(ctx, field, obj)
		case "plugins":
			out.Values[i] = ec._VirtualService_plugins(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._VirtualService_metadata(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "status":
			out.Values[i] = ec._VirtualService_status(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _VirtualService_domains(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "VirtualService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Domains, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return graphql.MarshalString(res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _VirtualService_routes(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "VirtualService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Routes, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.Route)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._Route(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _VirtualService_sslConfig(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "VirtualService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.SslConfig, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.SslConfig)

	if res == nil {
		return graphql.Null
	}
	return ec._SslConfig(ctx, field.Selections, res)
}

func (ec *executionContext) _VirtualService_plugins(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "VirtualService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Plugins, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualServicePlugins)

	if res == nil {
		return graphql.Null
	}
	return ec._VirtualServicePlugins(ctx, field.Selections, res)
}

func (ec *executionContext) _VirtualService_metadata(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "VirtualService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Metadata, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Metadata)
	return ec._Metadata(ctx, field.Selections, &res)
}

func (ec *executionContext) _VirtualService_status(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "VirtualService",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Status, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.Status)
	return ec._Status(ctx, field.Selections, &res)
}

var virtualServiceMutationImplementors = []string{"VirtualServiceMutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _VirtualServiceMutation(ctx context.Context, sel ast.SelectionSet, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, virtualServiceMutationImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VirtualServiceMutation")
		case "create":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_create(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "update":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_update(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "delete":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_delete(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "addRoute":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_addRoute(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "updateRoute":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_updateRoute(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "deleteRoute":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_deleteRoute(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "swapRoutes":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceMutation_swapRoutes(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _VirtualServiceMutation_create(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 models.InputVirtualService
	if tmp, ok := rawArgs["virtualService"]; ok {
		var err error
		arg0, err = UnmarshalInputVirtualService(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["virtualService"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.VirtualServiceMutation().Create(ctx, obj, args["virtualService"].(models.InputVirtualService))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)

	if res == nil {
		return graphql.Null
	}
	return ec._VirtualService(ctx, field.Selections, res)
}

func (ec *executionContext) _VirtualServiceMutation_update(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 models.InputVirtualService
	if tmp, ok := rawArgs["virtualService"]; ok {
		var err error
		arg0, err = UnmarshalInputVirtualService(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["virtualService"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.VirtualServiceMutation().Update(ctx, obj, args["virtualService"].(models.InputVirtualService))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)

	if res == nil {
		return graphql.Null
	}
	return ec._VirtualService(ctx, field.Selections, res)
}

func (ec *executionContext) _VirtualServiceMutation_delete(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.VirtualServiceMutation().Delete(ctx, obj, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)

	if res == nil {
		return graphql.Null
	}
	return ec._VirtualService(ctx, field.Selections, res)
}

func (ec *executionContext) _VirtualServiceMutation_addRoute(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["virtualServiceName"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["virtualServiceName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["resourceVersion"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["index"]; ok {
		var err error
		arg2, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["index"] = arg2
	var arg3 models.InputRoute
	if tmp, ok := rawArgs["route"]; ok {
		var err error
		arg3, err = UnmarshalInputRoute(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["route"] = arg3
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.VirtualServiceMutation().AddRoute(ctx, obj, args["virtualServiceName"].(string), args["resourceVersion"].(string), args["index"].(int), args["route"].(models.InputRoute))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)

	if res == nil {
		return graphql.Null
	}
	return ec._VirtualService(ctx, field.Selections, res)
}

func (ec *executionContext) _VirtualServiceMutation_updateRoute(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["virtualServiceName"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["virtualServiceName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["resourceVersion"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["index"]; ok {
		var err error
		arg2, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["index"] = arg2
	var arg3 models.InputRoute
	if tmp, ok := rawArgs["route"]; ok {
		var err error
		arg3, err = UnmarshalInputRoute(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["route"] = arg3
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.VirtualServiceMutation().UpdateRoute(ctx, obj, args["virtualServiceName"].(string), args["resourceVersion"].(string), args["index"].(int), args["route"].(models.InputRoute))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)

	if res == nil {
		return graphql.Null
	}
	return ec._VirtualService(ctx, field.Selections, res)
}

func (ec *executionContext) _VirtualServiceMutation_deleteRoute(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["virtualServiceName"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["virtualServiceName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["resourceVersion"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["index"]; ok {
		var err error
		arg2, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["index"] = arg2
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.VirtualServiceMutation().DeleteRoute(ctx, obj, args["virtualServiceName"].(string), args["resourceVersion"].(string), args["index"].(int))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)

	if res == nil {
		return graphql.Null
	}
	return ec._VirtualService(ctx, field.Selections, res)
}

func (ec *executionContext) _VirtualServiceMutation_swapRoutes(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["virtualServiceName"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["virtualServiceName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["resourceVersion"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["index1"]; ok {
		var err error
		arg2, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["index1"] = arg2
	var arg3 int
	if tmp, ok := rawArgs["index2"]; ok {
		var err error
		arg3, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["index2"] = arg3
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.VirtualServiceMutation().SwapRoutes(ctx, obj, args["virtualServiceName"].(string), args["resourceVersion"].(string), args["index1"].(int), args["index2"].(int))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)

	if res == nil {
		return graphql.Null
	}
	return ec._VirtualService(ctx, field.Selections, res)
}

var virtualServicePluginsImplementors = []string{"VirtualServicePlugins"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _VirtualServicePlugins(ctx context.Context, sel ast.SelectionSet, obj *models.VirtualServicePlugins) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, virtualServicePluginsImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VirtualServicePlugins")
		case "empty":
			out.Values[i] = ec._VirtualServicePlugins_empty(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _VirtualServicePlugins_empty(ctx context.Context, field graphql.CollectedField, obj *models.VirtualServicePlugins) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "VirtualServicePlugins",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Empty, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var virtualServiceQueryImplementors = []string{"VirtualServiceQuery"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _VirtualServiceQuery(ctx context.Context, sel ast.SelectionSet, obj *customtypes.VirtualServiceQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, virtualServiceQueryImplementors)

	var wg sync.WaitGroup
	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VirtualServiceQuery")
		case "list":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceQuery_list(ctx, field, obj)
				wg.Done()
			}(i, field)
		case "get":
			wg.Add(1)
			go func(i int, field graphql.CollectedField) {
				out.Values[i] = ec._VirtualServiceQuery_get(ctx, field, obj)
				wg.Done()
			}(i, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}
	wg.Wait()
	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _VirtualServiceQuery_list(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 *customtypes.MapStringString
	if tmp, ok := rawArgs["selector"]; ok {
		var err error
		var ptr1 customtypes.MapStringString
		if tmp != nil {
			err = (&ptr1).UnmarshalGQL(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["selector"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceQuery",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.VirtualServiceQuery().List(ctx, obj, args["selector"].(*customtypes.MapStringString))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]*models.VirtualService)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()

			if res[idx1] == nil {
				return graphql.Null
			}
			return ec._VirtualService(ctx, field.Selections, res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _VirtualServiceQuery_get(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "VirtualServiceQuery",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.VirtualServiceQuery().Get(ctx, obj, args["name"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualService)

	if res == nil {
		return graphql.Null
	}
	return ec._VirtualService(ctx, field.Selections, res)
}

var weightedDestinationImplementors = []string{"WeightedDestination"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _WeightedDestination(ctx context.Context, sel ast.SelectionSet, obj *models.WeightedDestination) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, weightedDestinationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WeightedDestination")
		case "destination":
			out.Values[i] = ec._WeightedDestination_destination(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "weight":
			out.Values[i] = ec._WeightedDestination_weight(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) _WeightedDestination_destination(ctx context.Context, field graphql.CollectedField, obj *models.WeightedDestination) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "WeightedDestination",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Destination, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(models.SingleDestination)
	return ec._SingleDestination(ctx, field.Selections, &res)
}

func (ec *executionContext) _WeightedDestination_weight(ctx context.Context, field graphql.CollectedField, obj *models.WeightedDestination) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "WeightedDestination",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Weight, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(int)
	return graphql.MarshalInt(res)
}

var __DirectiveImplementors = []string{"__Directive"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __DirectiveImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Locations, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]string)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return graphql.MarshalString(res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Directive",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var __EnumValueImplementors = []string{"__EnumValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __EnumValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.IsDeprecated, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__EnumValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.DeprecationReason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

var __FieldImplementors = []string{"__Field"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __FieldImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Args, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.IsDeprecated, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(bool)
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Field",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.DeprecationReason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

var __InputValueImplementors = []string{"__InputValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __InputValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Name, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Type, nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__InputValue",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.DefaultValue, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __SchemaImplementors = []string{"__Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __SchemaImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Types(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.QueryType(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)

	if res == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.MutationType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)

	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.SubscriptionType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)

	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Schema",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Directives(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Directive(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var __TypeImplementors = []string{"__Type"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __TypeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	invalid := false
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
			if out.Values[i] == graphql.Null {
				invalid = true
			}
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	if invalid {
		return graphql.Null
	}
	return out
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Kind(), nil
	})
	if resTmp == nil {
		if !ec.HasError(rctx) {
			ec.Errorf(ctx, "must not be null")
		}
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Name(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)

	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Description(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["includeDeprecated"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Field(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Interfaces(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.PossibleTypes(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["includeDeprecated"] = arg0
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   args,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___EnumValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.InputFields(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := &graphql.ResolverContext{
		Object: "__Type",
		Args:   nil,
		Field:  field,
	}
	ctx = graphql.WithResolverContext(ctx, rctx)
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.OfType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)

	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) _Destination(ctx context.Context, sel ast.SelectionSet, obj *models.Destination) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.MultiDestination:
		return ec._MultiDestination(ctx, sel, &obj)
	case *models.MultiDestination:
		return ec._MultiDestination(ctx, sel, obj)
	case models.SingleDestination:
		return ec._SingleDestination(ctx, sel, &obj)
	case *models.SingleDestination:
		return ec._SingleDestination(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _DestinationSpec(ctx context.Context, sel ast.SelectionSet, obj *models.DestinationSpec) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.AwsDestinationSpec:
		return ec._AwsDestinationSpec(ctx, sel, &obj)
	case *models.AwsDestinationSpec:
		return ec._AwsDestinationSpec(ctx, sel, obj)
	case models.AzureDestinationSpec:
		return ec._AzureDestinationSpec(ctx, sel, &obj)
	case *models.AzureDestinationSpec:
		return ec._AzureDestinationSpec(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Resolver(ctx context.Context, sel ast.SelectionSet, obj *models.Resolver) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.GlooResolver:
		return ec._GlooResolver(ctx, sel, &obj)
	case *models.GlooResolver:
		return ec._GlooResolver(ctx, sel, obj)
	case models.TemplateResolver:
		return ec._TemplateResolver(ctx, sel, &obj)
	case *models.TemplateResolver:
		return ec._TemplateResolver(ctx, sel, obj)
	case models.NodeJSResolver:
		return ec._NodeJSResolver(ctx, sel, &obj)
	case *models.NodeJSResolver:
		return ec._NodeJSResolver(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ServiceSpec(ctx context.Context, sel ast.SelectionSet, obj *models.ServiceSpec) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.SwaggerServiceSpec:
		return ec._SwaggerServiceSpec(ctx, sel, &obj)
	case *models.SwaggerServiceSpec:
		return ec._SwaggerServiceSpec(ctx, sel, obj)
	case models.GRPCServiceSpec:
		return ec._GRPCServiceSpec(ctx, sel, &obj)
	case *models.GRPCServiceSpec:
		return ec._GRPCServiceSpec(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpstreamSpec(ctx context.Context, sel ast.SelectionSet, obj *models.UpstreamSpec) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.AwsUpstreamSpec:
		return ec._AwsUpstreamSpec(ctx, sel, &obj)
	case *models.AwsUpstreamSpec:
		return ec._AwsUpstreamSpec(ctx, sel, obj)
	case models.AzureUpstreamSpec:
		return ec._AzureUpstreamSpec(ctx, sel, &obj)
	case *models.AzureUpstreamSpec:
		return ec._AzureUpstreamSpec(ctx, sel, obj)
	case models.KubeUpstreamSpec:
		return ec._KubeUpstreamSpec(ctx, sel, &obj)
	case *models.KubeUpstreamSpec:
		return ec._KubeUpstreamSpec(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func UnmarshalInputAwsDestinationSpec(v interface{}) (models.InputAwsDestinationSpec, error) {
	var it models.InputAwsDestinationSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "logicalName":
			var err error
			it.LogicalName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "invocationStyle":
			var err error
			err = (&it.InvocationStyle).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAwsLambdaFunction(v interface{}) (models.InputAwsLambdaFunction, error) {
	var it models.InputAwsLambdaFunction
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "logicalName":
			var err error
			it.LogicalName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "functionName":
			var err error
			it.FunctionName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "qualifier":
			var err error
			it.Qualifier, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAwsUpstreamSpec(v interface{}) (models.InputAwsUpstreamSpec, error) {
	var it models.InputAwsUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "region":
			var err error
			it.Region, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "secretRef":
			var err error
			it.SecretRef, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "functions":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Functions = make([]models.InputAwsLambdaFunction, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Functions[idx1], err = UnmarshalInputAwsLambdaFunction(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAzureDestinationSpec(v interface{}) (models.InputAzureDestinationSpec, error) {
	var it models.InputAzureDestinationSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functionName":
			var err error
			it.FunctionName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAzureFunction(v interface{}) (models.InputAzureFunction, error) {
	var it models.InputAzureFunction
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functionName":
			var err error
			it.FunctionName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "authLevel":
			var err error
			it.AuthLevel, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAzureUpstreamSpec(v interface{}) (models.InputAzureUpstreamSpec, error) {
	var it models.InputAzureUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functionAppName":
			var err error
			it.FunctionAppName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "secretRef":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.SecretRef = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "functions":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Functions = make([]models.InputAzureFunction, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Functions[idx1], err = UnmarshalInputAzureFunction(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputDestination(v interface{}) (models.InputDestination, error) {
	var it models.InputDestination
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "singleDestination":
			var err error
			var ptr1 models.InputSingleDestination
			if v != nil {
				ptr1, err = UnmarshalInputSingleDestination(v)
				it.SingleDestination = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "multiDestination":
			var err error
			var ptr1 models.InputMultiDestination
			if v != nil {
				ptr1, err = UnmarshalInputMultiDestination(v)
				it.MultiDestination = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputDestinationSpec(v interface{}) (models.InputDestinationSpec, error) {
	var it models.InputDestinationSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "aws":
			var err error
			var ptr1 models.InputAwsDestinationSpec
			if v != nil {
				ptr1, err = UnmarshalInputAwsDestinationSpec(v)
				it.Aws = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "azure":
			var err error
			var ptr1 models.InputAzureDestinationSpec
			if v != nil {
				ptr1, err = UnmarshalInputAzureDestinationSpec(v)
				it.Azure = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputFieldResolver(v interface{}) (models.InputFieldResolver, error) {
	var it models.InputFieldResolver
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "fieldName":
			var err error
			it.FieldName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "resolver":
			var err error
			it.Resolver, err = UnmarshalInputResolver(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputGRPCServiceSpec(v interface{}) (models.InputGRPCServiceSpec, error) {
	var it models.InputGRPCServiceSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "empty":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Empty = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputGlooResolver(v interface{}) (models.InputGlooResolver, error) {
	var it models.InputGlooResolver
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "empty":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Empty = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputKeyValueMatcher(v interface{}) (models.InputKeyValueMatcher, error) {
	var it models.InputKeyValueMatcher
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error
			it.Value, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "isRegex":
			var err error
			it.IsRegex, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputKubeUpstreamSpec(v interface{}) (models.InputKubeUpstreamSpec, error) {
	var it models.InputKubeUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "serviceName":
			var err error
			it.ServiceName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "serviceNamespace":
			var err error
			it.ServiceNamespace, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "servicePort":
			var err error
			it.ServicePort, err = graphql.UnmarshalInt(v)
			if err != nil {
				return it, err
			}
		case "selector":
			var err error
			var ptr1 customtypes.MapStringString
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.Selector = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputMatcher(v interface{}) (models.InputMatcher, error) {
	var it models.InputMatcher
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pathMatch":
			var err error
			it.PathMatch, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "pathMatchType":
			var err error
			err = (&it.PathMatchType).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "headers":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Headers = make([]models.InputKeyValueMatcher, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Headers[idx1], err = UnmarshalInputKeyValueMatcher(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "queryParameters":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.QueryParameters = make([]models.InputKeyValueMatcher, len(rawIf1))
			for idx1 := range rawIf1 {
				it.QueryParameters[idx1], err = UnmarshalInputKeyValueMatcher(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "methods":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Methods = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Methods[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputMetadata(v interface{}) (models.InputMetadata, error) {
	var it models.InputMetadata
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "namespace":
			var err error
			it.Namespace, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "resourceVersion":
			var err error
			it.ResourceVersion, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "labels":
			var err error
			var ptr1 customtypes.MapStringString
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.Labels = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "annotations":
			var err error
			var ptr1 customtypes.MapStringString
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.Annotations = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputMultiDestination(v interface{}) (models.InputMultiDestination, error) {
	var it models.InputMultiDestination
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "destinations":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Destinations = make([]models.InputWeightedDestination, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Destinations[idx1], err = UnmarshalInputWeightedDestination(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputNodeJSResolver(v interface{}) (models.InputNodeJSResolver, error) {
	var it models.InputNodeJSResolver
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "empty":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Empty = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputResolver(v interface{}) (models.InputResolver, error) {
	var it models.InputResolver
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "glooResolver":
			var err error
			var ptr1 models.InputGlooResolver
			if v != nil {
				ptr1, err = UnmarshalInputGlooResolver(v)
				it.GlooResolver = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "templateResolver":
			var err error
			var ptr1 models.InputTemplateResolver
			if v != nil {
				ptr1, err = UnmarshalInputTemplateResolver(v)
				it.TemplateResolver = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "nodeResolver":
			var err error
			var ptr1 models.InputNodeJSResolver
			if v != nil {
				ptr1, err = UnmarshalInputNodeJSResolver(v)
				it.NodeResolver = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputResolverMap(v interface{}) (models.InputResolverMap, error) {
	var it models.InputResolverMap
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "types":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Types = make([]models.InputTypeResolver, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Types[idx1], err = UnmarshalInputTypeResolver(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			it.Metadata, err = UnmarshalInputMetadata(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputRoute(v interface{}) (models.InputRoute, error) {
	var it models.InputRoute
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "matcher":
			var err error
			it.Matcher, err = UnmarshalInputMatcher(v)
			if err != nil {
				return it, err
			}
		case "destination":
			var err error
			it.Destination, err = UnmarshalInputDestination(v)
			if err != nil {
				return it, err
			}
		case "plugins":
			var err error
			var ptr1 models.InputRoutePlugins
			if v != nil {
				ptr1, err = UnmarshalInputRoutePlugins(v)
				it.Plugins = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputRoutePlugins(v interface{}) (models.InputRoutePlugins, error) {
	var it models.InputRoutePlugins
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "empty":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Empty = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputServiceSpec(v interface{}) (models.InputServiceSpec, error) {
	var it models.InputServiceSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "swagger":
			var err error
			var ptr1 models.InputSwaggerServiceSpec
			if v != nil {
				ptr1, err = UnmarshalInputSwaggerServiceSpec(v)
				it.Swagger = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "grpc":
			var err error
			var ptr1 models.InputGRPCServiceSpec
			if v != nil {
				ptr1, err = UnmarshalInputGRPCServiceSpec(v)
				it.Grpc = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputSingleDestination(v interface{}) (models.InputSingleDestination, error) {
	var it models.InputSingleDestination
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "upstreamName":
			var err error
			it.UpstreamName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "destinationSpec":
			var err error
			var ptr1 models.InputDestinationSpec
			if v != nil {
				ptr1, err = UnmarshalInputDestinationSpec(v)
				it.DestinationSpec = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputSslConfig(v interface{}) (models.InputSslConfig, error) {
	var it models.InputSslConfig
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "secretRef":
			var err error
			it.SecretRef, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputStatus(v interface{}) (models.InputStatus, error) {
	var it models.InputStatus
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "state":
			var err error
			err = (&it.State).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "reason":
			var err error
			it.Reason, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputSwaggerServiceSpec(v interface{}) (models.InputSwaggerServiceSpec, error) {
	var it models.InputSwaggerServiceSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "empty":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Empty = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputTemplateResolver(v interface{}) (models.InputTemplateResolver, error) {
	var it models.InputTemplateResolver
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "empty":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Empty = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputTypeResolver(v interface{}) (models.InputTypeResolver, error) {
	var it models.InputTypeResolver
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "typeName":
			var err error
			it.TypeName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "fields":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Fields = make([]models.InputFieldResolver, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Fields[idx1], err = UnmarshalInputFieldResolver(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputUpstream(v interface{}) (models.InputUpstream, error) {
	var it models.InputUpstream
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "spec":
			var err error
			it.Spec, err = UnmarshalInputUpstreamSpec(v)
			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			it.Metadata, err = UnmarshalInputMetadata(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputUpstreamSpec(v interface{}) (models.InputUpstreamSpec, error) {
	var it models.InputUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "aws":
			var err error
			var ptr1 models.InputAwsUpstreamSpec
			if v != nil {
				ptr1, err = UnmarshalInputAwsUpstreamSpec(v)
				it.Aws = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "azure":
			var err error
			var ptr1 models.InputAzureUpstreamSpec
			if v != nil {
				ptr1, err = UnmarshalInputAzureUpstreamSpec(v)
				it.Azure = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "kube":
			var err error
			var ptr1 models.InputKubeUpstreamSpec
			if v != nil {
				ptr1, err = UnmarshalInputKubeUpstreamSpec(v)
				it.Kube = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputVirtualService(v interface{}) (models.InputVirtualService, error) {
	var it models.InputVirtualService
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "domains":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Domains = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Domains[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "routes":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Routes = make([]models.InputRoute, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Routes[idx1], err = UnmarshalInputRoute(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "sslConfig":
			var err error
			var ptr1 models.InputSslConfig
			if v != nil {
				ptr1, err = UnmarshalInputSslConfig(v)
				it.SslConfig = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "plugins":
			var err error
			var ptr1 models.InputVirtualServicePlugins
			if v != nil {
				ptr1, err = UnmarshalInputVirtualServicePlugins(v)
				it.Plugins = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			it.Metadata, err = UnmarshalInputMetadata(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputVirtualServicePlugins(v interface{}) (models.InputVirtualServicePlugins, error) {
	var it models.InputVirtualServicePlugins
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "empty":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Empty = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputWeightedDestination(v interface{}) (models.InputWeightedDestination, error) {
	var it models.InputWeightedDestination
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "destination":
			var err error
			it.Destination, err = UnmarshalInputSingleDestination(v)
			if err != nil {
				return it, err
			}
		case "weight":
			var err error
			it.Weight, err = graphql.UnmarshalInt(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) FieldMiddleware(ctx context.Context, next graphql.Resolver) (ret interface{}) {
	defer func() {
		if r := recover(); r != nil {
			ec.Error(ctx, ec.Recover(ctx, r))
			ret = nil
		}
	}()
	res, err := ec.ResolverMiddleware(ctx, next)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return res
}

func (ec *executionContext) introspectSchema() *introspection.Schema {
	return introspection.WrapSchema(parsedSchema)
}

func (ec *executionContext) introspectType(name string) *introspection.Type {
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name])
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "schema.graphql", Input: `# Top Level
schema {
    query: Query
    mutation: Mutation
}

type Query {
    upstreams(namespace: String!):       UpstreamQuery!
    virtualServices(namespace: String!): VirtualServiceQuery!
    resolverMaps(namespace: String!): ResolverMapQuery!
}

type Mutation {
    upstreams(namespace: String!):       UpstreamMutation!
    virtualServices(namespace: String!): VirtualServiceMutation!
    resolverMaps(namespace: String!): ResolverMapMutation!
}

type UpstreamQuery {
    list(selector: MapStringString): [Upstream]
    get(name: String!):                Upstream
}


type UpstreamMutation {
    create(upstream: InputUpstream!): Upstream
    update(upstream: InputUpstream!): Upstream
    delete(name: String!): Upstream
}


type VirtualServiceQuery {
    list(selector: MapStringString): [VirtualService]
    get(name: String!):                VirtualService
}


type VirtualServiceMutation {
    create(virtualService: InputVirtualService!): VirtualService
    update(virtualService: InputVirtualService!): VirtualService
    delete(name: String!): VirtualService

    addRoute(virtualServiceName: String!, resourceVersion: String!, index: Int!, route: InputRoute!) : VirtualService
    updateRoute(virtualServiceName: String!, resourceVersion: String!, index: Int!, route: InputRoute!) : VirtualService
    deleteRoute(virtualServiceName: String!, resourceVersion: String!, index: Int!) : VirtualService
    swapRoutes(virtualServiceName: String!, resourceVersion: String!, index1: Int!, index2: Int!) : VirtualService
}


type ResolverMapQuery {
    list(selector: MapStringString): [ResolverMap]
    get(name: String!):                ResolverMap
}

type ResolverMapMutation {
    create(resolverMap: InputResolverMap!): ResolverMap
    update(resolverMap: InputResolverMap!): ResolverMap
    delete(name: String!): ResolverMap
}

# Upstream
# Upstream
# Upstream
# Upstream

type Upstream {
    spec:     UpstreamSpec!
    metadata: Metadata!
    status:   Status!
}

union UpstreamSpec = AwsUpstreamSpec | AzureUpstreamSpec | KubeUpstreamSpec

type AwsUpstreamSpec {
    region:    String!
    secretRef: String!
    functions: [AwsLambdaFunction!]
}

type AzureUpstreamSpec {
    functionAppName: String!
    secretRef:       String
    functions:       [AzureFunction!]
}

type KubeUpstreamSpec {
    serviceName:      String!
    serviceNamespace: String!
    servicePort:      Int!
    selector:         MapStringString
}

type AwsLambdaFunction {
    logicalName:  String!
    functionName: String!
    qualifier:    String!
}

type AzureFunction {
    functionName: String!
    authLevel:    String!
}

union ServiceSpec = SwaggerServiceSpec | GRPCServiceSpec

# Not implemented yet
type SwaggerServiceSpec  {
    empty: String
}

# Not implemented yet
type GRPCServiceSpec {
    empty: String
}


# Upstream Mutation
# Upstream Mutation
# Upstream Mutation
# Upstream Mutation

input InputUpstream {
    spec:     InputUpstreamSpec!
    metadata: InputMetadata!
}

input InputUpstreamSpec {
    # oneof: aws | azure | kube
    aws: InputAwsUpstreamSpec
    azure: InputAzureUpstreamSpec
    kube: InputKubeUpstreamSpec
}

input InputAwsUpstreamSpec {
    region:    String!
    secretRef: String!
    functions: [InputAwsLambdaFunction!]
}

input InputAzureUpstreamSpec {
    functionAppName: String!
    secretRef:       String
    functions:       [InputAzureFunction!]
}

input InputKubeUpstreamSpec {
    serviceName:      String!
    serviceNamespace: String!
    servicePort:      Int!
    selector:         MapStringString
}

input InputAwsLambdaFunction {
    logicalName:  String!
    functionName: String!
    qualifier:    String!
}

input InputAzureFunction {
    functionName: String!
    authLevel:    String!
}

input InputServiceSpec  {
    # oneof: swagger | grpc
    swagger: InputSwaggerServiceSpec
    grpc:    InputGRPCServiceSpec
}

# Not implemented yet
input InputSwaggerServiceSpec  {
    empty: String
}

# Not implemented yet
input InputGRPCServiceSpec {
    empty: String
}

input InputMetadata {
    name:            String!
    namespace:       String!
    resourceVersion: String!
    labels:          MapStringString
    annotations:     MapStringString
}

input InputStatus {
    state:  State!
    reason: String!
}






## VirtualService
## VirtualService
## VirtualService
## VirtualService
## VirtualService
## VirtualService

type VirtualService {
    domains: [String!]
    routes:  [Route!]
    sslConfig: SslConfig
    plugins: VirtualServicePlugins

    metadata: Metadata!
    status:   Status!
}


type Route {
    matcher: Matcher!
    destination: Destination!
    plugins: RoutePlugins
}

# not implemented
type VirtualServicePlugins {
    empty: String
}

type Matcher {
    pathMatch: String!
    pathMatchType: PathMatchType!
    headers: [KeyValueMatcher!]
    queryParameters: [KeyValueMatcher!]
    methods: [String!]
}

type KeyValueMatcher {
    name: String!
    value: String!
    isRegex: Boolean!
}

union Destination = MultiDestination | SingleDestination

type MultiDestination {
    destinations: [WeightedDestination!]
}

type WeightedDestination {
    destination: SingleDestination!
    weight: Int!
}

type SingleDestination {
    upstreamName: String!
    destinationSpec: DestinationSpec
}

union DestinationSpec = AwsDestinationSpec | AzureDestinationSpec

type AwsDestinationSpec {
    logicalName: String!
    invocationStyle: AwsLambdaInvocationStyle!
}

type AzureDestinationSpec {
    functionName: String!
}

type SslConfig {
    secretRef: String!
}

# not implemented
type RoutePlugins {
    empty: String
}

# InputVirtualService
# InputVirtualService
# InputVirtualService
# InputVirtualService

input InputVirtualService {
    domains: [String!]
    routes:  [InputRoute!]
    sslConfig: InputSslConfig
    plugins: InputVirtualServicePlugins
    metadata: InputMetadata!
}


input InputRoute {
    matcher: InputMatcher!
    destination: InputDestination!
    plugins: InputRoutePlugins
}

# not implemented
input InputVirtualServicePlugins {
    empty: String
}

input InputMatcher {
    pathMatch: String!
    pathMatchType: PathMatchType!
    headers: [InputKeyValueMatcher!]
    queryParameters: [InputKeyValueMatcher!]
    methods: [String!]
}

input InputKeyValueMatcher {
    name: String!
    value: String!
    isRegex: Boolean!
}

input InputDestination {
    # oneof: MultiDestination, SingleDestination
    singleDestination: InputSingleDestination
    multiDestination: InputMultiDestination
}

input InputMultiDestination {
    destinations: [InputWeightedDestination!]
}

input InputWeightedDestination {
    destination: InputSingleDestination!
    weight: Int!
}

input InputSingleDestination {
    upstreamName: String!
    destinationSpec: InputDestinationSpec
}

input InputDestinationSpec {
    # oneof: aws | azure
    aws: InputAwsDestinationSpec
    azure: InputAzureDestinationSpec
}

input InputAwsDestinationSpec {
    logicalName: String!
    invocationStyle: AwsLambdaInvocationStyle!
}

input InputAzureDestinationSpec {
    functionName: String!
}

input InputSslConfig {
    secretRef: String!
}


# not implemented
input InputRoutePlugins {
    empty: String
}


## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap


type ResolverMap {
    # can't do maps, thanks facebook
    # the trick with type resolvers is the typeNames must be unique!
    # this converts to a map in the server
    # what a novel idea for a type system. maps... who would have thunk it?
    types: [TypeResolver!]!
    metadata: Metadata!
    status:   Status!
}

type TypeResolver {
    typeName: String!
    # again, the fieldNames within this array must be unique
    fields: [FieldResolver!]!
}

type FieldResolver {
    fieldName: String!
    resolver: Resolver!
}

union Resolver = GlooResolver | TemplateResolver | NodeJSResolver

# not implemented (ilackarms)
type GlooResolver {
    empty: String
}
type TemplateResolver {
    empty: String
}
type NodeJSResolver {
    empty: String
}



input InputResolverMap {
    # can't do maps, thanks facebook
    # the trick with type resolvers is the typeNames must be unique!
    # this converts to a map in the server
    # what a novel idea for a type system. maps... who would have thunk it?
    types: [InputTypeResolver!]!
    metadata: InputMetadata!
}

input InputTypeResolver {
    typeName: String!
    # again, the fieldNames within this array must be unique
    fields: [InputFieldResolver!]!
}

input InputFieldResolver {
    fieldName: String!
    resolver: InputResolver!
}

input InputResolver {
    # oneof: gloo, template, node
    glooResolver: InputGlooResolver
    templateResolver: InputTemplateResolver
    nodeResolver: InputNodeJSResolver
}

# not implemented (ilackarms)
input InputGlooResolver {
    empty: String
}
input InputTemplateResolver {
    empty: String
}
input InputNodeJSResolver {
    empty: String
}


# Common output types
# Common output types
# Common output types
# Common output types
# Common output types

type Metadata {
    name:            String!
    namespace:       String!
    resourceVersion: String!
    labels:          MapStringString
    annotations:     MapStringString
}

type Status {
    state:  State!
    reason: String
}




# Scalars / Extra

enum State {
    PENDING
    ACCEPTED
    REJECTED
}

scalar MapStringString

enum PathMatchType {
    PREFIX
    REGEX
    EXACT
}

enum AwsLambdaInvocationStyle {
    SYNC
    ASYNC
}
`},
)
