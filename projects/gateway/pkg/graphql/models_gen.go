// This file was generated by github.com/vektah/gqlgen, DO NOT EDIT

package graphql

import (
	fmt "fmt"
	io "io"
	strconv "strconv"

	scalars "github.com/solo-io/solo-kit/projects/gateway/pkg/graphql/scalars"
)

type AwsLambdaFunction struct {
	FunctionName string `json:"functionName"`
	Qualifier    string `json:"qualifier"`
}
type AwsUpstreamSpec struct {
	Region    string              `json:"region"`
	SecretRef string              `json:"secretRef"`
	Functions []AwsLambdaFunction `json:"functions"`
}
type AzureFunction struct {
	FunctionName string `json:"functionName"`
	AuthLevel    string `json:"authLevel"`
}
type AzureUpstreamSpec struct {
	FunctionAppName string          `json:"functionAppName"`
	SecretRef       *string         `json:"secretRef"`
	Functions       []AzureFunction `json:"functions"`
}
type GRPCServiceSpec struct {
	Empty *string `json:"empty"`
}
type InputAwsLambdaFunction struct {
	FunctionName string `json:"functionName"`
	Qualifier    string `json:"qualifier"`
}
type InputAwsUpstreamSpec struct {
	Region    string                   `json:"region"`
	SecretRef string                   `json:"secretRef"`
	Functions []InputAwsLambdaFunction `json:"functions"`
}
type InputAzureFunction struct {
	FunctionName string `json:"functionName"`
	AuthLevel    string `json:"authLevel"`
}
type InputAzureUpstreamSpec struct {
	FunctionAppName string               `json:"functionAppName"`
	SecretRef       *string              `json:"secretRef"`
	Functions       []InputAzureFunction `json:"functions"`
}
type InputGRPCServiceSpec struct {
	Empty *string `json:"empty"`
}
type InputKubeUpstreamSpec struct {
	ServiceName      string                   `json:"serviceName"`
	ServiceNamespace string                   `json:"serviceNamespace"`
	ServicePort      int                      `json:"servicePort"`
	Selector         *scalars.MapStringString `json:"selector"`
}
type InputMetadata struct {
	Name            string                   `json:"name"`
	Namespace       string                   `json:"namespace"`
	ResourceVersion string                   `json:"resourceVersion"`
	Labels          *scalars.MapStringString `json:"labels"`
	Annotations     *scalars.MapStringString `json:"annotations"`
}
type InputServiceSpec struct {
	Swagger *InputSwaggerServiceSpec `json:"swagger"`
	Grpc    *InputGRPCServiceSpec    `json:"grpc"`
}
type InputStatus struct {
	State  State   `json:"state"`
	Reason *string `json:"reason"`
}
type InputSwaggerServiceSpec struct {
	Empty *string `json:"empty"`
}
type InputUpstream struct {
	Spec     InputUpstreamSpec `json:"spec"`
	Metadata InputMetadata     `json:"metadata"`
	Status   InputStatus       `json:"status"`
}
type InputUpstreamSpec struct {
	Aws   *InputAwsUpstreamSpec   `json:"aws"`
	Azure *InputAzureUpstreamSpec `json:"azure"`
	Kube  *InputKubeUpstreamSpec  `json:"kube"`
}
type KubeUpstreamSpec struct {
	ServiceName      string                   `json:"serviceName"`
	ServiceNamespace string                   `json:"serviceNamespace"`
	ServicePort      int                      `json:"servicePort"`
	Selector         *scalars.MapStringString `json:"selector"`
}
type Metadata struct {
	Name            string                   `json:"name"`
	Namespace       string                   `json:"namespace"`
	ResourceVersion string                   `json:"resourceVersion"`
	Labels          *scalars.MapStringString `json:"labels"`
	Annotations     *scalars.MapStringString `json:"annotations"`
}
type ServiceSpec interface{}
type Status struct {
	State  State   `json:"state"`
	Reason *string `json:"reason"`
}
type SwaggerServiceSpec struct {
	Empty *string `json:"empty"`
}
type Upstream struct {
	Spec     UpstreamSpec `json:"spec"`
	Metadata Metadata     `json:"metadata"`
	Status   Status       `json:"status"`
}
type UpstreamMutation struct {
	Create *Upstream `json:"create"`
	Update *Upstream `json:"update"`
}
type UpstreamQuery struct {
	List []Upstream `json:"list"`
	Get  *Upstream  `json:"get"`
}
type UpstreamSpec interface{}

type State string

const (
	StatePending  State = "PENDING"
	StateAccepted State = "ACCEPTED"
	StateRejected State = "REJECTED"
)

func (e State) IsValid() bool {
	switch e {
	case StatePending, StateAccepted, StateRejected:
		return true
	}
	return false
}

func (e State) String() string {
	return string(e)
}

func (e *State) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = State(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid State", str)
	}
	return nil
}

func (e State) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
