// This file was generated by github.com/vektah/gqlgen, DO NOT EDIT

package graphql

import (
	"bytes"
	context "context"
	fmt "fmt"
	strconv "strconv"

	"github.com/solo-io/solo-kit/projects/gateway/pkg/graphql"
	scalars "github.com/solo-io/solo-kit/projects/gateway/pkg/graphql/scalars"
	graphql "github.com/vektah/gqlgen/graphql"
	introspection "github.com/vektah/gqlgen/neelance/introspection"
	query "github.com/vektah/gqlgen/neelance/query"
	schema "github.com/vektah/gqlgen/neelance/schema"
)

func MakeExecutableSchema(resolvers Resolvers) graphql.ExecutableSchema {
	return &executableSchema{resolvers: resolvers}
}

type Resolvers interface {
	Mutation_upstreams(ctx context.Context, namespace string) (*UpstreamMutation, error)
	Query_upstreams(ctx context.Context, namespace string) (*UpstreamQuery, error)
}

type executableSchema struct {
	resolvers Resolvers
}

func (e *executableSchema) Schema() *schema.Schema {
	return parsedSchema
}

func (e *executableSchema) Query(ctx context.Context, op *query.Operation) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e.resolvers}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.Selections)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:   buf,
		Errors: ec.Errors,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, op *query.Operation) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e.resolvers}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.Selections)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:   buf,
		Errors: ec.Errors,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *query.Operation) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext

	resolvers Resolvers
}

var awsLambdaFunctionImplementors = []string{"AwsLambdaFunction"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AwsLambdaFunction(ctx context.Context, sel []query.Selection, obj *AwsLambdaFunction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, awsLambdaFunctionImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AwsLambdaFunction")
		case "functionName":
			out.Values[i] = ec._AwsLambdaFunction_functionName(ctx, field, obj)
		case "qualifier":
			out.Values[i] = ec._AwsLambdaFunction_qualifier(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _AwsLambdaFunction_functionName(ctx context.Context, field graphql.CollectedField, obj *AwsLambdaFunction) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AwsLambdaFunction"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.FunctionName
	return graphql.MarshalString(res)
}

func (ec *executionContext) _AwsLambdaFunction_qualifier(ctx context.Context, field graphql.CollectedField, obj *AwsLambdaFunction) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AwsLambdaFunction"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Qualifier
	return graphql.MarshalString(res)
}

var awsUpstreamSpecImplementors = []string{"AwsUpstreamSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AwsUpstreamSpec(ctx context.Context, sel []query.Selection, obj *AwsUpstreamSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, awsUpstreamSpecImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AwsUpstreamSpec")
		case "region":
			out.Values[i] = ec._AwsUpstreamSpec_region(ctx, field, obj)
		case "secretRef":
			out.Values[i] = ec._AwsUpstreamSpec_secretRef(ctx, field, obj)
		case "functions":
			out.Values[i] = ec._AwsUpstreamSpec_functions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _AwsUpstreamSpec_region(ctx context.Context, field graphql.CollectedField, obj *AwsUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AwsUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Region
	return graphql.MarshalString(res)
}

func (ec *executionContext) _AwsUpstreamSpec_secretRef(ctx context.Context, field graphql.CollectedField, obj *AwsUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AwsUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.SecretRef
	return graphql.MarshalString(res)
}

func (ec *executionContext) _AwsUpstreamSpec_functions(ctx context.Context, field graphql.CollectedField, obj *AwsUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AwsUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Functions
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._AwsLambdaFunction(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var azureFunctionImplementors = []string{"AzureFunction"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AzureFunction(ctx context.Context, sel []query.Selection, obj *AzureFunction) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, azureFunctionImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AzureFunction")
		case "functionName":
			out.Values[i] = ec._AzureFunction_functionName(ctx, field, obj)
		case "authLevel":
			out.Values[i] = ec._AzureFunction_authLevel(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _AzureFunction_functionName(ctx context.Context, field graphql.CollectedField, obj *AzureFunction) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AzureFunction"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.FunctionName
	return graphql.MarshalString(res)
}

func (ec *executionContext) _AzureFunction_authLevel(ctx context.Context, field graphql.CollectedField, obj *AzureFunction) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AzureFunction"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.AuthLevel
	return graphql.MarshalString(res)
}

var azureUpstreamSpecImplementors = []string{"AzureUpstreamSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AzureUpstreamSpec(ctx context.Context, sel []query.Selection, obj *AzureUpstreamSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, azureUpstreamSpecImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AzureUpstreamSpec")
		case "functionAppName":
			out.Values[i] = ec._AzureUpstreamSpec_functionAppName(ctx, field, obj)
		case "secretRef":
			out.Values[i] = ec._AzureUpstreamSpec_secretRef(ctx, field, obj)
		case "functions":
			out.Values[i] = ec._AzureUpstreamSpec_functions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _AzureUpstreamSpec_functionAppName(ctx context.Context, field graphql.CollectedField, obj *AzureUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AzureUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.FunctionAppName
	return graphql.MarshalString(res)
}

func (ec *executionContext) _AzureUpstreamSpec_secretRef(ctx context.Context, field graphql.CollectedField, obj *AzureUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AzureUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.SecretRef
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) _AzureUpstreamSpec_functions(ctx context.Context, field graphql.CollectedField, obj *AzureUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AzureUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Functions
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._AzureFunction(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var gRPCServiceSpecImplementors = []string{"GRPCServiceSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _GRPCServiceSpec(ctx context.Context, sel []query.Selection, obj *GRPCServiceSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, gRPCServiceSpecImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GRPCServiceSpec")
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

var kubeUpstreamSpecImplementors = []string{"KubeUpstreamSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _KubeUpstreamSpec(ctx context.Context, sel []query.Selection, obj *KubeUpstreamSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, kubeUpstreamSpecImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KubeUpstreamSpec")
		case "serviceName":
			out.Values[i] = ec._KubeUpstreamSpec_serviceName(ctx, field, obj)
		case "serviceNamespace":
			out.Values[i] = ec._KubeUpstreamSpec_serviceNamespace(ctx, field, obj)
		case "servicePort":
			out.Values[i] = ec._KubeUpstreamSpec_servicePort(ctx, field, obj)
		case "selector":
			out.Values[i] = ec._KubeUpstreamSpec_selector(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _KubeUpstreamSpec_serviceName(ctx context.Context, field graphql.CollectedField, obj *KubeUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "KubeUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.ServiceName
	return graphql.MarshalString(res)
}

func (ec *executionContext) _KubeUpstreamSpec_serviceNamespace(ctx context.Context, field graphql.CollectedField, obj *KubeUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "KubeUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.ServiceNamespace
	return graphql.MarshalString(res)
}

func (ec *executionContext) _KubeUpstreamSpec_servicePort(ctx context.Context, field graphql.CollectedField, obj *KubeUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "KubeUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.ServicePort
	return graphql.MarshalInt(res)
}

func (ec *executionContext) _KubeUpstreamSpec_selector(ctx context.Context, field graphql.CollectedField, obj *KubeUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "KubeUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Selector
	if res == nil {
		return graphql.Null
	}
	return *res
}

var metadataImplementors = []string{"Metadata"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Metadata(ctx context.Context, sel []query.Selection, obj *Metadata) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, metadataImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Metadata")
		case "name":
			out.Values[i] = ec._Metadata_name(ctx, field, obj)
		case "namespace":
			out.Values[i] = ec._Metadata_namespace(ctx, field, obj)
		case "resourceVersion":
			out.Values[i] = ec._Metadata_resourceVersion(ctx, field, obj)
		case "labels":
			out.Values[i] = ec._Metadata_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._Metadata_annotations(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Metadata_name(ctx context.Context, field graphql.CollectedField, obj *Metadata) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Metadata"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Metadata_namespace(ctx context.Context, field graphql.CollectedField, obj *Metadata) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Metadata"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Namespace
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Metadata_resourceVersion(ctx context.Context, field graphql.CollectedField, obj *Metadata) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Metadata"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.ResourceVersion
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Metadata_labels(ctx context.Context, field graphql.CollectedField, obj *Metadata) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Metadata"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Labels
	if res == nil {
		return graphql.Null
	}
	return *res
}

func (ec *executionContext) _Metadata_annotations(ctx context.Context, field graphql.CollectedField, obj *Metadata) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Metadata"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Annotations
	if res == nil {
		return graphql.Null
	}
	return *res
}

var mutationImplementors = []string{"Mutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Mutation(ctx context.Context, sel []query.Selection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, mutationImplementors, ec.Variables)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "upstreams":
			out.Values[i] = ec._Mutation_upstreams(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Mutation_upstreams(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["namespace"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()

	resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation_upstreams(ctx, args["namespace"].(string))
	})
	if err != nil {
		ec.Error(ctx, err)
		return graphql.Null
	}
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*UpstreamMutation)
	if res == nil {
		return graphql.Null
	}
	return ec._UpstreamMutation(ctx, field.Selections, res)
}

var queryImplementors = []string{"Query"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Query(ctx context.Context, sel []query.Selection) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, queryImplementors, ec.Variables)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "upstreams":
			out.Values[i] = ec._Query_upstreams(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Query_upstreams(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["namespace"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp, err := ec.ResolverMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query_upstreams(ctx, args["namespace"].(string))
		})
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*UpstreamQuery)
		if res == nil {
			return graphql.Null
		}
		return ec._UpstreamQuery(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Query"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := ec.introspectSchema()
	if res == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := field.Args["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Query"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := ec.introspectType(args["name"].(string))
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

var statusImplementors = []string{"Status"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Status(ctx context.Context, sel []query.Selection, obj *Status) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, statusImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Status")
		case "state":
			out.Values[i] = ec._Status_state(ctx, field, obj)
		case "reason":
			out.Values[i] = ec._Status_reason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Status_state(ctx context.Context, field graphql.CollectedField, obj *Status) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Status"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.State
	return res
}

func (ec *executionContext) _Status_reason(ctx context.Context, field graphql.CollectedField, obj *Status) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Status"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Reason
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var swaggerServiceSpecImplementors = []string{"SwaggerServiceSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SwaggerServiceSpec(ctx context.Context, sel []query.Selection, obj *SwaggerServiceSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, swaggerServiceSpecImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SwaggerServiceSpec")
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

var upstreamImplementors = []string{"Upstream"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Upstream(ctx context.Context, sel []query.Selection, obj *Upstream) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, upstreamImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Upstream")
		case "spec":
			out.Values[i] = ec._Upstream_spec(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._Upstream_metadata(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Upstream_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Upstream_spec(ctx context.Context, field graphql.CollectedField, obj *Upstream) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Upstream"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Spec
	return ec._UpstreamSpec(ctx, field.Selections, &res)
}

func (ec *executionContext) _Upstream_metadata(ctx context.Context, field graphql.CollectedField, obj *Upstream) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Upstream"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Metadata
	return ec._Metadata(ctx, field.Selections, &res)
}

func (ec *executionContext) _Upstream_status(ctx context.Context, field graphql.CollectedField, obj *Upstream) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Upstream"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Status
	return ec._Status(ctx, field.Selections, &res)
}

var upstreamMutationImplementors = []string{"UpstreamMutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UpstreamMutation(ctx context.Context, sel []query.Selection, obj *UpstreamMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, upstreamMutationImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpstreamMutation")
		case "create":
			out.Values[i] = ec._UpstreamMutation_create(ctx, field, obj)
		case "update":
			out.Values[i] = ec._UpstreamMutation_update(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _UpstreamMutation_create(ctx context.Context, field graphql.CollectedField, obj *UpstreamMutation) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 InputUpstream
	if tmp, ok := field.Args["upstream"]; ok {
		var err error
		arg0, err = UnmarshalInputUpstream(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["upstream"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "UpstreamMutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Create
	if res == nil {
		return graphql.Null
	}
	return ec._Upstream(ctx, field.Selections, res)
}

func (ec *executionContext) _UpstreamMutation_update(ctx context.Context, field graphql.CollectedField, obj *UpstreamMutation) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 InputUpstream
	if tmp, ok := field.Args["upstream"]; ok {
		var err error
		arg0, err = UnmarshalInputUpstream(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["upstream"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "UpstreamMutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Update
	if res == nil {
		return graphql.Null
	}
	return ec._Upstream(ctx, field.Selections, res)
}

var upstreamQueryImplementors = []string{"UpstreamQuery"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UpstreamQuery(ctx context.Context, sel []query.Selection, obj *UpstreamQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, upstreamQueryImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpstreamQuery")
		case "list":
			out.Values[i] = ec._UpstreamQuery_list(ctx, field, obj)
		case "get":
			out.Values[i] = ec._UpstreamQuery_get(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _UpstreamQuery_list(ctx context.Context, field graphql.CollectedField, obj *UpstreamQuery) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 *scalars.MapStringString
	if tmp, ok := field.Args["selector"]; ok {
		var err error
		var ptr1 scalars.MapStringString
		if tmp != nil {
			err = (&ptr1).UnmarshalGQL(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["selector"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "UpstreamQuery"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.List
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._Upstream(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _UpstreamQuery_get(ctx context.Context, field graphql.CollectedField, obj *UpstreamQuery) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 *string
	if tmp, ok := field.Args["name"]; ok {
		var err error
		var ptr1 string
		if tmp != nil {
			ptr1, err = graphql.UnmarshalString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "UpstreamQuery"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Get
	if res == nil {
		return graphql.Null
	}
	return ec._Upstream(ctx, field.Selections, res)
}

var __DirectiveImplementors = []string{"__Directive"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(ctx context.Context, sel []query.Selection, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __DirectiveImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Locations()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return graphql.MarshalString(res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Args()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var __EnumValueImplementors = []string{"__EnumValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(ctx context.Context, sel []query.Selection, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __EnumValueImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.IsDeprecated()
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.DeprecationReason()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __FieldImplementors = []string{"__Field"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(ctx context.Context, sel []query.Selection, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __FieldImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Args()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Type()
	return ec.___Type(ctx, field.Selections, &res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.IsDeprecated()
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.DeprecationReason()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __InputValueImplementors = []string{"__InputValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(ctx context.Context, sel []query.Selection, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __InputValueImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Type()
	return ec.___Type(ctx, field.Selections, &res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.DefaultValue()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __SchemaImplementors = []string{"__Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(ctx context.Context, sel []query.Selection, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __SchemaImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Types()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.QueryType()
	return ec.___Type(ctx, field.Selections, &res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.MutationType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.SubscriptionType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Directives()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Directive(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var __TypeImplementors = []string{"__Type"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(ctx context.Context, sel []query.Selection, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ec.Doc, sel, __TypeImplementors, ec.Variables)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Kind()
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Name()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Description()
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := field.Args["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["includeDeprecated"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Fields(args["includeDeprecated"].(bool))
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Field(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.Interfaces()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.PossibleTypes()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := field.Args["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["includeDeprecated"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.EnumValues(args["includeDeprecated"].(bool))
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___EnumValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.InputFields()
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	res := obj.OfType()
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) _ServiceSpec(ctx context.Context, sel []query.Selection, obj *ServiceSpec) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case SwaggerServiceSpec:
		return ec._SwaggerServiceSpec(ctx, sel, &obj)
	case *SwaggerServiceSpec:
		return ec._SwaggerServiceSpec(ctx, sel, obj)
	case GRPCServiceSpec:
		return ec._GRPCServiceSpec(ctx, sel, &obj)
	case *GRPCServiceSpec:
		return ec._GRPCServiceSpec(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpstreamSpec(ctx context.Context, sel []query.Selection, obj *UpstreamSpec) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case AwsUpstreamSpec:
		return ec._AwsUpstreamSpec(ctx, sel, &obj)
	case *AwsUpstreamSpec:
		return ec._AwsUpstreamSpec(ctx, sel, obj)
	case AzureUpstreamSpec:
		return ec._AzureUpstreamSpec(ctx, sel, &obj)
	case *AzureUpstreamSpec:
		return ec._AzureUpstreamSpec(ctx, sel, obj)
	case KubeUpstreamSpec:
		return ec._KubeUpstreamSpec(ctx, sel, &obj)
	case *KubeUpstreamSpec:
		return ec._KubeUpstreamSpec(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func UnmarshalInputAwsLambdaFunction(v interface{}) (InputAwsLambdaFunction, error) {
	var it InputAwsLambdaFunction
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functionName":
			var err error
			it.FunctionName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "qualifier":
			var err error
			it.Qualifier, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAwsUpstreamSpec(v interface{}) (InputAwsUpstreamSpec, error) {
	var it InputAwsUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "region":
			var err error
			it.Region, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "secretRef":
			var err error
			it.SecretRef, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "functions":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				}
			}
			it.Functions = make([]InputAwsLambdaFunction, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Functions[idx1], err = UnmarshalInputAwsLambdaFunction(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAzureFunction(v interface{}) (InputAzureFunction, error) {
	var it InputAzureFunction
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functionName":
			var err error
			it.FunctionName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "authLevel":
			var err error
			it.AuthLevel, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAzureUpstreamSpec(v interface{}) (InputAzureUpstreamSpec, error) {
	var it InputAzureUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functionAppName":
			var err error
			it.FunctionAppName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "secretRef":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.SecretRef = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "functions":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				}
			}
			it.Functions = make([]InputAzureFunction, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Functions[idx1], err = UnmarshalInputAzureFunction(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputGRPCServiceSpec(v interface{}) (InputGRPCServiceSpec, error) {
	var it InputGRPCServiceSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		}
	}

	return it, nil
}

func UnmarshalInputKubeUpstreamSpec(v interface{}) (InputKubeUpstreamSpec, error) {
	var it InputKubeUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "serviceName":
			var err error
			it.ServiceName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "serviceNamespace":
			var err error
			it.ServiceNamespace, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "servicePort":
			var err error
			it.ServicePort, err = graphql.UnmarshalInt(v)
			if err != nil {
				return it, err
			}
		case "selector":
			var err error
			var ptr1 scalars.MapStringString
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.Selector = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputMetadata(v interface{}) (InputMetadata, error) {
	var it InputMetadata
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "namespace":
			var err error
			it.Namespace, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "resourceVersion":
			var err error
			it.ResourceVersion, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "labels":
			var err error
			var ptr1 scalars.MapStringString
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.Labels = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "annotations":
			var err error
			var ptr1 scalars.MapStringString
			if v != nil {
				err = (&ptr1).UnmarshalGQL(v)
				it.Annotations = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputServiceSpec(v interface{}) (InputServiceSpec, error) {
	var it InputServiceSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "swagger":
			var err error
			var ptr1 InputSwaggerServiceSpec
			if v != nil {
				ptr1, err = UnmarshalInputSwaggerServiceSpec(v)
				it.Swagger = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "grpc":
			var err error
			var ptr1 InputGRPCServiceSpec
			if v != nil {
				ptr1, err = UnmarshalInputGRPCServiceSpec(v)
				it.Grpc = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputStatus(v interface{}) (InputStatus, error) {
	var it InputStatus
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "state":
			var err error
			err = (&it.State).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "reason":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Reason = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputSwaggerServiceSpec(v interface{}) (InputSwaggerServiceSpec, error) {
	var it InputSwaggerServiceSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		}
	}

	return it, nil
}

func UnmarshalInputUpstream(v interface{}) (InputUpstream, error) {
	var it InputUpstream
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "spec":
			var err error
			it.Spec, err = UnmarshalInputUpstreamSpec(v)
			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			it.Metadata, err = UnmarshalInputMetadata(v)
			if err != nil {
				return it, err
			}
		case "status":
			var err error
			it.Status, err = UnmarshalInputStatus(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputUpstreamSpec(v interface{}) (InputUpstreamSpec, error) {
	var it InputUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "aws":
			var err error
			var ptr1 InputAwsUpstreamSpec
			if v != nil {
				ptr1, err = UnmarshalInputAwsUpstreamSpec(v)
				it.Aws = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "azure":
			var err error
			var ptr1 InputAzureUpstreamSpec
			if v != nil {
				ptr1, err = UnmarshalInputAzureUpstreamSpec(v)
				it.Azure = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "kube":
			var err error
			var ptr1 InputKubeUpstreamSpec
			if v != nil {
				ptr1, err = UnmarshalInputKubeUpstreamSpec(v)
				it.Kube = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) introspectSchema() *introspection.Schema {
	return introspection.WrapSchema(parsedSchema)
}

func (ec *executionContext) introspectType(name string) *introspection.Type {
	t := parsedSchema.Resolve(name)
	if t == nil {
		return nil
	}
	return introspection.WrapType(t)
}

var parsedSchema = schema.MustParse(`# Query / Outputs
# Query / Outputs
# Query / Outputs
# Query / Outputs

type Query {
    upstreams(namespace: String!):       UpstreamQuery
}

type UpstreamQuery {
    list(selector: MapStringString): [Upstream]
    get(name: String):                Upstream
}

type Upstream {
    spec:     UpstreamSpec!
    metadata: Metadata!
    status:   Status!
}

union UpstreamSpec = AwsUpstreamSpec | AzureUpstreamSpec | KubeUpstreamSpec

type AwsUpstreamSpec {
    region:    String!
    secretRef: String!
    functions: [AwsLambdaFunction]
}

type AzureUpstreamSpec {
    functionAppName: String!
    secretRef:       String
    functions:       [AzureFunction]
}

type KubeUpstreamSpec {
    serviceName:      String!
    serviceNamespace: String!
    servicePort:      Int!
    selector:         MapStringString
}

type AwsLambdaFunction {
    functionName: String!
    qualifier:    String!
}

type AzureFunction {
    functionName: String!
    authLevel:    String!
}

union ServiceSpec = SwaggerServiceSpec | GRPCServiceSpec

# Not implemented yet
type SwaggerServiceSpec  {}

# Not implemented yet
type GRPCServiceSpec {}

type Metadata {
    name:            String!
    namespace:       String!
    resourceVersion: String!
    labels:          MapStringString
    annotations:     MapStringString
}

type Status {
    state:  State!
    reason: String
}















# Mutations/Inputs
# Mutations/Inputs
# Mutations/Inputs
# Mutations/Inputs

type Mutation {
    upstreams(namespace: String!): UpstreamMutation
}

type UpstreamMutation {
    create(upstream: InputUpstream!): Upstream
    update(upstream: InputUpstream!): Upstream
}

input InputUpstream {
    spec:     InputUpstreamSpec!
    metadata: InputMetadata!
    status:   InputStatus!
}

input InputUpstreamSpec {
    # oneof: aws | azure | kube
    aws: InputAwsUpstreamSpec
    azure: InputAzureUpstreamSpec
    kube: InputKubeUpstreamSpec
}

input InputAwsUpstreamSpec {
    region:    String!
    secretRef: String!
    functions: [InputAwsLambdaFunction]
}

input InputAzureUpstreamSpec {
    functionAppName: String!
    secretRef:       String
    functions:       [InputAzureFunction]
}

input InputKubeUpstreamSpec {
    serviceName:      String!
    serviceNamespace: String!
    servicePort:      Int!
    selector:         MapStringString
}

input InputAwsLambdaFunction {
    functionName: String!
    qualifier:    String!
}

input InputAzureFunction {
    functionName: String!
    authLevel:    String!
}

input InputServiceSpec  {
    # oneof: swagger | grpc
    swagger: InputSwaggerServiceSpec
    grpc:    InputGRPCServiceSpec
}

# Not implemented yet
input InputSwaggerServiceSpec  {}

# Not implemented yet
input InputGRPCServiceSpec {}

input InputMetadata {
    name:            String!
    namespace:       String!
    resourceVersion: String!
    labels:          MapStringString
    annotations:     MapStringString
}

input InputStatus {
    state:  State!
    reason: String
}






# Scalars / Extra

enum State {
    PENDING
    ACCEPTED
    REJECTED
}

scalar MapStringString


#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
## The mutation type, represents all updates we can make to our data
#type Mutation {
#    createUpstream(upstream: InputUpstream!) : Upstream
#    updateUpstream(upstream: InputUpstream!) : Upstream
#    deleteUpstream(name: String!) : Boolean
#
#    createVirtualService(virtualService: InputVirtualService!) : VirtualService
#    updateVirtualService(virtualService: InputVirtualService!) : VirtualService
#    deleteVirtualService(name: String!) : Boolean
#
#    addRoute(virtualServiceName: String!, index: Int!, route: InputRoute!) : VirtualService
#    updateRoute(virtualServiceName: String!, index: Int!, route: InputRoute!) : VirtualService
#    deleteRoute(virtualServiceName: String!, index: Int!) : VirtualService
#}
#
####
#### Output types
####
#
#type Upstream {
#    spec: UpstreamSpec!
#    status: Status!
#    metadata: Metadata!
#}
#
#type VirtualService {
#    name: String!
#    domains: [String]
#    routes: [Route]
#    sslConfig: SSLConfig
#    roles: [String]
#    status: Status
#    metadata: Metadata
#    destinationUpstreams: [Upstream]
#}
#
#type Route {
#    matcher: Matcher!
#    destination: Destination!
#    prefixRewrite: String
#    extensions: Struct
#}
#
#type MultiDestination {
#    weighedDestinations: [WeightedDestination]!
#}
#
#type WeightedDestination {
#    destination: SingleDestination!
#    weight: Int!
#}
#
#type RequestMatcher {
#    path: Path!
#    headers: MapStringString
#    queryParams: MapStringString
#    verbs: [String]
#}
#
#type EventMatcher {
#    eventType: String!
#}
#
#type SSLConfig {
#    secretRef: String!
#}
#type UpstreamDestination {
#    name: String!
#}
#
#type FunctionDestination {
#    upstreamName: String!
#    functionName: String!
#}
#
#type PathPrefix implements Path {
#    path: String!
#}
#type PathRegex implements Path {
#    path: String!
#}
#type PathExact implements Path {
#    path: String!
#}
#
#type Function {
#    name: String!
#    spec: Struct
#}
#
#type ServiceInfo {
#    type: String!
#    properties: Struct
#}
#
#type Status {
#    state: State!
#    reason: String
#}
#
#type Metadata {
#    resourceVersion: String!
#    namespace: String
#    annotations: MapStringString
#}
#
#type UserConfigProperty {
#    key: String!
#    value: String!
#}
#
####
#### Input types
####
#
#input InputUpstream {
#    name: String!
#    type: String!
#    connectionTimeout: Duration
#    spec: Struct
#    functions: [InputFunction]
#    serviceInfo: InputServiceInfo
#    metadata: InputMetadata
#}
#
#input InputVirtualService {
#    name: String!
#    domains: [String]
#    routes: [InputRoute]
#    sslConfig: InputSSLConfig
#    roles: [String]
#    metadata: InputMetadata
#}
#
#input InputRoute {
#    matcher: InputMatcher!
#    destination: InputDestination!
#
#    prefixRewrite: String
#    extensions: Struct
#}
#
#input InputMatcher {
#    # oneof requestMatcher | eventMatcher
#    requestMatcher: InputRequestMatcher
#    eventMatcher: InputEventMatcher
#}
#input InputDestination {
#    # oneof multiDestinations | singleDestination
#    singleDestination: InputSingleDestination
#    multiDestinations: [InputWeightedDestination]
#}
#
#input InputWeightedDestination {
#    destination: InputSingleDestination!
#    weight: Int!
#}
#
#input InputSingleDestination {
#    # oneof upstreamDestination | functionDestination
#    upstreamDestination: InputUpstreamDestination
#    functionDestination: InputFunctionDestination
#}
#
#input InputRequestMatcher {
#    # oneof pathPrefix | pathRegex | pathExact
#    pathPrefix: InputPathPrefix
#    pathRegex: InputPathRegex
#    pathExact: InputPathExact
#
#    headers: MapStringString
#    queryParams: MapStringString
#    verbs: [String]
#}
#
#input InputEventMatcher {
#    eventType: String!
#}
#
#input InputSSLConfig {
#    secretRef: String!
#}
#input InputUpstreamDestination {
#    name: String!
#}
#
#input InputFunctionDestination {
#    upstreamName: String!
#    functionName: String!
#}
#
#input InputPathPrefix {
#    path: String!
#}
#input InputPathRegex {
#    path: String!
#}
#input InputPathExact {
#    path: String!
#}
#
#input InputFunction {
#    name: String!
#    spec: Struct
#}
#
#input InputServiceInfo {
#    type: String!
#    properties: Struct
#}
#
#input InputStatus {
#    state: State!
#    reason: String
#}
#
#input InputMetadata {
#    resourceVersion: String!
#    namespace: String
#    annotations: MapStringString
#}
#
#input InputUserConfigProperty {
#    key: String!
#    value: String!
#}
#
#
#
#
#
####
#### Interfaces, enums, scalars
####
#union Matcher = RequestMatcher | EventMatcher
#
#type SingleDestination {
#    destination: SingleDestinationUnion!
#}
#
#union Destination = MultiDestination | SingleDestination
#union SingleDestinationUnion = FunctionDestination | UpstreamDestination
#
#interface Path {
#    path: String!
#}
#
#enum State {
#    PENDING
#    ACCEPTED
#    REJECTED
#}
#
#scalar Duration
#scalar Struct
## graphql doesnt have generics or maps
#scalar MapStringString
`)
