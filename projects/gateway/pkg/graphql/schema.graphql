# Top Level
schema {
    query: Query
    mutation: Mutation
}

type Query {
    upstreams(namespace: String!):       UpstreamQuery
    virtualServices(namespace: String!): VirtualServicesQuery
}

type Mutation {
    upstreams(namespace: String!):       UpstreamMutation
    virtualServices(namespace: String!): VirtualServicesMutation
}

type UpstreamQuery {
    list(selector: MapStringString): [Upstream]
    get(name: String!):                Upstream
}


type UpstreamMutation {
    create(upstream: InputUpstream!): Upstream
    update(upstream: InputUpstream!): Upstream
    delete(name: String!): Upstream
}


type VirtualServiceQuery {
    list(selector: MapStringString): [VirtualService]
    get(name: String!):                VirtualService
}


type VirtualServiceMutation {
    create(upstream: InputVirtualService!): VirtualService
    update(upstream: InputVirtualService!): VirtualService
    delete(name: String!): VirtualService
}

# Upstream
# Upstream
# Upstream
# Upstream

type Upstream {
    spec:     UpstreamSpec!
    metadata: Metadata!
    status:   Status!
}

union UpstreamSpec = AwsUpstreamSpec | AzureUpstreamSpec | KubeUpstreamSpec

type AwsUpstreamSpec {
    region:    String!
    secretRef: String!
    functions: [AwsLambdaFunction]
}

type AzureUpstreamSpec {
    functionAppName: String!
    secretRef:       String
    functions:       [AzureFunction]
}

type KubeUpstreamSpec {
    serviceName:      String!
    serviceNamespace: String!
    servicePort:      Int!
    selector:         MapStringString
}

type AwsLambdaFunction {
    logicalName:  String!
    functionName: String!
    qualifier:    String!
}

type AzureFunction {
    functionName: String!
    authLevel:    String!
}

union ServiceSpec = SwaggerServiceSpec | GRPCServiceSpec

# Not implemented yet
type SwaggerServiceSpec  {
    empty: String
}

# Not implemented yet
type GRPCServiceSpec {
    empty: String
}


# Upstream Mutation
# Upstream Mutation
# Upstream Mutation
# Upstream Mutation

input InputUpstream {
    spec:     InputUpstreamSpec!
    metadata: InputMetadata!
}

input InputUpstreamSpec {
    # oneof: aws | azure | kube
    aws: InputAwsUpstreamSpec
    azure: InputAzureUpstreamSpec
    kube: InputKubeUpstreamSpec
}

input InputAwsUpstreamSpec {
    region:    String!
    secretRef: String!
    functions: [InputAwsLambdaFunction]
}

input InputAzureUpstreamSpec {
    functionAppName: String!
    secretRef:       String
    functions:       [InputAzureFunction]
}

input InputKubeUpstreamSpec {
    serviceName:      String!
    serviceNamespace: String!
    servicePort:      Int!
    selector:         MapStringString
}

input InputAwsLambdaFunction {
    functionName: String!
    qualifier:    String!
}

input InputAzureFunction {
    functionName: String!
    authLevel:    String!
}

input InputServiceSpec  {
    # oneof: swagger | grpc
    swagger: InputSwaggerServiceSpec
    grpc:    InputGRPCServiceSpec
}

# Not implemented yet
input InputSwaggerServiceSpec  {
    empty: String
}

# Not implemented yet
input InputGRPCServiceSpec {
    empty: String
}

input InputMetadata {
    name:            String!
    namespace:       String!
    resourceVersion: String!
    labels:          MapStringString
    annotations:     MapStringString
}

input InputStatus {
    state:  State!
    reason: String
}






## VirtualService
## VirtualService
## VirtualService

type VirtualService {
    domains: [String]
    routes:  [Route]
    sslConfig: SslConfig
    plugins: VirtualServicePlugins

    metadata: Metadata!
    status:   Status!
}


type Route {
    matcher: Matcher!
    destination: Destination!
}

# not implemented
type VirtualServicePlugins {
    empty: String
}

type Matcher {
    pathMatch: String!
    pathMatchType: PathMatchType!
    headers: [KeyVaueMatcher]
    queryParameters: [KeyValueMatcher]
    methods: [String]
}

type KeyVaueMatcher {
    name: String!
    value: String!
    isRegex: Boolean!
}

union Destination = MultiDestination | Destination

type MultiDestination {
    destinations: [WeightedDestination]
}

type WeightedDestination {
    destination: Destination!
    weight: Int!
}

type Destination {
    upstreamName: String!
    destinationSpec: DestinationSpec
}

union DestinationSpec = AwsDestinationSpec | AzureDestinationSpec

type AwsDestinationSpec {
    logicalName: String!
    invocationStyle: AwsLambdaInvocationStyle!
}

type AzureDestinationSpec {
    functionName: String!
}

type SslConfig {
    secretRef: String!
}

# InputVirtualService
# InputVirtualService
# InputVirtualService
# InputVirtualService

type InputVirtualService {
    domains: [String]
    routes:  [InputRoute]
    sslConfig: InputSslConfig
    plugins: InputVirtualServicePlugins
    metadata: InputMetadata
}


type InputRoute {
    matcher: InputMatcher!
    destination: InputDestination!
}

# not implemented
type InputVirtualServicePlugins {
    empty: String
}

type InputMatcher {
    pathMatch: String!
    pathMatchType: PathMatchType!
    headers: [InputKeyVaueMatcher]
    queryParameters: [InputKeyValueMatcher]
    methods: [String]
}

type InputKeyVaueMatcher {
    name: String!
    value: String!
    isRegex: Boolean!
}

input InputDestination {
    # oneof: MultiDestination, Destination
    destination: InputDestination
    multiDestination: InputMultiDestination
}

type InputMultiDestination {
    destinations: [InputWeightedDestination]
}

type InputWeightedDestination {
    destination: InputDestination!
    weight: Int!
}

type InputDestination {
    upstreamName: String!
    destinationSpec: InputDestinationSpec
}

input InputDestinationSpec {
    # oneof: aws | azure
    aws: InputAwsDestinationSpec
    azure: InputAzureDestinationSpec
}

type InputAwsDestinationSpec {
    logicalName: String!
    invocationStyle: AwsLambdaInvocationStyle!
}

type InputAzureDestinationSpec {
    functionName: String!
}

type InputSslConfig {
    secretRef: String!
}

# Common output types

type Metadata {
    name:            String!
    namespace:       String!
    resourceVersion: String!
    labels:          MapStringString
    annotations:     MapStringString
}

type Status {
    state:  State!
    reason: String
}




# Scalars / Extra

enum State {
    PENDING
    ACCEPTED
    REJECTED
}

scalar MapStringString

enum PathMatchType {
    PREFIX
    REGEX
    EXACT
}

enum AwsLambdaInvocationStyle {
    SYNC
    ASYNC
}
