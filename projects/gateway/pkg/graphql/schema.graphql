# Query / Outputs
# Query / Outputs
# Query / Outputs
# Query / Outputs

schema {
    query: Query
    mutation: Mutation
}

type Query {
    upstreams(namespace: String!):       UpstreamQuery
    virtualServices(namespace: String!): VirtualServicesQuery
}

type UpstreamQuery {
    list(selector: MapStringString): [Upstream]
    get(name: String!):                Upstream
}

type Upstream {
    spec:     UpstreamSpec!
    metadata: Metadata!
    status:   Status!
}

union UpstreamSpec = AwsUpstreamSpec | AzureUpstreamSpec | KubeUpstreamSpec

type AwsUpstreamSpec {
    region:    String!
    secretRef: String!
    functions: [AwsLambdaFunction]
}

type AzureUpstreamSpec {
    functionAppName: String!
    secretRef:       String
    functions:       [AzureFunction]
}

type KubeUpstreamSpec {
    serviceName:      String!
    serviceNamespace: String!
    servicePort:      Int!
    selector:         MapStringString
}

type AwsLambdaFunction {
    functionName: String!
    qualifier:    String!
}

type AzureFunction {
    functionName: String!
    authLevel:    String!
}

union ServiceSpec = SwaggerServiceSpec | GRPCServiceSpec

# Not implemented yet
type SwaggerServiceSpec  {
    empty: String
}

# Not implemented yet
type GRPCServiceSpec {
    empty: String
}


## Virtual Services


type VirtualServiceQuery {
    list(selector: MapStringString): [VirtualService]
    get(name: String!):                VirtualService
}

type VirtualService {
    domains: [String]
    routes:  [Route]
    plugins: VirtualServicePlugins

    metadata: Metadata!
    status:   Status!
}


type Route {

}

# not implemented
type VirtualServicePlugins {
    empty: String
}


# Common output types

type Metadata {
    name:            String!
    namespace:       String!
    resourceVersion: String!
    labels:          MapStringString
    annotations:     MapStringString
}

type Status {
    state:  State!
    reason: String
}















# Mutations/Inputs
# Mutations/Inputs
# Mutations/Inputs
# Mutations/Inputs

type Mutation {
    upstreams(namespace: String!): UpstreamMutation
}

type UpstreamMutation {
    create(upstream: InputUpstream!): Upstream
    update(upstream: InputUpstream!): Upstream
}

input InputUpstream {
    spec:     InputUpstreamSpec!
    metadata: InputMetadata!
    status:   InputStatus!
}

input InputUpstreamSpec {
    # oneof: aws | azure | kube
    aws: InputAwsUpstreamSpec
    azure: InputAzureUpstreamSpec
    kube: InputKubeUpstreamSpec
}

input InputAwsUpstreamSpec {
    region:    String!
    secretRef: String!
    functions: [InputAwsLambdaFunction]
}

input InputAzureUpstreamSpec {
    functionAppName: String!
    secretRef:       String
    functions:       [InputAzureFunction]
}

input InputKubeUpstreamSpec {
    serviceName:      String!
    serviceNamespace: String!
    servicePort:      Int!
    selector:         MapStringString
}

input InputAwsLambdaFunction {
    functionName: String!
    qualifier:    String!
}

input InputAzureFunction {
    functionName: String!
    authLevel:    String!
}

input InputServiceSpec  {
    # oneof: swagger | grpc
    swagger: InputSwaggerServiceSpec
    grpc:    InputGRPCServiceSpec
}

# Not implemented yet
input InputSwaggerServiceSpec  {
    empty: String
}

# Not implemented yet
input InputGRPCServiceSpec {
    empty: String
}

input InputMetadata {
    name:            String!
    namespace:       String!
    resourceVersion: String!
    labels:          MapStringString
    annotations:     MapStringString
}

input InputStatus {
    state:  State!
    reason: String
}






# Scalars / Extra

enum State {
    PENDING
    ACCEPTED
    REJECTED
}

scalar MapStringString
