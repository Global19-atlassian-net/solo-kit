# Top Level
schema {
    query: Query
    mutation: Mutation
}

type Query {
    upstreams(namespace: String!):       UpstreamQuery!
    virtualServices(namespace: String!): VirtualServiceQuery!
    resolverMaps(namespace: String!): ResolverMapQuery!
}

type Mutation {
    upstreams(namespace: String!):       UpstreamMutation!
    virtualServices(namespace: String!): VirtualServiceMutation!
    resolverMaps(namespace: String!): ResolverMapMutation!
}

type UpstreamQuery {
    list(selector: MapStringString): [Upstream]
    get(name: String!):                Upstream
}


type UpstreamMutation {
    create(upstream: InputUpstream!): Upstream
    update(upstream: InputUpstream!): Upstream
    delete(name: String!): Upstream
}


type VirtualServiceQuery {
    list(selector: MapStringString): [VirtualService]
    get(name: String!):                VirtualService
}


type VirtualServiceMutation {
    create(virtualService: InputVirtualService!): VirtualService
    update(virtualService: InputVirtualService!): VirtualService
    delete(name: String!): VirtualService
}


type ResolverMapQuery {
    list(selector: MapStringString): [ResolverMap]
    get(name: String!):                ResolverMap
}

type ResolverMapMutation {
    create(resolverMap: InputResolverMap!): ResolverMap
    update(resolverMap: InputResolverMap!): ResolverMap
    delete(name: String!): ResolverMap
}

# Upstream
# Upstream
# Upstream
# Upstream

type Upstream {
    spec:     UpstreamSpec!
    metadata: Metadata!
    status:   Status!
}

union UpstreamSpec = AwsUpstreamSpec | AzureUpstreamSpec | KubeUpstreamSpec

type AwsUpstreamSpec {
    region:    String!
    secretRef: String!
    functions: [AwsLambdaFunction]
}

type AzureUpstreamSpec {
    functionAppName: String!
    secretRef:       String
    functions:       [AzureFunction]
}

type KubeUpstreamSpec {
    serviceName:      String!
    serviceNamespace: String!
    servicePort:      Int!
    selector:         MapStringString
}

type AwsLambdaFunction {
    logicalName:  String!
    functionName: String!
    qualifier:    String!
}

type AzureFunction {
    functionName: String!
    authLevel:    String!
}

union ServiceSpec = SwaggerServiceSpec | GRPCServiceSpec

# Not implemented yet
type SwaggerServiceSpec  {
    empty: String
}

# Not implemented yet
type GRPCServiceSpec {
    empty: String
}


# Upstream Mutation
# Upstream Mutation
# Upstream Mutation
# Upstream Mutation

input InputUpstream {
    spec:     InputUpstreamSpec!
    metadata: InputMetadata!
}

input InputUpstreamSpec {
    # oneof: aws | azure | kube
    aws: InputAwsUpstreamSpec
    azure: InputAzureUpstreamSpec
    kube: InputKubeUpstreamSpec
}

input InputAwsUpstreamSpec {
    region:    String!
    secretRef: String!
    functions: [InputAwsLambdaFunction]
}

input InputAzureUpstreamSpec {
    functionAppName: String!
    secretRef:       String
    functions:       [InputAzureFunction]
}

input InputKubeUpstreamSpec {
    serviceName:      String!
    serviceNamespace: String!
    servicePort:      Int!
    selector:         MapStringString
}

input InputAwsLambdaFunction {
    functionName: String!
    qualifier:    String!
}

input InputAzureFunction {
    functionName: String!
    authLevel:    String!
}

input InputServiceSpec  {
    # oneof: swagger | grpc
    swagger: InputSwaggerServiceSpec
    grpc:    InputGRPCServiceSpec
}

# Not implemented yet
input InputSwaggerServiceSpec  {
    empty: String
}

# Not implemented yet
input InputGRPCServiceSpec {
    empty: String
}

input InputMetadata {
    name:            String!
    namespace:       String!
    resourceVersion: String!
    labels:          MapStringString
    annotations:     MapStringString
}

input InputStatus {
    state:  State!
    reason: String
}






## VirtualService
## VirtualService
## VirtualService
## VirtualService
## VirtualService
## VirtualService

type VirtualService {
    domains: [String]
    routes:  [Route]
    sslConfig: SslConfig
    plugins: VirtualServicePlugins

    metadata: Metadata!
    status:   Status!
}


type Route {
    matcher: Matcher!
    destination: Destination!
}

# not implemented
type VirtualServicePlugins {
    empty: String
}

type Matcher {
    pathMatch: String!
    pathMatchType: PathMatchType!
    headers: [KeyValueMatcher]
    queryParameters: [KeyValueMatcher]
    methods: [String]
}

type KeyValueMatcher {
    name: String!
    value: String!
    isRegex: Boolean!
}

union Destination = MultiDestination | SingleDestination

type MultiDestination {
    destinations: [WeightedDestination]
}

type WeightedDestination {
    destination: SingleDestination!
    weight: Int!
}

type SingleDestination {
    upstreamName: String!
    destinationSpec: DestinationSpec
}

union DestinationSpec = AwsDestinationSpec | AzureDestinationSpec

type AwsDestinationSpec {
    logicalName: String!
    invocationStyle: AwsLambdaInvocationStyle!
}

type AzureDestinationSpec {
    functionName: String!
}

type SslConfig {
    secretRef: String!
}

# InputVirtualService
# InputVirtualService
# InputVirtualService
# InputVirtualService

input InputVirtualService {
    domains: [String]
    routes:  [InputRoute]
    sslConfig: InputSslConfig
    plugins: InputVirtualServicePlugins
    metadata: InputMetadata
}


input InputRoute {
    matcher: InputMatcher!
    destination: InputDestination!
}

# not implemented
input InputVirtualServicePlugins {
    empty: String
}

input InputMatcher {
    pathMatch: String!
    pathMatchType: PathMatchType!
    headers: [InputKeyValueMatcher]
    queryParameters: [InputKeyValueMatcher]
    methods: [String]
}

input InputKeyValueMatcher {
    name: String!
    value: String!
    isRegex: Boolean!
}

input InputDestination {
    # oneof: MultiDestination, SingleDestination
    singleDestination: InputSingleDestination
    multiDestination: InputMultiDestination
}

input InputMultiDestination {
    destinations: [InputWeightedDestination]
}

input InputWeightedDestination {
    destination: InputDestination!
    weight: Int!
}

input InputSingleDestination {
    upstreamName: String!
    destinationSpec: InputDestinationSpec
}

input InputDestinationSpec {
    # oneof: aws | azure
    aws: InputAwsDestinationSpec
    azure: InputAzureDestinationSpec
}

input InputAwsDestinationSpec {
    logicalName: String!
    invocationStyle: AwsLambdaInvocationStyle!
}

input InputAzureDestinationSpec {
    functionName: String!
}

input InputSslConfig {
    secretRef: String!
}



## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap


type ResolverMap {
    # can't do maps, thanks facebook
    # the trick with type resolvers is the typeNames must be unique!
    # this converts to a map in the server
    # what a novel idea for a type system. maps... who would have thunk it?
    types: [TypeResolver]!
    metadata: Metadata!
    status:   Status!
}

type TypeResolver {
    typeName: String!
    # again, the fieldNames within this array must be unique
    fields: [FieldResolver]!
}

type FieldResolver {
    fieldName: String!
    resolver: Resolver!
}

union Resolver = GlooResolver | TemplateResolver | NodeJSResolver

# not implemented (ilackarms)
type GlooResolver {
    empty: String
}
type TemplateResolver {
    empty: String
}
type NodeJSResolver {
    empty: String
}



input InputResolverMap {
    # can't do maps, thanks facebook
    # the trick with type resolvers is the typeNames must be unique!
    # this converts to a map in the server
    # what a novel idea for a type system. maps... who would have thunk it?
    types: [InputTypeResolver]!
    metadata: InputMetadata!
}

input InputTypeResolver {
    typeName: String!
    # again, the fieldNames within this array must be unique
    fields: [InputFieldResolver]!
}

input InputFieldResolver {
    fieldName: String!
    resolver: InputResolver!
}

input InputResolver {
    # oneof: gloo, template, node
    glooResolver: InputGlooResolver
    templateResolver: InputTemplateResolver
    nodeResolver: InputNodeJSResolver
}

# not implemented (ilackarms)
input InputGlooResolver {
    empty: String
}
input InputTemplateResolver {
    empty: String
}
input InputNodeJSResolver {
    empty: String
}


# Common output types
# Common output types
# Common output types
# Common output types
# Common output types

type Metadata {
    name:            String!
    namespace:       String!
    resourceVersion: String!
    labels:          MapStringString
    annotations:     MapStringString
}

type Status {
    state:  State!
    reason: String
}




# Scalars / Extra

enum State {
    PENDING
    ACCEPTED
    REJECTED
}

scalar MapStringString

enum PathMatchType {
    PREFIX
    REGEX
    EXACT
}

enum AwsLambdaInvocationStyle {
    SYNC
    ASYNC
}
