# Query / Outputs
# Query / Outputs
# Query / Outputs
# Query / Outputs

schema {
    query: Query
    mutation: Mutation
}

type Query {
    upstreams(namespace: String!):       UpstreamQuery
}

type UpstreamQuery {
    list(selector: MapStringString): [Upstream]
    get(name: String):                Upstream
}

type Upstream {
    spec:     UpstreamSpec!
    metadata: Metadata!
    status:   Status!
}

union UpstreamSpec = AwsUpstreamSpec | AzureUpstreamSpec | KubeUpstreamSpec

type AwsUpstreamSpec {
    region:    String!
    secretRef: String!
    functions: [AwsLambdaFunction]
}

type AzureUpstreamSpec {
    functionAppName: String!
    secretRef:       String
    functions:       [AzureFunction]
}

type KubeUpstreamSpec {
    serviceName:      String!
    serviceNamespace: String!
    servicePort:      Int!
    selector:         MapStringString
}

type AwsLambdaFunction {
    functionName: String!
    qualifier:    String!
}

type AzureFunction {
    functionName: String!
    authLevel:    String!
}

union ServiceSpec = SwaggerServiceSpec | GRPCServiceSpec

# Not implemented yet
type SwaggerServiceSpec  {
    empty: String
}

# Not implemented yet
type GRPCServiceSpec {
    empty: String
}

type Metadata {
    name:            String!
    namespace:       String!
    resourceVersion: String!
    labels:          MapStringString
    annotations:     MapStringString
}

type Status {
    state:  State!
    reason: String
}















# Mutations/Inputs
# Mutations/Inputs
# Mutations/Inputs
# Mutations/Inputs

type Mutation {
    upstreams(namespace: String!): UpstreamMutation
}

type UpstreamMutation {
    create(upstream: InputUpstream!): Upstream
    update(upstream: InputUpstream!): Upstream
}

input InputUpstream {
    spec:     InputUpstreamSpec!
    metadata: InputMetadata!
    status:   InputStatus!
}

input InputUpstreamSpec {
    # oneof: aws | azure | kube
    aws: InputAwsUpstreamSpec
    azure: InputAzureUpstreamSpec
    kube: InputKubeUpstreamSpec
}

input InputAwsUpstreamSpec {
    region:    String!
    secretRef: String!
    functions: [InputAwsLambdaFunction]
}

input InputAzureUpstreamSpec {
    functionAppName: String!
    secretRef:       String
    functions:       [InputAzureFunction]
}

input InputKubeUpstreamSpec {
    serviceName:      String!
    serviceNamespace: String!
    servicePort:      Int!
    selector:         MapStringString
}

input InputAwsLambdaFunction {
    functionName: String!
    qualifier:    String!
}

input InputAzureFunction {
    functionName: String!
    authLevel:    String!
}

input InputServiceSpec  {
    # oneof: swagger | grpc
    swagger: InputSwaggerServiceSpec
    grpc:    InputGRPCServiceSpec
}

# Not implemented yet
input InputSwaggerServiceSpec  {
    empty: String
}

# Not implemented yet
input InputGRPCServiceSpec {
    empty: String
}

input InputMetadata {
    name:            String!
    namespace:       String!
    resourceVersion: String!
    labels:          MapStringString
    annotations:     MapStringString
}

input InputStatus {
    state:  State!
    reason: String
}






# Scalars / Extra

enum State {
    PENDING
    ACCEPTED
    REJECTED
}

scalar MapStringString


#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
## The mutation type, represents all updates we can make to our data
#type Mutation {
#    createUpstream(upstream: InputUpstream!) : Upstream
#    updateUpstream(upstream: InputUpstream!) : Upstream
#    deleteUpstream(name: String!) : Boolean
#
#    createVirtualService(virtualService: InputVirtualService!) : VirtualService
#    updateVirtualService(virtualService: InputVirtualService!) : VirtualService
#    deleteVirtualService(name: String!) : Boolean
#
#    addRoute(virtualServiceName: String!, index: Int!, route: InputRoute!) : VirtualService
#    updateRoute(virtualServiceName: String!, index: Int!, route: InputRoute!) : VirtualService
#    deleteRoute(virtualServiceName: String!, index: Int!) : VirtualService
#}
#
####
#### Output types
####
#
#type Upstream {
#    spec: UpstreamSpec!
#    status: Status!
#    metadata: Metadata!
#}
#
#type VirtualService {
#    name: String!
#    domains: [String]
#    routes: [Route]
#    sslConfig: SSLConfig
#    roles: [String]
#    status: Status
#    metadata: Metadata
#    destinationUpstreams: [Upstream]
#}
#
#type Route {
#    matcher: Matcher!
#    destination: Destination!
#    prefixRewrite: String
#    extensions: Struct
#}
#
#type MultiDestination {
#    weighedDestinations: [WeightedDestination]!
#}
#
#type WeightedDestination {
#    destination: SingleDestination!
#    weight: Int!
#}
#
#type RequestMatcher {
#    path: Path!
#    headers: MapStringString
#    queryParams: MapStringString
#    verbs: [String]
#}
#
#type EventMatcher {
#    eventType: String!
#}
#
#type SSLConfig {
#    secretRef: String!
#}
#type UpstreamDestination {
#    name: String!
#}
#
#type FunctionDestination {
#    upstreamName: String!
#    functionName: String!
#}
#
#type PathPrefix implements Path {
#    path: String!
#}
#type PathRegex implements Path {
#    path: String!
#}
#type PathExact implements Path {
#    path: String!
#}
#
#type Function {
#    name: String!
#    spec: Struct
#}
#
#type ServiceInfo {
#    type: String!
#    properties: Struct
#}
#
#type Status {
#    state: State!
#    reason: String
#}
#
#type Metadata {
#    resourceVersion: String!
#    namespace: String
#    annotations: MapStringString
#}
#
#type UserConfigProperty {
#    key: String!
#    value: String!
#}
#
####
#### Input types
####
#
#input InputUpstream {
#    name: String!
#    type: String!
#    connectionTimeout: Duration
#    spec: Struct
#    functions: [InputFunction]
#    serviceInfo: InputServiceInfo
#    metadata: InputMetadata
#}
#
#input InputVirtualService {
#    name: String!
#    domains: [String]
#    routes: [InputRoute]
#    sslConfig: InputSSLConfig
#    roles: [String]
#    metadata: InputMetadata
#}
#
#input InputRoute {
#    matcher: InputMatcher!
#    destination: InputDestination!
#
#    prefixRewrite: String
#    extensions: Struct
#}
#
#input InputMatcher {
#    # oneof requestMatcher | eventMatcher
#    requestMatcher: InputRequestMatcher
#    eventMatcher: InputEventMatcher
#}
#input InputDestination {
#    # oneof multiDestinations | singleDestination
#    singleDestination: InputSingleDestination
#    multiDestinations: [InputWeightedDestination]
#}
#
#input InputWeightedDestination {
#    destination: InputSingleDestination!
#    weight: Int!
#}
#
#input InputSingleDestination {
#    # oneof upstreamDestination | functionDestination
#    upstreamDestination: InputUpstreamDestination
#    functionDestination: InputFunctionDestination
#}
#
#input InputRequestMatcher {
#    # oneof pathPrefix | pathRegex | pathExact
#    pathPrefix: InputPathPrefix
#    pathRegex: InputPathRegex
#    pathExact: InputPathExact
#
#    headers: MapStringString
#    queryParams: MapStringString
#    verbs: [String]
#}
#
#input InputEventMatcher {
#    eventType: String!
#}
#
#input InputSSLConfig {
#    secretRef: String!
#}
#input InputUpstreamDestination {
#    name: String!
#}
#
#input InputFunctionDestination {
#    upstreamName: String!
#    functionName: String!
#}
#
#input InputPathPrefix {
#    path: String!
#}
#input InputPathRegex {
#    path: String!
#}
#input InputPathExact {
#    path: String!
#}
#
#input InputFunction {
#    name: String!
#    spec: Struct
#}
#
#input InputServiceInfo {
#    type: String!
#    properties: Struct
#}
#
#input InputStatus {
#    state: State!
#    reason: String
#}
#
#input InputMetadata {
#    resourceVersion: String!
#    namespace: String
#    annotations: MapStringString
#}
#
#input InputUserConfigProperty {
#    key: String!
#    value: String!
#}
#
#
#
#
#
####
#### Interfaces, enums, scalars
####
#union Matcher = RequestMatcher | EventMatcher
#
#type SingleDestination {
#    destination: SingleDestinationUnion!
#}
#
#union Destination = MultiDestination | SingleDestination
#union SingleDestinationUnion = FunctionDestination | UpstreamDestination
#
#interface Path {
#    path: String!
#}
#
#enum State {
#    PENDING
#    ACCEPTED
#    REJECTED
#}
#
#scalar Duration
#scalar Struct
## graphql doesnt have generics or maps
#scalar MapStringString
