// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtualservice.proto

package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf1 "google/protobuf"
import _ "github.com/gogo/protobuf/gogoproto"
import core_solo_io "github.com/solo-io/solo-kit/pkg/api/v1/resources/core"
import core_solo_io1 "github.com/solo-io/solo-kit/pkg/api/v1/resources/core"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

//
// @solo-kit:resource
// @solo-kit:resource.short_name=vs
// @solo-kit:resource.plural_name=virtualservices
// @solo-kit:resource.group_name=gloo.solo.io
// @solo-kit:resource.version=v1
//
// Virtual Services represent a collection of routes for a set of domains.
// Gloo's Virtual Services can be compared to
// [virtual hosts](https://www.envoyproxy.io/docs/envoy/latest/api-v1/route_config/vService.html?highlight=virtual%20host) in Envoy terminology.
// A virtual service can be used to define "apps"; a collection of APIs that belong to a particular domain.
// The Virtual Service concept allows configuration of per-virtualservice SSL certificates
type VirtualService struct {
	// Name of the virtual service. Names must be unique and follow the following syntax rules:
	// One or more lowercase rfc1035/rfc1123 labels separated by '.' with a maximum length of 253 characters.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Domains represent the list of domains (host/authority header) that will match for all routes on this virtual service.
	// As in Envoy: wildcard hosts are supported in the form of “*.foo.com” or “*-bar.foo.com”.
	// If domains is empty, gloo will set the domain to "*", making that virtual service the "default" virtualservice.
	// The default virtualservice will be the fallback virtual service for all requests that do not match a domain on an existing virtual service.
	// Only one default virtual service can be defined (either with an empty domain list, or a domain list that includes "*")
	Domains []string `protobuf:"bytes,2,rep,name=domains" json:"domains,omitempty"`
	// Routes define the list of [routes](../) that live on this virtual service.
	Routes []*Route `protobuf:"bytes,3,rep,name=routes" json:"routes,omitempty"`
	// SSL Config is optional for the virtual service. If provided, the virtual service will listen on the envoy HTTPS listener port (default :8443)
	// If left empty, the virtual service will listen on the HTTP listener port (default :8080)
	SslConfig *SSLConfig `protobuf:"bytes,4,opt,name=ssl_config,json=sslConfig" json:"ssl_config,omitempty"`
	// indicates whether or not this virtual service should be assigned to gateway roles automatically
	// TODO: eventually this flag will be deprecated; gateway roles will have to explicitly state the virtual services
	// they have access to.
	DisableForGateways bool `protobuf:"varint,7,opt,name=disable_for_gateways,json=disableForGateways,proto3" json:"disable_for_gateways,omitempty"`
	// Status indicates the validation status of the virtual service resource. Status is read-only by clients, and set by gloo during validation
	Status *core_solo_io1.Status `protobuf:"bytes,5,opt,name=status" json:"status,omitempty" testdiff:"ignore"`
	// Metadata contains the object metadata for this resource
	Metadata *core_solo_io.Metadata `protobuf:"bytes,6,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *VirtualService) Reset()                    { *m = VirtualService{} }
func (m *VirtualService) String() string            { return proto.CompactTextString(m) }
func (*VirtualService) ProtoMessage()               {}
func (*VirtualService) Descriptor() ([]byte, []int) { return fileDescriptorVirtualservice, []int{0} }

func (m *VirtualService) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VirtualService) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *VirtualService) GetRoutes() []*Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *VirtualService) GetSslConfig() *SSLConfig {
	if m != nil {
		return m.SslConfig
	}
	return nil
}

func (m *VirtualService) GetDisableForGateways() bool {
	if m != nil {
		return m.DisableForGateways
	}
	return false
}

func (m *VirtualService) GetStatus() *core_solo_io1.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *VirtualService) GetMetadata() *core_solo_io.Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// *
// Routes declare the entrypoints on virtual services and the upstreams or functions they route requests to
type Route struct {
	// Matcher defines what properties of a request to match on.
	// Routes will route all requests they match.
	// If a request matches more than one route, the first route on the virtual service's route list will be selected.
	//
	// Types that are valid to be assigned to Matcher:
	//	*Route_RequestMatcher
	//	*Route_EventMatcher
	Matcher isRoute_Matcher `protobuf_oneof:"matcher"`
	// A route is only allowed to specify one of multiple_destinations or single_destination. Setting both will result in an error
	// Multiple Destinations is used when a user wants a route to balance requests between multiple destinations
	// Balancing is done by probability, where weights are specified for each destination
	MultipleDestinations []*WeightedDestination `protobuf:"bytes,3,rep,name=multiple_destinations,json=multipleDestinations" json:"multiple_destinations,omitempty"`
	// A single destination is specified when a route only routes to a single destination.
	SingleDestination *Destination `protobuf:"bytes,4,opt,name=single_destination,json=singleDestination" json:"single_destination,omitempty"`
	// PrefixRewrite can be specified to rewrite the matched path of the request path to a new prefix
	PrefixRewrite string `protobuf:"bytes,5,opt,name=prefix_rewrite,json=prefixRewrite,proto3" json:"prefix_rewrite,omitempty"`
	// Extensions provides a way to extend the behavior of a route. In addition to the core route extensions<!--(TODO)-->,
	// gloo provides the means for route plugins<!--(TODO)--> to be added to gloo which add new types of route extensions.
	// <!--See the route extensions section for a more detailed explanation-->
	Extensions *google_protobuf1.Struct `protobuf:"bytes,6,opt,name=extensions" json:"extensions,omitempty"`
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptorVirtualservice, []int{1} }

type isRoute_Matcher interface {
	isRoute_Matcher()
	Equal(interface{}) bool
}

type Route_RequestMatcher struct {
	RequestMatcher *RequestMatcher `protobuf:"bytes,1,opt,name=request_matcher,json=requestMatcher,oneof"`
}
type Route_EventMatcher struct {
	EventMatcher *EventMatcher `protobuf:"bytes,2,opt,name=event_matcher,json=eventMatcher,oneof"`
}

func (*Route_RequestMatcher) isRoute_Matcher() {}
func (*Route_EventMatcher) isRoute_Matcher()   {}

func (m *Route) GetMatcher() isRoute_Matcher {
	if m != nil {
		return m.Matcher
	}
	return nil
}

func (m *Route) GetRequestMatcher() *RequestMatcher {
	if x, ok := m.GetMatcher().(*Route_RequestMatcher); ok {
		return x.RequestMatcher
	}
	return nil
}

func (m *Route) GetEventMatcher() *EventMatcher {
	if x, ok := m.GetMatcher().(*Route_EventMatcher); ok {
		return x.EventMatcher
	}
	return nil
}

func (m *Route) GetMultipleDestinations() []*WeightedDestination {
	if m != nil {
		return m.MultipleDestinations
	}
	return nil
}

func (m *Route) GetSingleDestination() *Destination {
	if m != nil {
		return m.SingleDestination
	}
	return nil
}

func (m *Route) GetPrefixRewrite() string {
	if m != nil {
		return m.PrefixRewrite
	}
	return ""
}

func (m *Route) GetExtensions() *google_protobuf1.Struct {
	if m != nil {
		return m.Extensions
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Route) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Route_OneofMarshaler, _Route_OneofUnmarshaler, _Route_OneofSizer, []interface{}{
		(*Route_RequestMatcher)(nil),
		(*Route_EventMatcher)(nil),
	}
}

func _Route_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Route)
	// matcher
	switch x := m.Matcher.(type) {
	case *Route_RequestMatcher:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RequestMatcher); err != nil {
			return err
		}
	case *Route_EventMatcher:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EventMatcher); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Route.Matcher has unexpected type %T", x)
	}
	return nil
}

func _Route_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Route)
	switch tag {
	case 1: // matcher.request_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RequestMatcher)
		err := b.DecodeMessage(msg)
		m.Matcher = &Route_RequestMatcher{msg}
		return true, err
	case 2: // matcher.event_matcher
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EventMatcher)
		err := b.DecodeMessage(msg)
		m.Matcher = &Route_EventMatcher{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Route_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Route)
	// matcher
	switch x := m.Matcher.(type) {
	case *Route_RequestMatcher:
		s := proto.Size(x.RequestMatcher)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Route_EventMatcher:
		s := proto.Size(x.EventMatcher)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Request Matcher is a route matcher for traditional http requests
// Request Matchers stand in juxtoposition to Event Matchers, which match "events" rather than HTTP Requests
type RequestMatcher struct {
	// Path specifies the :path header in HTTP2, or the request URL path in HTTP 1
	//
	// Types that are valid to be assigned to Path:
	//	*RequestMatcher_PathPrefix
	//	*RequestMatcher_PathRegex
	//	*RequestMatcher_PathExact
	Path isRequestMatcher_Path `protobuf_oneof:"path"`
	// Headers specify a list of request headers and their values the request must contain to match this route
	// If a value is not specified (empty string) for a header, all values will match so long as the header is present on the request
	Headers map[string]string `protobuf:"bytes,4,rep,name=headers" json:"headers,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Query params work the same way as headers, but for query string parameters
	QueryParams map[string]string `protobuf:"bytes,5,rep,name=query_params,json=queryParams" json:"query_params,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// HTTP Verb(s) to match on. If none specified, the matcher will match all verbs
	Verbs []string `protobuf:"bytes,6,rep,name=verbs" json:"verbs,omitempty"`
}

func (m *RequestMatcher) Reset()                    { *m = RequestMatcher{} }
func (m *RequestMatcher) String() string            { return proto.CompactTextString(m) }
func (*RequestMatcher) ProtoMessage()               {}
func (*RequestMatcher) Descriptor() ([]byte, []int) { return fileDescriptorVirtualservice, []int{2} }

type isRequestMatcher_Path interface {
	isRequestMatcher_Path()
	Equal(interface{}) bool
}

type RequestMatcher_PathPrefix struct {
	PathPrefix string `protobuf:"bytes,1,opt,name=path_prefix,json=pathPrefix,proto3,oneof"`
}
type RequestMatcher_PathRegex struct {
	PathRegex string `protobuf:"bytes,2,opt,name=path_regex,json=pathRegex,proto3,oneof"`
}
type RequestMatcher_PathExact struct {
	PathExact string `protobuf:"bytes,3,opt,name=path_exact,json=pathExact,proto3,oneof"`
}

func (*RequestMatcher_PathPrefix) isRequestMatcher_Path() {}
func (*RequestMatcher_PathRegex) isRequestMatcher_Path()  {}
func (*RequestMatcher_PathExact) isRequestMatcher_Path()  {}

func (m *RequestMatcher) GetPath() isRequestMatcher_Path {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *RequestMatcher) GetPathPrefix() string {
	if x, ok := m.GetPath().(*RequestMatcher_PathPrefix); ok {
		return x.PathPrefix
	}
	return ""
}

func (m *RequestMatcher) GetPathRegex() string {
	if x, ok := m.GetPath().(*RequestMatcher_PathRegex); ok {
		return x.PathRegex
	}
	return ""
}

func (m *RequestMatcher) GetPathExact() string {
	if x, ok := m.GetPath().(*RequestMatcher_PathExact); ok {
		return x.PathExact
	}
	return ""
}

func (m *RequestMatcher) GetHeaders() map[string]string {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *RequestMatcher) GetQueryParams() map[string]string {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

func (m *RequestMatcher) GetVerbs() []string {
	if m != nil {
		return m.Verbs
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RequestMatcher) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RequestMatcher_OneofMarshaler, _RequestMatcher_OneofUnmarshaler, _RequestMatcher_OneofSizer, []interface{}{
		(*RequestMatcher_PathPrefix)(nil),
		(*RequestMatcher_PathRegex)(nil),
		(*RequestMatcher_PathExact)(nil),
	}
}

func _RequestMatcher_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RequestMatcher)
	// path
	switch x := m.Path.(type) {
	case *RequestMatcher_PathPrefix:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.PathPrefix)
	case *RequestMatcher_PathRegex:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.PathRegex)
	case *RequestMatcher_PathExact:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.PathExact)
	case nil:
	default:
		return fmt.Errorf("RequestMatcher.Path has unexpected type %T", x)
	}
	return nil
}

func _RequestMatcher_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RequestMatcher)
	switch tag {
	case 1: // path.path_prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Path = &RequestMatcher_PathPrefix{x}
		return true, err
	case 2: // path.path_regex
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Path = &RequestMatcher_PathRegex{x}
		return true, err
	case 3: // path.path_exact
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Path = &RequestMatcher_PathExact{x}
		return true, err
	default:
		return false, nil
	}
}

func _RequestMatcher_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RequestMatcher)
	// path
	switch x := m.Path.(type) {
	case *RequestMatcher_PathPrefix:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.PathPrefix)))
		n += len(x.PathPrefix)
	case *RequestMatcher_PathRegex:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.PathRegex)))
		n += len(x.PathRegex)
	case *RequestMatcher_PathExact:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.PathExact)))
		n += len(x.PathExact)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Event matcher is a special kind of matcher for CloudEvents
// The CloudEvents API is described here: https://github.com/cloudevents/spec/blob/master/spec.md
type EventMatcher struct {
	// Event Type indicates the event type or topic to match
	EventType string `protobuf:"bytes,1,opt,name=event_type,json=eventType,proto3" json:"event_type,omitempty"`
}

func (m *EventMatcher) Reset()                    { *m = EventMatcher{} }
func (m *EventMatcher) String() string            { return proto.CompactTextString(m) }
func (*EventMatcher) ProtoMessage()               {}
func (*EventMatcher) Descriptor() ([]byte, []int) { return fileDescriptorVirtualservice, []int{3} }

func (m *EventMatcher) GetEventType() string {
	if m != nil {
		return m.EventType
	}
	return ""
}

// WeightedDestination attaches a weight to a destination
// For use in routes with multiple destinations
type WeightedDestination struct {
	*Destination `protobuf:"bytes,1,opt,name=destination,embedded=destination" json:"destination,omitempty"`
	// Weight must be greater than zero
	// Routing to each destination will be balanced by the ratio of the destination's weight to the total weight on a route
	Weight uint32 `protobuf:"varint,2,opt,name=weight,proto3" json:"weight,omitempty"`
}

func (m *WeightedDestination) Reset()         { *m = WeightedDestination{} }
func (m *WeightedDestination) String() string { return proto.CompactTextString(m) }
func (*WeightedDestination) ProtoMessage()    {}
func (*WeightedDestination) Descriptor() ([]byte, []int) {
	return fileDescriptorVirtualservice, []int{4}
}

func (m *WeightedDestination) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

// Destination is a destination that requests can be routed to.
type Destination struct {
	// Types that are valid to be assigned to DestinationType:
	//	*Destination_Function
	//	*Destination_Upstream
	DestinationType isDestination_DestinationType `protobuf_oneof:"destination_type"`
}

func (m *Destination) Reset()                    { *m = Destination{} }
func (m *Destination) String() string            { return proto.CompactTextString(m) }
func (*Destination) ProtoMessage()               {}
func (*Destination) Descriptor() ([]byte, []int) { return fileDescriptorVirtualservice, []int{5} }

type isDestination_DestinationType interface {
	isDestination_DestinationType()
	Equal(interface{}) bool
}

type Destination_Function struct {
	Function *FunctionDestination `protobuf:"bytes,1,opt,name=function,oneof"`
}
type Destination_Upstream struct {
	Upstream *UpstreamDestination `protobuf:"bytes,2,opt,name=upstream,oneof"`
}

func (*Destination_Function) isDestination_DestinationType() {}
func (*Destination_Upstream) isDestination_DestinationType() {}

func (m *Destination) GetDestinationType() isDestination_DestinationType {
	if m != nil {
		return m.DestinationType
	}
	return nil
}

func (m *Destination) GetFunction() *FunctionDestination {
	if x, ok := m.GetDestinationType().(*Destination_Function); ok {
		return x.Function
	}
	return nil
}

func (m *Destination) GetUpstream() *UpstreamDestination {
	if x, ok := m.GetDestinationType().(*Destination_Upstream); ok {
		return x.Upstream
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Destination) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Destination_OneofMarshaler, _Destination_OneofUnmarshaler, _Destination_OneofSizer, []interface{}{
		(*Destination_Function)(nil),
		(*Destination_Upstream)(nil),
	}
}

func _Destination_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Destination)
	// destination_type
	switch x := m.DestinationType.(type) {
	case *Destination_Function:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Function); err != nil {
			return err
		}
	case *Destination_Upstream:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Upstream); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Destination.DestinationType has unexpected type %T", x)
	}
	return nil
}

func _Destination_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Destination)
	switch tag {
	case 1: // destination_type.function
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(FunctionDestination)
		err := b.DecodeMessage(msg)
		m.DestinationType = &Destination_Function{msg}
		return true, err
	case 2: // destination_type.upstream
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(UpstreamDestination)
		err := b.DecodeMessage(msg)
		m.DestinationType = &Destination_Upstream{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Destination_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Destination)
	// destination_type
	switch x := m.DestinationType.(type) {
	case *Destination_Function:
		s := proto.Size(x.Function)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Destination_Upstream:
		s := proto.Size(x.Upstream)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// FunctionDestination will route a request to a specific function defined for an upstream
type FunctionDestination struct {
	// Upstream Name is the name of the upstream the function belongs to
	UpstreamName string `protobuf:"bytes,1,opt,name=upstream_name,json=upstreamName,proto3" json:"upstream_name,omitempty"`
	// Function Name is the name of the function as defined on the upstream
	FunctionName string `protobuf:"bytes,2,opt,name=function_name,json=functionName,proto3" json:"function_name,omitempty"`
}

func (m *FunctionDestination) Reset()         { *m = FunctionDestination{} }
func (m *FunctionDestination) String() string { return proto.CompactTextString(m) }
func (*FunctionDestination) ProtoMessage()    {}
func (*FunctionDestination) Descriptor() ([]byte, []int) {
	return fileDescriptorVirtualservice, []int{6}
}

func (m *FunctionDestination) GetUpstreamName() string {
	if m != nil {
		return m.UpstreamName
	}
	return ""
}

func (m *FunctionDestination) GetFunctionName() string {
	if m != nil {
		return m.FunctionName
	}
	return ""
}

// Upstream Destination routes a request to an upstream
type UpstreamDestination struct {
	// Name of the upstream
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *UpstreamDestination) Reset()         { *m = UpstreamDestination{} }
func (m *UpstreamDestination) String() string { return proto.CompactTextString(m) }
func (*UpstreamDestination) ProtoMessage()    {}
func (*UpstreamDestination) Descriptor() ([]byte, []int) {
	return fileDescriptorVirtualservice, []int{7}
}

func (m *UpstreamDestination) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// SSLConfig contains the options necessary to configure a virtualservice or listener to use TLS
type SSLConfig struct {
	// Types that are valid to be assigned to SslSecrets:
	//	*SSLConfig_SecretRef
	//	*SSLConfig_SslFiles
	SslSecrets isSSLConfig_SslSecrets `protobuf_oneof:"ssl_secrets"`
	// optional. the SNI domains that should be considered for TLS connections
	SniDomains []string `protobuf:"bytes,3,rep,name=sni_domains,json=sniDomains" json:"sni_domains,omitempty"`
}

func (m *SSLConfig) Reset()                    { *m = SSLConfig{} }
func (m *SSLConfig) String() string            { return proto.CompactTextString(m) }
func (*SSLConfig) ProtoMessage()               {}
func (*SSLConfig) Descriptor() ([]byte, []int) { return fileDescriptorVirtualservice, []int{8} }

type isSSLConfig_SslSecrets interface {
	isSSLConfig_SslSecrets()
	Equal(interface{}) bool
}

type SSLConfig_SecretRef struct {
	SecretRef string `protobuf:"bytes,1,opt,name=secret_ref,json=secretRef,proto3,oneof"`
}
type SSLConfig_SslFiles struct {
	SslFiles *SSLFiles `protobuf:"bytes,2,opt,name=ssl_files,json=sslFiles,oneof"`
}

func (*SSLConfig_SecretRef) isSSLConfig_SslSecrets() {}
func (*SSLConfig_SslFiles) isSSLConfig_SslSecrets()  {}

func (m *SSLConfig) GetSslSecrets() isSSLConfig_SslSecrets {
	if m != nil {
		return m.SslSecrets
	}
	return nil
}

func (m *SSLConfig) GetSecretRef() string {
	if x, ok := m.GetSslSecrets().(*SSLConfig_SecretRef); ok {
		return x.SecretRef
	}
	return ""
}

func (m *SSLConfig) GetSslFiles() *SSLFiles {
	if x, ok := m.GetSslSecrets().(*SSLConfig_SslFiles); ok {
		return x.SslFiles
	}
	return nil
}

func (m *SSLConfig) GetSniDomains() []string {
	if m != nil {
		return m.SniDomains
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SSLConfig) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SSLConfig_OneofMarshaler, _SSLConfig_OneofUnmarshaler, _SSLConfig_OneofSizer, []interface{}{
		(*SSLConfig_SecretRef)(nil),
		(*SSLConfig_SslFiles)(nil),
	}
}

func _SSLConfig_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SSLConfig)
	// ssl_secrets
	switch x := m.SslSecrets.(type) {
	case *SSLConfig_SecretRef:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.SecretRef)
	case *SSLConfig_SslFiles:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SslFiles); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SSLConfig.SslSecrets has unexpected type %T", x)
	}
	return nil
}

func _SSLConfig_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SSLConfig)
	switch tag {
	case 1: // ssl_secrets.secret_ref
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.SslSecrets = &SSLConfig_SecretRef{x}
		return true, err
	case 2: // ssl_secrets.ssl_files
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SSLFiles)
		err := b.DecodeMessage(msg)
		m.SslSecrets = &SSLConfig_SslFiles{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SSLConfig_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SSLConfig)
	// ssl_secrets
	switch x := m.SslSecrets.(type) {
	case *SSLConfig_SecretRef:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.SecretRef)))
		n += len(x.SecretRef)
	case *SSLConfig_SslFiles:
		s := proto.Size(x.SslFiles)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// SSLFiles reference paths to certificates which can be read by the proxy off of its local filesystem
type SSLFiles struct {
	TlsCert string `protobuf:"bytes,1,opt,name=tls_cert,json=tlsCert,proto3" json:"tls_cert,omitempty"`
	TlsKey  string `protobuf:"bytes,2,opt,name=tls_key,json=tlsKey,proto3" json:"tls_key,omitempty"`
	// for client cert validation. optional
	RootCa string `protobuf:"bytes,3,opt,name=root_ca,json=rootCa,proto3" json:"root_ca,omitempty"`
}

func (m *SSLFiles) Reset()                    { *m = SSLFiles{} }
func (m *SSLFiles) String() string            { return proto.CompactTextString(m) }
func (*SSLFiles) ProtoMessage()               {}
func (*SSLFiles) Descriptor() ([]byte, []int) { return fileDescriptorVirtualservice, []int{9} }

func (m *SSLFiles) GetTlsCert() string {
	if m != nil {
		return m.TlsCert
	}
	return ""
}

func (m *SSLFiles) GetTlsKey() string {
	if m != nil {
		return m.TlsKey
	}
	return ""
}

func (m *SSLFiles) GetRootCa() string {
	if m != nil {
		return m.RootCa
	}
	return ""
}

func init() {
	proto.RegisterType((*VirtualService)(nil), "gloo.api.v1.VirtualService")
	proto.RegisterType((*Route)(nil), "gloo.api.v1.Route")
	proto.RegisterType((*RequestMatcher)(nil), "gloo.api.v1.RequestMatcher")
	proto.RegisterType((*EventMatcher)(nil), "gloo.api.v1.EventMatcher")
	proto.RegisterType((*WeightedDestination)(nil), "gloo.api.v1.WeightedDestination")
	proto.RegisterType((*Destination)(nil), "gloo.api.v1.Destination")
	proto.RegisterType((*FunctionDestination)(nil), "gloo.api.v1.FunctionDestination")
	proto.RegisterType((*UpstreamDestination)(nil), "gloo.api.v1.UpstreamDestination")
	proto.RegisterType((*SSLConfig)(nil), "gloo.api.v1.SSLConfig")
	proto.RegisterType((*SSLFiles)(nil), "gloo.api.v1.SSLFiles")
}
func (this *VirtualService) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualService)
	if !ok {
		that2, ok := that.(VirtualService)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	if !this.SslConfig.Equal(that1.SslConfig) {
		return false
	}
	if this.DisableForGateways != that1.DisableForGateways {
		return false
	}
	if !this.Status.Equal(that1.Status) {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *Route) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Route)
	if !ok {
		that2, ok := that.(Route)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Matcher == nil {
		if this.Matcher != nil {
			return false
		}
	} else if this.Matcher == nil {
		return false
	} else if !this.Matcher.Equal(that1.Matcher) {
		return false
	}
	if len(this.MultipleDestinations) != len(that1.MultipleDestinations) {
		return false
	}
	for i := range this.MultipleDestinations {
		if !this.MultipleDestinations[i].Equal(that1.MultipleDestinations[i]) {
			return false
		}
	}
	if !this.SingleDestination.Equal(that1.SingleDestination) {
		return false
	}
	if this.PrefixRewrite != that1.PrefixRewrite {
		return false
	}
	if !this.Extensions.Equal(that1.Extensions) {
		return false
	}
	return true
}
func (this *Route_RequestMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Route_RequestMatcher)
	if !ok {
		that2, ok := that.(Route_RequestMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RequestMatcher.Equal(that1.RequestMatcher) {
		return false
	}
	return true
}
func (this *Route_EventMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Route_EventMatcher)
	if !ok {
		that2, ok := that.(Route_EventMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.EventMatcher.Equal(that1.EventMatcher) {
		return false
	}
	return true
}
func (this *RequestMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestMatcher)
	if !ok {
		that2, ok := that.(RequestMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Path == nil {
		if this.Path != nil {
			return false
		}
	} else if this.Path == nil {
		return false
	} else if !this.Path.Equal(that1.Path) {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if this.Headers[i] != that1.Headers[i] {
			return false
		}
	}
	if len(this.QueryParams) != len(that1.QueryParams) {
		return false
	}
	for i := range this.QueryParams {
		if this.QueryParams[i] != that1.QueryParams[i] {
			return false
		}
	}
	if len(this.Verbs) != len(that1.Verbs) {
		return false
	}
	for i := range this.Verbs {
		if this.Verbs[i] != that1.Verbs[i] {
			return false
		}
	}
	return true
}
func (this *RequestMatcher_PathPrefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestMatcher_PathPrefix)
	if !ok {
		that2, ok := that.(RequestMatcher_PathPrefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PathPrefix != that1.PathPrefix {
		return false
	}
	return true
}
func (this *RequestMatcher_PathRegex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestMatcher_PathRegex)
	if !ok {
		that2, ok := that.(RequestMatcher_PathRegex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PathRegex != that1.PathRegex {
		return false
	}
	return true
}
func (this *RequestMatcher_PathExact) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestMatcher_PathExact)
	if !ok {
		that2, ok := that.(RequestMatcher_PathExact)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PathExact != that1.PathExact {
		return false
	}
	return true
}
func (this *EventMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventMatcher)
	if !ok {
		that2, ok := that.(EventMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EventType != that1.EventType {
		return false
	}
	return true
}
func (this *WeightedDestination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WeightedDestination)
	if !ok {
		that2, ok := that.(WeightedDestination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Destination.Equal(that1.Destination) {
		return false
	}
	if this.Weight != that1.Weight {
		return false
	}
	return true
}
func (this *Destination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Destination)
	if !ok {
		that2, ok := that.(Destination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.DestinationType == nil {
		if this.DestinationType != nil {
			return false
		}
	} else if this.DestinationType == nil {
		return false
	} else if !this.DestinationType.Equal(that1.DestinationType) {
		return false
	}
	return true
}
func (this *Destination_Function) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Destination_Function)
	if !ok {
		that2, ok := that.(Destination_Function)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Function.Equal(that1.Function) {
		return false
	}
	return true
}
func (this *Destination_Upstream) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Destination_Upstream)
	if !ok {
		that2, ok := that.(Destination_Upstream)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Upstream.Equal(that1.Upstream) {
		return false
	}
	return true
}
func (this *FunctionDestination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FunctionDestination)
	if !ok {
		that2, ok := that.(FunctionDestination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UpstreamName != that1.UpstreamName {
		return false
	}
	if this.FunctionName != that1.FunctionName {
		return false
	}
	return true
}
func (this *UpstreamDestination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpstreamDestination)
	if !ok {
		that2, ok := that.(UpstreamDestination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	return true
}
func (this *SSLConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SSLConfig)
	if !ok {
		that2, ok := that.(SSLConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.SslSecrets == nil {
		if this.SslSecrets != nil {
			return false
		}
	} else if this.SslSecrets == nil {
		return false
	} else if !this.SslSecrets.Equal(that1.SslSecrets) {
		return false
	}
	if len(this.SniDomains) != len(that1.SniDomains) {
		return false
	}
	for i := range this.SniDomains {
		if this.SniDomains[i] != that1.SniDomains[i] {
			return false
		}
	}
	return true
}
func (this *SSLConfig_SecretRef) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SSLConfig_SecretRef)
	if !ok {
		that2, ok := that.(SSLConfig_SecretRef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SecretRef != that1.SecretRef {
		return false
	}
	return true
}
func (this *SSLConfig_SslFiles) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SSLConfig_SslFiles)
	if !ok {
		that2, ok := that.(SSLConfig_SslFiles)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SslFiles.Equal(that1.SslFiles) {
		return false
	}
	return true
}
func (this *SSLFiles) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SSLFiles)
	if !ok {
		that2, ok := that.(SSLFiles)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TlsCert != that1.TlsCert {
		return false
	}
	if this.TlsKey != that1.TlsKey {
		return false
	}
	if this.RootCa != that1.RootCa {
		return false
	}
	return true
}

func init() { proto.RegisterFile("virtualservice.proto", fileDescriptorVirtualservice) }

var fileDescriptorVirtualservice = []byte{
	// 1001 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x55, 0xcd, 0x6e, 0x23, 0x45,
	0x10, 0x8e, 0xe3, 0xc4, 0x89, 0xcb, 0x76, 0xc8, 0x76, 0x9c, 0x5d, 0x6f, 0xf8, 0x89, 0x99, 0x15,
	0x92, 0x41, 0xec, 0x98, 0x84, 0x45, 0xa0, 0x1c, 0x56, 0x2b, 0x67, 0x93, 0x8d, 0x04, 0x0b, 0x4b,
	0x87, 0x65, 0x25, 0x2e, 0xa3, 0xce, 0xb8, 0x3c, 0x69, 0x32, 0x9e, 0x9e, 0x74, 0xf7, 0x38, 0xf1,
	0x6b, 0x70, 0xe6, 0x82, 0xc4, 0x81, 0x87, 0xe1, 0xc0, 0x13, 0xec, 0x81, 0x47, 0xe0, 0x09, 0x50,
	0x77, 0xcf, 0x24, 0x33, 0x51, 0x14, 0xc1, 0x69, 0xba, 0xbf, 0xfa, 0xbe, 0xaa, 0x9a, 0xea, 0xaa,
	0x6e, 0xe8, 0xce, 0xb8, 0xd4, 0x19, 0x8b, 0x15, 0xca, 0x19, 0x0f, 0xd1, 0x4f, 0xa5, 0xd0, 0x82,
	0xb4, 0xa2, 0x58, 0x08, 0x9f, 0xa5, 0xdc, 0x9f, 0xed, 0x6c, 0xbd, 0x17, 0x09, 0x11, 0xc5, 0x38,
	0xb4, 0xa6, 0x93, 0x6c, 0x32, 0x54, 0x5a, 0x66, 0xa1, 0x76, 0xd4, 0xad, 0x6e, 0x24, 0x22, 0x61,
	0x97, 0x43, 0xb3, 0xca, 0xd1, 0x9d, 0x88, 0xeb, 0xd3, 0xec, 0xc4, 0x0f, 0xc5, 0x74, 0xa8, 0x44,
	0x2c, 0x1e, 0x73, 0xe1, 0xbe, 0x67, 0x5c, 0x0f, 0x59, 0xca, 0x87, 0xb3, 0x9d, 0xe1, 0x14, 0x35,
	0x1b, 0x33, 0xcd, 0x72, 0xc9, 0xf0, 0x3f, 0x48, 0x94, 0x66, 0x3a, 0x53, 0x4e, 0xe0, 0xfd, 0xb9,
	0x08, 0x6b, 0x3f, 0xba, 0xec, 0x8f, 0x5d, 0xf6, 0x84, 0xc0, 0x52, 0xc2, 0xa6, 0xd8, 0xab, 0xf5,
	0x6b, 0x83, 0x26, 0xb5, 0x6b, 0xd2, 0x83, 0x95, 0xb1, 0x98, 0x32, 0x9e, 0xa8, 0xde, 0x62, 0xbf,
	0x3e, 0x68, 0xd2, 0x62, 0x4b, 0x3e, 0x81, 0x86, 0x14, 0x99, 0x46, 0xd5, 0xab, 0xf7, 0xeb, 0x83,
	0xd6, 0x2e, 0xf1, 0x4b, 0xbf, 0xed, 0x53, 0x63, 0xa2, 0x39, 0x83, 0x7c, 0x01, 0xa0, 0x54, 0x1c,
	0x84, 0x22, 0x99, 0xf0, 0xa8, 0xb7, 0xd4, 0xaf, 0x0d, 0x5a, 0xbb, 0xf7, 0x2b, 0xfc, 0xe3, 0xe3,
	0x6f, 0xf6, 0xad, 0x95, 0x36, 0x95, 0x8a, 0xdd, 0x92, 0x7c, 0x06, 0xdd, 0x31, 0x57, 0xec, 0x24,
	0xc6, 0x60, 0x22, 0x64, 0x10, 0x31, 0x8d, 0x17, 0x6c, 0xae, 0x7a, 0x2b, 0xfd, 0xda, 0x60, 0x95,
	0x92, 0xdc, 0x76, 0x28, 0xe4, 0x8b, 0xdc, 0x42, 0xf6, 0xa1, 0xe1, 0xfe, 0xb2, 0xb7, 0x6c, 0x83,
	0x74, 0xfd, 0x50, 0x48, 0xf4, 0x4d, 0x25, 0x7c, 0x2e, 0xfc, 0x63, 0x6b, 0x1b, 0x6d, 0xfe, 0xf3,
	0x76, 0xfb, 0x9e, 0x46, 0xa5, 0xc7, 0x7c, 0x32, 0xd9, 0xf3, 0x78, 0x94, 0x08, 0x89, 0x1e, 0xcd,
	0xa5, 0x64, 0x17, 0x56, 0x8b, 0xea, 0xf6, 0x1a, 0x79, 0xae, 0x15, 0x37, 0x2f, 0x73, 0x2b, 0xbd,
	0xe2, 0x79, 0xbf, 0xd6, 0x61, 0xd9, 0xfe, 0x33, 0x39, 0x84, 0x77, 0x24, 0x9e, 0x67, 0xa8, 0x74,
	0x30, 0x65, 0x3a, 0x3c, 0x45, 0x69, 0x0b, 0xda, 0xda, 0x7d, 0xb7, 0x5a, 0x20, 0xc7, 0x79, 0xe9,
	0x28, 0x47, 0x0b, 0x74, 0x4d, 0x56, 0x10, 0xf2, 0x0c, 0x3a, 0x38, 0xc3, 0xe4, 0xda, 0xcb, 0xa2,
	0xf5, 0xf2, 0xb0, 0xe2, 0xe5, 0xc0, 0x30, 0xae, 0x7d, 0xb4, 0xb1, 0xb4, 0x27, 0xaf, 0x61, 0x73,
	0x9a, 0xc5, 0x9a, 0xa7, 0x31, 0x06, 0x63, 0x54, 0x9a, 0x27, 0x4c, 0x73, 0x91, 0x14, 0x07, 0xd6,
	0xaf, 0x78, 0x7a, 0x83, 0x3c, 0x3a, 0xd5, 0x38, 0x7e, 0x7e, 0x4d, 0xa4, 0xdd, 0x42, 0x5e, 0x02,
	0x15, 0x79, 0x01, 0x44, 0xf1, 0x24, 0xaa, 0x3a, 0xcd, 0x0f, 0xb5, 0x57, 0xf1, 0x59, 0xf6, 0x75,
	0xcf, 0x69, 0x4a, 0x10, 0xf9, 0x08, 0xd6, 0x52, 0x89, 0x13, 0x7e, 0x19, 0x48, 0xbc, 0x90, 0x5c,
	0xa3, 0x3d, 0xb4, 0x26, 0xed, 0x38, 0x94, 0x3a, 0x90, 0x7c, 0x09, 0x80, 0x97, 0x1a, 0x13, 0x65,
	0x73, 0x77, 0x07, 0xf2, 0xc0, 0x77, 0x63, 0xe5, 0x17, 0x63, 0xe5, 0x1f, 0xdb, 0xb1, 0xa2, 0x25,
	0xea, 0xa8, 0x09, 0x2b, 0x79, 0xed, 0xbc, 0xdf, 0xeb, 0xb0, 0x56, 0xad, 0x38, 0xf9, 0x10, 0x5a,
	0x29, 0xd3, 0xa7, 0x81, 0x0b, 0xe6, 0x9a, 0xfe, 0x68, 0x81, 0x82, 0x01, 0x5f, 0x59, 0x8c, 0x6c,
	0x83, 0xdd, 0x05, 0x12, 0x23, 0xbc, 0xb4, 0xf5, 0x37, 0x8c, 0xa6, 0xc1, 0xa8, 0x81, 0xae, 0x08,
	0x78, 0xc9, 0x42, 0xdd, 0xab, 0x97, 0x09, 0x07, 0x06, 0x22, 0x23, 0x58, 0x39, 0x45, 0x36, 0x46,
	0xa9, 0x7a, 0x4b, 0xb6, 0xe8, 0x83, 0x3b, 0x9a, 0xc0, 0x3f, 0x72, 0xd4, 0x83, 0x44, 0xcb, 0x39,
	0x2d, 0x84, 0xe4, 0x3b, 0x68, 0x9f, 0x67, 0x28, 0xe7, 0x41, 0xca, 0x24, 0x9b, 0x9a, 0xce, 0x36,
	0x8e, 0x3e, 0xbd, 0xcb, 0xd1, 0xf7, 0x86, 0xff, 0xca, 0xd2, 0x9d, 0xb3, 0xd6, 0xf9, 0x35, 0x42,
	0xba, 0xb0, 0x3c, 0x43, 0x79, 0x62, 0x6a, 0x69, 0x26, 0xda, 0x6d, 0xb6, 0xf6, 0xa0, 0x5d, 0x8e,
	0x4f, 0xd6, 0xa1, 0x7e, 0x86, 0xf3, 0xfc, 0x32, 0x30, 0x4b, 0xab, 0x63, 0x71, 0x86, 0xae, 0x12,
	0xd4, 0x6d, 0xf6, 0x16, 0xbf, 0xaa, 0x6d, 0x3d, 0x85, 0xf5, 0x9b, 0x21, 0xff, 0x8f, 0x7e, 0xd4,
	0x80, 0x25, 0x53, 0x33, 0xef, 0x31, 0xb4, 0xcb, 0x1d, 0x4d, 0xde, 0x07, 0x70, 0x33, 0xa0, 0xe7,
	0x69, 0x71, 0x2f, 0x35, 0x2d, 0xf2, 0xc3, 0x3c, 0x45, 0x4f, 0xc0, 0xc6, 0x2d, 0x6d, 0x4b, 0x9e,
	0x41, 0xab, 0xdc, 0x99, 0xb5, 0xbb, 0x3b, 0x73, 0xb4, 0xf4, 0xd7, 0xdb, 0xed, 0x1a, 0x2d, 0x4b,
	0xc8, 0x7d, 0x68, 0x5c, 0x58, 0xc7, 0x36, 0xd5, 0x0e, 0xcd, 0x77, 0xde, 0x6f, 0x35, 0x68, 0x95,
	0x23, 0x3d, 0x85, 0xd5, 0x49, 0x96, 0x84, 0xa5, 0x30, 0xd5, 0xa1, 0x3a, 0xcc, 0x8d, 0x25, 0xcd,
	0xd1, 0x02, 0xbd, 0xd2, 0x18, 0x7d, 0x96, 0x2a, 0x2d, 0x91, 0x4d, 0xf3, 0xf1, 0xae, 0xea, 0x5f,
	0xe7, 0xc6, 0x1b, 0xfa, 0x42, 0x33, 0x22, 0xb0, 0x5e, 0x4a, 0xdb, 0x56, 0xc9, 0x0b, 0x60, 0xe3,
	0x96, 0xb0, 0xe4, 0x11, 0x74, 0x0a, 0x59, 0x50, 0xba, 0xe5, 0xdb, 0x05, 0xf8, 0xad, 0xb9, 0xed,
	0x1f, 0x41, 0xa7, 0xc8, 0xcd, 0x91, 0xdc, 0x49, 0xb5, 0x0b, 0xd0, 0x90, 0xbc, 0x8f, 0x61, 0xe3,
	0x96, 0xbc, 0x6e, 0x7b, 0x3d, 0xbc, 0x5f, 0x6a, 0xd0, 0xbc, 0xba, 0xd9, 0xcd, 0xb4, 0x28, 0x0c,
	0x25, 0xea, 0x40, 0xe2, 0xe4, 0x6a, 0xe0, 0x9a, 0x0e, 0xa3, 0x38, 0x21, 0x4f, 0xc0, 0x5c, 0xfe,
	0xc1, 0x84, 0xc7, 0xa8, 0xf2, 0x7a, 0x6c, 0xde, 0x7c, 0x25, 0x0e, 0x8d, 0xd1, 0x14, 0x41, 0xa9,
	0xd8, 0xae, 0xc9, 0x36, 0xb4, 0x54, 0xc2, 0x83, 0xe2, 0x99, 0xaa, 0xdb, 0xa6, 0x06, 0x95, 0xf0,
	0xe7, 0x0e, 0x19, 0x75, 0xa0, 0x65, 0xdc, 0xba, 0x38, 0xca, 0x7b, 0x03, 0xab, 0x85, 0x1f, 0xf2,
	0x10, 0x56, 0x75, 0xac, 0x82, 0x10, 0xa5, 0xce, 0x13, 0x5f, 0xd1, 0xb1, 0xda, 0x47, 0xa9, 0xc9,
	0x03, 0x30, 0xcb, 0xc0, 0xf4, 0xb0, 0xab, 0x42, 0x43, 0xc7, 0xea, 0x6b, 0x9c, 0x1b, 0x83, 0x14,
	0x42, 0x07, 0x21, 0x73, 0x13, 0x6f, 0x5e, 0x39, 0xa1, 0xf7, 0xd9, 0x68, 0xef, 0x8f, 0xbf, 0x3f,
	0xa8, 0xfd, 0xf4, 0xe4, 0xae, 0x97, 0x38, 0x95, 0xe2, 0x67, 0x0c, 0xb5, 0x1a, 0x9a, 0xbf, 0x1a,
	0xa6, 0x67, 0x51, 0xfe, 0x36, 0x9f, 0x34, 0xec, 0x45, 0xf6, 0xf9, 0xbf, 0x01, 0x00, 0x00, 0xff,
	0xff, 0x5a, 0x67, 0xff, 0xb0, 0x52, 0x08, 0x00, 0x00,
}
