// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proxy.proto

package v1

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import core_solo_io "github.com/solo-io/solo-kit/pkg/api/v1/resources/core"
import core_solo_io1 "github.com/solo-io/solo-kit/pkg/api/v1/resources/core"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type RedirectAction_RedirectResponseCode int32

const (
	// Moved Permanently HTTP Status Code - 301.
	RedirectAction_MOVED_PERMANENTLY RedirectAction_RedirectResponseCode = 0
	// Found HTTP Status Code - 302.
	RedirectAction_FOUND RedirectAction_RedirectResponseCode = 1
	// See Other HTTP Status Code - 303.
	RedirectAction_SEE_OTHER RedirectAction_RedirectResponseCode = 2
	// Temporary Redirect HTTP Status Code - 307.
	RedirectAction_TEMPORARY_REDIRECT RedirectAction_RedirectResponseCode = 3
	// Permanent Redirect HTTP Status Code - 308.
	RedirectAction_PERMANENT_REDIRECT RedirectAction_RedirectResponseCode = 4
)

var RedirectAction_RedirectResponseCode_name = map[int32]string{
	0: "MOVED_PERMANENTLY",
	1: "FOUND",
	2: "SEE_OTHER",
	3: "TEMPORARY_REDIRECT",
	4: "PERMANENT_REDIRECT",
}
var RedirectAction_RedirectResponseCode_value = map[string]int32{
	"MOVED_PERMANENTLY":  0,
	"FOUND":              1,
	"SEE_OTHER":          2,
	"TEMPORARY_REDIRECT": 3,
	"PERMANENT_REDIRECT": 4,
}

func (x RedirectAction_RedirectResponseCode) String() string {
	return proto.EnumName(RedirectAction_RedirectResponseCode_name, int32(x))
}
func (RedirectAction_RedirectResponseCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorProxy, []int{9, 0}
}

//
// @solo-kit:resource
// @solo-kit:resource.short_name=px
// @solo-kit:resource.plural_name=proxies
// @solo-kit:resource.group_name=gloo.solo.io
// @solo-kit:resource.version=v1
//
// A Proxy is a container for the entire set of configuration that will to be applied to one or more Proxy instances.
// Proxies can be understood as a set of listeners, represents a different bind address/port where the proxy will listen
// for connections. Each listener has its own set of configuration.
//
// If any of the subresources within a listener is declared invalid (e.g. due to invalid user configuration), the
// proxy will be marked invalid by Gloo.
//
// Proxy instances that register with Gloo are assigned the proxy configuration corresponding with
// a proxy-specific identifier.
// In the case of Envoy, proxy instances are identified by matching the following string pattern `PROXY_ID~IGNORED`
// in the instance's [Node Id](https://www.envoyproxy.io/docs/envoy/latest/operations/cli). where
// PROXY_ID is the name of the proxy the Gloo operator wishes to assign.
// Node ID can be specified in Envoy with the `--service-node` flag, or in the Envoy instance's bootstrap config.
type Proxy struct {
	// Define here each listener the proxy should create.
	// Listeners define the a set of behaviors for a single bind address/port where the proxy will listen
	// If no listeners are specified, the instances configured with the proxy resource will not accept connections.
	Listeners []*Listener `protobuf:"bytes,2,rep,name=listeners" json:"listeners,omitempty"`
	// Status indicates the validation status of this resource.
	// Status is read-only by clients, and set by gloo during validation
	Status core_solo_io1.Status `protobuf:"bytes,6,opt,name=status" json:"status" testdiff:"ignore"`
	// Metadata contains the object metadata for this resource
	Metadata core_solo_io.Metadata `protobuf:"bytes,7,opt,name=metadata" json:"metadata"`
}

func (m *Proxy) Reset()                    { *m = Proxy{} }
func (m *Proxy) String() string            { return proto.CompactTextString(m) }
func (*Proxy) ProtoMessage()               {}
func (*Proxy) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{0} }

func (m *Proxy) GetListeners() []*Listener {
	if m != nil {
		return m.Listeners
	}
	return nil
}

func (m *Proxy) GetStatus() core_solo_io1.Status {
	if m != nil {
		return m.Status
	}
	return core_solo_io1.Status{}
}

func (m *Proxy) GetMetadata() core_solo_io.Metadata {
	if m != nil {
		return m.Metadata
	}
	return core_solo_io.Metadata{}
}

// Listeners define the address:port where the proxy will listen for incoming connections
// A Listener accepts connections (currently only HTTP is supported) and apply user-defined behavior for those connections,
// e.g. performing SSL termination, HTTP retries, and rate limiting.
type Listener struct {
	// the name of the listener. names must be unique for each listener within a proxy
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// the bind address for the listener.
	// both ipv4 and ipv6 formats are supported
	BindAddress string `protobuf:"bytes,2,opt,name=bind_address,json=bindAddress,proto3" json:"bind_address,omitempty"`
	// the port to bind on
	// ports numbers must be unique for listeners within a proxy
	BindPort uint32 `protobuf:"varint,3,opt,name=bind_port,json=bindPort,proto3" json:"bind_port,omitempty"`
	// Listeners can listen for HTTP, TCP (unsupported), and UDP (unsupported) connections
	//
	// Types that are valid to be assigned to ListenerType:
	//	*Listener_HttpListener
	ListenerType isListener_ListenerType `protobuf_oneof:"ListenerType"`
	// SSL Config is optional for the listener. If provided, the listener will serve TLS for connections on this port
	// Multiple SSLConfigs are supported for the pupose of SNI. Be aware that the SNI domain provided in the SSL Config
	// must match a domain in virtual host
	// TODO(ilackarms): ensure that ssl configs without a matching virtual host are errored
	SslConfiguations []*SSLConfig `protobuf:"bytes,5,rep,name=ssl_configuations,json=sslConfiguations" json:"ssl_configuations,omitempty"`
}

func (m *Listener) Reset()                    { *m = Listener{} }
func (m *Listener) String() string            { return proto.CompactTextString(m) }
func (*Listener) ProtoMessage()               {}
func (*Listener) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{1} }

type isListener_ListenerType interface {
	isListener_ListenerType()
	Equal(interface{}) bool
}

type Listener_HttpListener struct {
	HttpListener *HttpListener `protobuf:"bytes,4,opt,name=http_listener,json=httpListener,oneof"`
}

func (*Listener_HttpListener) isListener_ListenerType() {}

func (m *Listener) GetListenerType() isListener_ListenerType {
	if m != nil {
		return m.ListenerType
	}
	return nil
}

func (m *Listener) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Listener) GetBindAddress() string {
	if m != nil {
		return m.BindAddress
	}
	return ""
}

func (m *Listener) GetBindPort() uint32 {
	if m != nil {
		return m.BindPort
	}
	return 0
}

func (m *Listener) GetHttpListener() *HttpListener {
	if x, ok := m.GetListenerType().(*Listener_HttpListener); ok {
		return x.HttpListener
	}
	return nil
}

func (m *Listener) GetSslConfiguations() []*SSLConfig {
	if m != nil {
		return m.SslConfiguations
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Listener) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Listener_OneofMarshaler, _Listener_OneofUnmarshaler, _Listener_OneofSizer, []interface{}{
		(*Listener_HttpListener)(nil),
	}
}

func _Listener_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Listener)
	// ListenerType
	switch x := m.ListenerType.(type) {
	case *Listener_HttpListener:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HttpListener); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Listener.ListenerType has unexpected type %T", x)
	}
	return nil
}

func _Listener_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Listener)
	switch tag {
	case 4: // ListenerType.http_listener
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HttpListener)
		err := b.DecodeMessage(msg)
		m.ListenerType = &Listener_HttpListener{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Listener_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Listener)
	// ListenerType
	switch x := m.ListenerType.(type) {
	case *Listener_HttpListener:
		s := proto.Size(x.HttpListener)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Use this listener to configure proxy behavior for any HTTP-level features including defining routes (via virtualservices).
// HttpListeners also contain plugin configuration that applies globally across all virtaul hosts on the listener.
// Some plugins can be configured to work both on the listener and virtual host level (such as the rate limit plugin)
type HttpListener struct {
	// the set of virtual hosts that will be accessible by clients connecting to this listener.
	// at least one virtual host must be specified for this listener to be active (else connections will be refused)
	// the set of domains for each virtual host must be unique, or the config will be considered invalid
	VirtualHosts []*VirtualHost `protobuf:"bytes,1,rep,name=virtual_hosts,json=virtualHosts" json:"virtual_hosts,omitempty"`
	// Plugins contains top-level plugin configuration to be applied to a listener
	// Listener config is applied to all HTTP traffic that
	// connects to this listener. Some configuration here can be overridden in
	// Virtual Host Plugin configuration or Route Plugin configuration
	//
	// Plugins should be specified here in the form of
	//   `"plugin_name": {..//plugin_config...}`
	// to allow specifying multiple plugins.
	ListenerPlugins map[string]*ListenerPlugin `protobuf:"bytes,2,rep,name=listener_plugins,json=listenerPlugins" json:"listener_plugins,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *HttpListener) Reset()                    { *m = HttpListener{} }
func (m *HttpListener) String() string            { return proto.CompactTextString(m) }
func (*HttpListener) ProtoMessage()               {}
func (*HttpListener) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{2} }

func (m *HttpListener) GetVirtualHosts() []*VirtualHost {
	if m != nil {
		return m.VirtualHosts
	}
	return nil
}

func (m *HttpListener) GetListenerPlugins() map[string]*ListenerPlugin {
	if m != nil {
		return m.ListenerPlugins
	}
	return nil
}

//
// Virtual Hosts group an ordered list of routes under one or more domains.
// Each Virtual Host has a logical name, which must be unique for the listener.
// An HTTP request is first matched to a virtual host based on its host header, then to a route within the virtual host.
// If a request is not matched to any virtual host or a route therein, the target proxy will reply with a 404.
type VirtualHost struct {
	// the logical name of the virtual host. names must be unique for each virtual host within a listener
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The list of domains (i.e.: matching the `Host` header of a request) that belong to this virtual host.
	// Note that the wildcard will not match the empty string. e.g. “*-bar.foo.com” will match “baz-bar.foo.com”
	// but not “-bar.foo.com”. Additionally, a special entry “*” is allowed which will match any host/authority header.
	// Only a single virtual host in the entire route configuration can match on “*”. A domain must be unique across all
	// virtual hosts or the config will be invalidated by Gloo
	// Domains on virtual hosts obey the same rules as [Envoy Virtual Hosts](https://github.com/envoyproxy/envoy/blob/master/api/envoy/api/v2/route/route.proto)
	Domains []string `protobuf:"bytes,2,rep,name=domains" json:"domains,omitempty"`
	// The list of HTTP routes define routing actions to be taken for incoming HTTP requests whose host header matches
	// this virtual host. If the request matches more than one route in the list, the first route matched will be selected.
	// If the list of routes is empty, the virtual host will be ignored by Gloo.
	Routes []*Route `protobuf:"bytes,3,rep,name=routes" json:"routes,omitempty"`
	// Plugins contains top-level plugin configuration to be applied to a listener
	// Listener config is applied to all HTTP traffic that
	// connects to this listener. Some configuration here can be overridden in
	// Virtual Host Plugin configuration or Route Plugin configuration
	//
	// Plugins should be specified here in the form of
	//   `"plugin_name": {..//plugin_config...}`
	// to allow specifying multiple plugins.
	VirtualHostPlugins map[string]*VirtualHostPlugin `protobuf:"bytes,4,rep,name=virtual_host_plugins,json=virtualHostPlugins" json:"virtual_host_plugins,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *VirtualHost) Reset()                    { *m = VirtualHost{} }
func (m *VirtualHost) String() string            { return proto.CompactTextString(m) }
func (*VirtualHost) ProtoMessage()               {}
func (*VirtualHost) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{3} }

func (m *VirtualHost) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VirtualHost) GetDomains() []string {
	if m != nil {
		return m.Domains
	}
	return nil
}

func (m *VirtualHost) GetRoutes() []*Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

func (m *VirtualHost) GetVirtualHostPlugins() map[string]*VirtualHostPlugin {
	if m != nil {
		return m.VirtualHostPlugins
	}
	return nil
}

// *
// Routes declare the entrypoints on virtual hosts and the action to take for matched requests.
type Route struct {
	// The matcher contains parameters for matching requests (i.e.: based on HTTP path, headers, etc.)
	Matcher *RouteMatcher `protobuf:"bytes,1,opt,name=matcher" json:"matcher,omitempty"`
	// The Route Action Defines what action the proxy should take when a request matches the route.
	//
	// Types that are valid to be assigned to Action:
	//	*Route_RouteAction
	//	*Route_RedirectAction
	//	*Route_DirectResponseAction
	Action isRoute_Action `protobuf_oneof:"action"`
	// Route Plugins extend the behavior of routes.
	// Route plugins include configuration such as retries,
	// rate limiting, and request/resonse transformation.
	//
	// Plugins should be specified here in the form of
	//   `"plugin_name": {..//plugin_config...}`
	// to allow specifying multiple plugins.
	RoutePlugins map[string]*RoutePlugin `protobuf:"bytes,5,rep,name=route_plugins,json=routePlugins" json:"route_plugins,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{4} }

type isRoute_Action interface {
	isRoute_Action()
	Equal(interface{}) bool
}

type Route_RouteAction struct {
	RouteAction *RouteAction `protobuf:"bytes,2,opt,name=route_action,json=routeAction,oneof"`
}
type Route_RedirectAction struct {
	RedirectAction *RedirectAction `protobuf:"bytes,3,opt,name=redirect_action,json=redirectAction,oneof"`
}
type Route_DirectResponseAction struct {
	DirectResponseAction *DirectResponseAction `protobuf:"bytes,4,opt,name=direct_response_action,json=directResponseAction,oneof"`
}

func (*Route_RouteAction) isRoute_Action()          {}
func (*Route_RedirectAction) isRoute_Action()       {}
func (*Route_DirectResponseAction) isRoute_Action() {}

func (m *Route) GetAction() isRoute_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *Route) GetMatcher() *RouteMatcher {
	if m != nil {
		return m.Matcher
	}
	return nil
}

func (m *Route) GetRouteAction() *RouteAction {
	if x, ok := m.GetAction().(*Route_RouteAction); ok {
		return x.RouteAction
	}
	return nil
}

func (m *Route) GetRedirectAction() *RedirectAction {
	if x, ok := m.GetAction().(*Route_RedirectAction); ok {
		return x.RedirectAction
	}
	return nil
}

func (m *Route) GetDirectResponseAction() *DirectResponseAction {
	if x, ok := m.GetAction().(*Route_DirectResponseAction); ok {
		return x.DirectResponseAction
	}
	return nil
}

func (m *Route) GetRoutePlugins() map[string]*RoutePlugin {
	if m != nil {
		return m.RoutePlugins
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Route) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Route_OneofMarshaler, _Route_OneofUnmarshaler, _Route_OneofSizer, []interface{}{
		(*Route_RouteAction)(nil),
		(*Route_RedirectAction)(nil),
		(*Route_DirectResponseAction)(nil),
	}
}

func _Route_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Route)
	// action
	switch x := m.Action.(type) {
	case *Route_RouteAction:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RouteAction); err != nil {
			return err
		}
	case *Route_RedirectAction:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RedirectAction); err != nil {
			return err
		}
	case *Route_DirectResponseAction:
		_ = b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DirectResponseAction); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Route.Action has unexpected type %T", x)
	}
	return nil
}

func _Route_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Route)
	switch tag {
	case 2: // action.route_action
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RouteAction)
		err := b.DecodeMessage(msg)
		m.Action = &Route_RouteAction{msg}
		return true, err
	case 3: // action.redirect_action
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RedirectAction)
		err := b.DecodeMessage(msg)
		m.Action = &Route_RedirectAction{msg}
		return true, err
	case 4: // action.direct_response_action
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DirectResponseAction)
		err := b.DecodeMessage(msg)
		m.Action = &Route_DirectResponseAction{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Route_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Route)
	// action
	switch x := m.Action.(type) {
	case *Route_RouteAction:
		s := proto.Size(x.RouteAction)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Route_RedirectAction:
		s := proto.Size(x.RedirectAction)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Route_DirectResponseAction:
		s := proto.Size(x.DirectResponseAction)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// RouteActions are used to route matched requests to upstreams.
type RouteAction struct {
	// Defines the destination upstream for routing
	// Some destinations require additional configuration for the route (e.g. AWS upstreams require a function name
	// to be specified).
	//
	// Types that are valid to be assigned to Destination:
	//	*RouteAction_Single
	//	*RouteAction_Multi
	Destination isRouteAction_Destination `protobuf_oneof:"destination"`
}

func (m *RouteAction) Reset()                    { *m = RouteAction{} }
func (m *RouteAction) String() string            { return proto.CompactTextString(m) }
func (*RouteAction) ProtoMessage()               {}
func (*RouteAction) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{5} }

type isRouteAction_Destination interface {
	isRouteAction_Destination()
	Equal(interface{}) bool
}

type RouteAction_Single struct {
	Single *Destination `protobuf:"bytes,1,opt,name=single,oneof"`
}
type RouteAction_Multi struct {
	Multi *MultiDestination `protobuf:"bytes,2,opt,name=multi,oneof"`
}

func (*RouteAction_Single) isRouteAction_Destination() {}
func (*RouteAction_Multi) isRouteAction_Destination()  {}

func (m *RouteAction) GetDestination() isRouteAction_Destination {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *RouteAction) GetSingle() *Destination {
	if x, ok := m.GetDestination().(*RouteAction_Single); ok {
		return x.Single
	}
	return nil
}

func (m *RouteAction) GetMulti() *MultiDestination {
	if x, ok := m.GetDestination().(*RouteAction_Multi); ok {
		return x.Multi
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RouteAction) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RouteAction_OneofMarshaler, _RouteAction_OneofUnmarshaler, _RouteAction_OneofSizer, []interface{}{
		(*RouteAction_Single)(nil),
		(*RouteAction_Multi)(nil),
	}
}

func _RouteAction_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RouteAction)
	// destination
	switch x := m.Destination.(type) {
	case *RouteAction_Single:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Single); err != nil {
			return err
		}
	case *RouteAction_Multi:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Multi); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RouteAction.Destination has unexpected type %T", x)
	}
	return nil
}

func _RouteAction_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RouteAction)
	switch tag {
	case 1: // destination.single
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Destination)
		err := b.DecodeMessage(msg)
		m.Destination = &RouteAction_Single{msg}
		return true, err
	case 2: // destination.multi
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(MultiDestination)
		err := b.DecodeMessage(msg)
		m.Destination = &RouteAction_Multi{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RouteAction_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RouteAction)
	// destination
	switch x := m.Destination.(type) {
	case *RouteAction_Single:
		s := proto.Size(x.Single)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RouteAction_Multi:
		s := proto.Size(x.Multi)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Destinations define routable destinations for proxied requests
type Destination struct {
	// The upstream to route requests to
	UpstreamName string `protobuf:"bytes,1,opt,name=upstream_name,json=upstreamName,proto3" json:"upstream_name,omitempty"`
	// Some upstreams utilize plugins which require or permit additional configuration on routes targeting them.
	// gRPC upstreams, for example, allow specifying REST-style parameters for JSON-to-gRPC transcoding in the
	// destination config. If the destination config is required for the upstream and not provided by the user,
	// Gloo will invalidate the destination and its parent resources.
	DestinationSpec *DestinationSpec `protobuf:"bytes,2,opt,name=destination_spec,json=destinationSpec" json:"destination_spec,omitempty"`
}

func (m *Destination) Reset()                    { *m = Destination{} }
func (m *Destination) String() string            { return proto.CompactTextString(m) }
func (*Destination) ProtoMessage()               {}
func (*Destination) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{6} }

func (m *Destination) GetUpstreamName() string {
	if m != nil {
		return m.UpstreamName
	}
	return ""
}

func (m *Destination) GetDestinationSpec() *DestinationSpec {
	if m != nil {
		return m.DestinationSpec
	}
	return nil
}

// MultiDestination is a container for a set of weighted destinations. Gloo will load balance traffic for a single
// route across multiple destinations according to their specified weights.
type MultiDestination struct {
	// This list must contain at least one destination or the listener housing this route will be invalid,
	// causing Gloo to error the parent proxy resource.
	Destinations []*WeightedDestination `protobuf:"bytes,1,rep,name=destinations" json:"destinations,omitempty"`
}

func (m *MultiDestination) Reset()                    { *m = MultiDestination{} }
func (m *MultiDestination) String() string            { return proto.CompactTextString(m) }
func (*MultiDestination) ProtoMessage()               {}
func (*MultiDestination) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{7} }

func (m *MultiDestination) GetDestinations() []*WeightedDestination {
	if m != nil {
		return m.Destinations
	}
	return nil
}

// WeightedDestination attaches a weight to a single destination.
type WeightedDestination struct {
	Destination *Destination `protobuf:"bytes,1,opt,name=destination" json:"destination,omitempty"`
	// Weight must be greater than zero
	// Routing to each destination will be balanced by the ratio of the destination's weight to the total weight on a route
	Weight uint32 `protobuf:"varint,2,opt,name=weight,proto3" json:"weight,omitempty"`
}

func (m *WeightedDestination) Reset()                    { *m = WeightedDestination{} }
func (m *WeightedDestination) String() string            { return proto.CompactTextString(m) }
func (*WeightedDestination) ProtoMessage()               {}
func (*WeightedDestination) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{8} }

func (m *WeightedDestination) GetDestination() *Destination {
	if m != nil {
		return m.Destination
	}
	return nil
}

func (m *WeightedDestination) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

// TODO(ilackarms): evaluate how much to differentiate (or if even to include) RedirectAction
// Notice: RedirectAction is copioed directly from https://github.com/envoyproxy/envoy/blob/master/api/envoy/api/v2/route/route.proto
type RedirectAction struct {
	// The host portion of the URL will be swapped with this value.
	HostRedirect string `protobuf:"bytes,1,opt,name=host_redirect,json=hostRedirect,proto3" json:"host_redirect,omitempty"`
	// Types that are valid to be assigned to PathRewriteSpecifier:
	//	*RedirectAction_PathRedirect
	//	*RedirectAction_PrefixRewrite
	PathRewriteSpecifier isRedirectAction_PathRewriteSpecifier `protobuf_oneof:"path_rewrite_specifier"`
	// The HTTP status code to use in the redirect response. The default response
	// code is MOVED_PERMANENTLY (301).
	ResponseCode RedirectAction_RedirectResponseCode `protobuf:"varint,3,opt,name=response_code,json=responseCode,proto3,enum=gloo.api.v1.RedirectAction_RedirectResponseCode" json:"response_code,omitempty"`
	// The scheme portion of the URL will be swapped with "https".
	HttpsRedirect bool `protobuf:"varint,4,opt,name=https_redirect,json=httpsRedirect,proto3" json:"https_redirect,omitempty"`
	// Indicates that during redirection, the query portion of the URL will
	// be removed. Default value is false.
	StripQuery bool `protobuf:"varint,6,opt,name=strip_query,json=stripQuery,proto3" json:"strip_query,omitempty"`
}

func (m *RedirectAction) Reset()                    { *m = RedirectAction{} }
func (m *RedirectAction) String() string            { return proto.CompactTextString(m) }
func (*RedirectAction) ProtoMessage()               {}
func (*RedirectAction) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{9} }

type isRedirectAction_PathRewriteSpecifier interface {
	isRedirectAction_PathRewriteSpecifier()
	Equal(interface{}) bool
}

type RedirectAction_PathRedirect struct {
	PathRedirect string `protobuf:"bytes,2,opt,name=path_redirect,json=pathRedirect,proto3,oneof"`
}
type RedirectAction_PrefixRewrite struct {
	PrefixRewrite string `protobuf:"bytes,5,opt,name=prefix_rewrite,json=prefixRewrite,proto3,oneof"`
}

func (*RedirectAction_PathRedirect) isRedirectAction_PathRewriteSpecifier()  {}
func (*RedirectAction_PrefixRewrite) isRedirectAction_PathRewriteSpecifier() {}

func (m *RedirectAction) GetPathRewriteSpecifier() isRedirectAction_PathRewriteSpecifier {
	if m != nil {
		return m.PathRewriteSpecifier
	}
	return nil
}

func (m *RedirectAction) GetHostRedirect() string {
	if m != nil {
		return m.HostRedirect
	}
	return ""
}

func (m *RedirectAction) GetPathRedirect() string {
	if x, ok := m.GetPathRewriteSpecifier().(*RedirectAction_PathRedirect); ok {
		return x.PathRedirect
	}
	return ""
}

func (m *RedirectAction) GetPrefixRewrite() string {
	if x, ok := m.GetPathRewriteSpecifier().(*RedirectAction_PrefixRewrite); ok {
		return x.PrefixRewrite
	}
	return ""
}

func (m *RedirectAction) GetResponseCode() RedirectAction_RedirectResponseCode {
	if m != nil {
		return m.ResponseCode
	}
	return RedirectAction_MOVED_PERMANENTLY
}

func (m *RedirectAction) GetHttpsRedirect() bool {
	if m != nil {
		return m.HttpsRedirect
	}
	return false
}

func (m *RedirectAction) GetStripQuery() bool {
	if m != nil {
		return m.StripQuery
	}
	return false
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RedirectAction) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RedirectAction_OneofMarshaler, _RedirectAction_OneofUnmarshaler, _RedirectAction_OneofSizer, []interface{}{
		(*RedirectAction_PathRedirect)(nil),
		(*RedirectAction_PrefixRewrite)(nil),
	}
}

func _RedirectAction_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RedirectAction)
	// path_rewrite_specifier
	switch x := m.PathRewriteSpecifier.(type) {
	case *RedirectAction_PathRedirect:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.PathRedirect)
	case *RedirectAction_PrefixRewrite:
		_ = b.EncodeVarint(5<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.PrefixRewrite)
	case nil:
	default:
		return fmt.Errorf("RedirectAction.PathRewriteSpecifier has unexpected type %T", x)
	}
	return nil
}

func _RedirectAction_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RedirectAction)
	switch tag {
	case 2: // path_rewrite_specifier.path_redirect
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.PathRewriteSpecifier = &RedirectAction_PathRedirect{x}
		return true, err
	case 5: // path_rewrite_specifier.prefix_rewrite
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.PathRewriteSpecifier = &RedirectAction_PrefixRewrite{x}
		return true, err
	default:
		return false, nil
	}
}

func _RedirectAction_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RedirectAction)
	// path_rewrite_specifier
	switch x := m.PathRewriteSpecifier.(type) {
	case *RedirectAction_PathRedirect:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.PathRedirect)))
		n += len(x.PathRedirect)
	case *RedirectAction_PrefixRewrite:
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.PrefixRewrite)))
		n += len(x.PrefixRewrite)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// TODO(ilackarms): evaluate how much to differentiate (or if even to include) DirectResponseAction
// DirectResponseAction is copied directly from https://github.com/envoyproxy/envoy/blob/master/api/envoy/api/v2/route/route.proto
type DirectResponseAction struct {
	// Specifies the HTTP response status to be returned.
	Status uint32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	// Specifies the content of the response body. If this setting is omitted,
	// no body is included in the generated response.
	//
	//   Note: Headers can be specified using the Header Modification plugin in the enclosing
	//   Route, Virtual Host, or Listener.
	Body string `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
}

func (m *DirectResponseAction) Reset()                    { *m = DirectResponseAction{} }
func (m *DirectResponseAction) String() string            { return proto.CompactTextString(m) }
func (*DirectResponseAction) ProtoMessage()               {}
func (*DirectResponseAction) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{10} }

func (m *DirectResponseAction) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *DirectResponseAction) GetBody() string {
	if m != nil {
		return m.Body
	}
	return ""
}

// Parameters for matching routes to requests received by a Gloo-managed proxy
type RouteMatcher struct {
	// Types that are valid to be assigned to PathSpecifier:
	//	*RouteMatcher_Prefix
	//	*RouteMatcher_Exact
	//	*RouteMatcher_Regex
	PathSpecifier isRouteMatcher_PathSpecifier `protobuf_oneof:"path_specifier"`
	// Specifies a set of headers that the route should match on. The router will
	// check the request’s headers against all the specified headers in the route
	// config. A match will happen if all the headers in the route are present in
	// the request with the same values (or based on presence if the value field
	// is not in the config).
	Headers []*HeaderMatcher `protobuf:"bytes,6,rep,name=headers" json:"headers,omitempty"`
	// Specifies a set of URL query parameters on which the route should
	// match. The router will check the query string from the *path* header
	// against all the specified query parameters. If the number of specified
	// query parameters is nonzero, they all must match the *path* header's
	// query string for a match to occur.
	QueryParameters []*QueryParameterMatcher `protobuf:"bytes,7,rep,name=query_parameters,json=queryParameters" json:"query_parameters,omitempty"`
	// HTTP Method/Verb(s) to match on. If none specified, the matcher will ignore the HTTP Method
	Methods []string `protobuf:"bytes,8,rep,name=methods" json:"methods,omitempty"`
}

func (m *RouteMatcher) Reset()                    { *m = RouteMatcher{} }
func (m *RouteMatcher) String() string            { return proto.CompactTextString(m) }
func (*RouteMatcher) ProtoMessage()               {}
func (*RouteMatcher) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{11} }

type isRouteMatcher_PathSpecifier interface {
	isRouteMatcher_PathSpecifier()
	Equal(interface{}) bool
}

type RouteMatcher_Prefix struct {
	Prefix string `protobuf:"bytes,1,opt,name=prefix,proto3,oneof"`
}
type RouteMatcher_Exact struct {
	Exact string `protobuf:"bytes,2,opt,name=exact,proto3,oneof"`
}
type RouteMatcher_Regex struct {
	Regex string `protobuf:"bytes,3,opt,name=regex,proto3,oneof"`
}

func (*RouteMatcher_Prefix) isRouteMatcher_PathSpecifier() {}
func (*RouteMatcher_Exact) isRouteMatcher_PathSpecifier()  {}
func (*RouteMatcher_Regex) isRouteMatcher_PathSpecifier()  {}

func (m *RouteMatcher) GetPathSpecifier() isRouteMatcher_PathSpecifier {
	if m != nil {
		return m.PathSpecifier
	}
	return nil
}

func (m *RouteMatcher) GetPrefix() string {
	if x, ok := m.GetPathSpecifier().(*RouteMatcher_Prefix); ok {
		return x.Prefix
	}
	return ""
}

func (m *RouteMatcher) GetExact() string {
	if x, ok := m.GetPathSpecifier().(*RouteMatcher_Exact); ok {
		return x.Exact
	}
	return ""
}

func (m *RouteMatcher) GetRegex() string {
	if x, ok := m.GetPathSpecifier().(*RouteMatcher_Regex); ok {
		return x.Regex
	}
	return ""
}

func (m *RouteMatcher) GetHeaders() []*HeaderMatcher {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *RouteMatcher) GetQueryParameters() []*QueryParameterMatcher {
	if m != nil {
		return m.QueryParameters
	}
	return nil
}

func (m *RouteMatcher) GetMethods() []string {
	if m != nil {
		return m.Methods
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RouteMatcher) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RouteMatcher_OneofMarshaler, _RouteMatcher_OneofUnmarshaler, _RouteMatcher_OneofSizer, []interface{}{
		(*RouteMatcher_Prefix)(nil),
		(*RouteMatcher_Exact)(nil),
		(*RouteMatcher_Regex)(nil),
	}
}

func _RouteMatcher_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RouteMatcher)
	// path_specifier
	switch x := m.PathSpecifier.(type) {
	case *RouteMatcher_Prefix:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Prefix)
	case *RouteMatcher_Exact:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Exact)
	case *RouteMatcher_Regex:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.Regex)
	case nil:
	default:
		return fmt.Errorf("RouteMatcher.PathSpecifier has unexpected type %T", x)
	}
	return nil
}

func _RouteMatcher_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RouteMatcher)
	switch tag {
	case 1: // path_specifier.prefix
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.PathSpecifier = &RouteMatcher_Prefix{x}
		return true, err
	case 2: // path_specifier.exact
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.PathSpecifier = &RouteMatcher_Exact{x}
		return true, err
	case 3: // path_specifier.regex
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.PathSpecifier = &RouteMatcher_Regex{x}
		return true, err
	default:
		return false, nil
	}
}

func _RouteMatcher_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RouteMatcher)
	// path_specifier
	switch x := m.PathSpecifier.(type) {
	case *RouteMatcher_Prefix:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Prefix)))
		n += len(x.Prefix)
	case *RouteMatcher_Exact:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Exact)))
		n += len(x.Exact)
	case *RouteMatcher_Regex:
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.Regex)))
		n += len(x.Regex)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

//   Internally, Gloo always uses the HTTP/2 *:authority* header to represent the HTTP/1 *Host*
//   header. Thus, if attempting to match on *Host*, match on *:authority* instead.
//
//   In the absence of any header match specifier, match will default to `present_match`
//   i.e, a request that has the `name` header will match, regardless of the header's
//   value.
type HeaderMatcher struct {
	// Specifies the name of the header in the request.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Specifies the value of the header. If the value is absent a request that
	// has the name header will match, regardless of the header’s value.
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// Specifies whether the header value should be treated as regex or not.
	Regex bool `protobuf:"varint,3,opt,name=regex,proto3" json:"regex,omitempty"`
}

func (m *HeaderMatcher) Reset()                    { *m = HeaderMatcher{} }
func (m *HeaderMatcher) String() string            { return proto.CompactTextString(m) }
func (*HeaderMatcher) ProtoMessage()               {}
func (*HeaderMatcher) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{12} }

func (m *HeaderMatcher) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HeaderMatcher) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *HeaderMatcher) GetRegex() bool {
	if m != nil {
		return m.Regex
	}
	return false
}

// Query parameter matching treats the query string of a request's :path header
// as an ampersand-separated list of keys and/or key=value elements.
type QueryParameterMatcher struct {
	// Specifies the name of a key that must be present in the requested
	// *path*'s query string.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Specifies the value of the key. If the value is absent, a request
	// that contains the key in its query string will match, whether the
	// key appears with a value (e.g., "?debug=true") or not (e.g., "?debug")
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	// Specifies whether the query parameter value is a regular expression.
	// Defaults to false. The entire query parameter value (i.e., the part to
	// the right of the equals sign in "key=value") must match the regex.
	// E.g., the regex "\d+$" will match "123" but not "a123" or "123a".
	Regex bool `protobuf:"varint,3,opt,name=regex,proto3" json:"regex,omitempty"`
}

func (m *QueryParameterMatcher) Reset()                    { *m = QueryParameterMatcher{} }
func (m *QueryParameterMatcher) String() string            { return proto.CompactTextString(m) }
func (*QueryParameterMatcher) ProtoMessage()               {}
func (*QueryParameterMatcher) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{13} }

func (m *QueryParameterMatcher) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *QueryParameterMatcher) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *QueryParameterMatcher) GetRegex() bool {
	if m != nil {
		return m.Regex
	}
	return false
}

// SSLConfig contains the options necessary to configure a virtual host or listener to use TLS
type SSLConfig struct {
	// Types that are valid to be assigned to SslSecrets:
	//	*SSLConfig_SecretRef
	//	*SSLConfig_SslFiles
	SslSecrets isSSLConfig_SslSecrets `protobuf_oneof:"ssl_secrets"`
	// optional. the SNI domains that should be considered for TLS connections
	SniDomains []string `protobuf:"bytes,3,rep,name=sni_domains,json=sniDomains" json:"sni_domains,omitempty"`
}

func (m *SSLConfig) Reset()                    { *m = SSLConfig{} }
func (m *SSLConfig) String() string            { return proto.CompactTextString(m) }
func (*SSLConfig) ProtoMessage()               {}
func (*SSLConfig) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{14} }

type isSSLConfig_SslSecrets interface {
	isSSLConfig_SslSecrets()
	Equal(interface{}) bool
}

type SSLConfig_SecretRef struct {
	SecretRef string `protobuf:"bytes,1,opt,name=secret_ref,json=secretRef,proto3,oneof"`
}
type SSLConfig_SslFiles struct {
	SslFiles *SSLFiles `protobuf:"bytes,2,opt,name=ssl_files,json=sslFiles,oneof"`
}

func (*SSLConfig_SecretRef) isSSLConfig_SslSecrets() {}
func (*SSLConfig_SslFiles) isSSLConfig_SslSecrets()  {}

func (m *SSLConfig) GetSslSecrets() isSSLConfig_SslSecrets {
	if m != nil {
		return m.SslSecrets
	}
	return nil
}

func (m *SSLConfig) GetSecretRef() string {
	if x, ok := m.GetSslSecrets().(*SSLConfig_SecretRef); ok {
		return x.SecretRef
	}
	return ""
}

func (m *SSLConfig) GetSslFiles() *SSLFiles {
	if x, ok := m.GetSslSecrets().(*SSLConfig_SslFiles); ok {
		return x.SslFiles
	}
	return nil
}

func (m *SSLConfig) GetSniDomains() []string {
	if m != nil {
		return m.SniDomains
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SSLConfig) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SSLConfig_OneofMarshaler, _SSLConfig_OneofUnmarshaler, _SSLConfig_OneofSizer, []interface{}{
		(*SSLConfig_SecretRef)(nil),
		(*SSLConfig_SslFiles)(nil),
	}
}

func _SSLConfig_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SSLConfig)
	// ssl_secrets
	switch x := m.SslSecrets.(type) {
	case *SSLConfig_SecretRef:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.SecretRef)
	case *SSLConfig_SslFiles:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SslFiles); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SSLConfig.SslSecrets has unexpected type %T", x)
	}
	return nil
}

func _SSLConfig_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SSLConfig)
	switch tag {
	case 1: // ssl_secrets.secret_ref
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.SslSecrets = &SSLConfig_SecretRef{x}
		return true, err
	case 2: // ssl_secrets.ssl_files
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SSLFiles)
		err := b.DecodeMessage(msg)
		m.SslSecrets = &SSLConfig_SslFiles{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SSLConfig_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SSLConfig)
	// ssl_secrets
	switch x := m.SslSecrets.(type) {
	case *SSLConfig_SecretRef:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.SecretRef)))
		n += len(x.SecretRef)
	case *SSLConfig_SslFiles:
		s := proto.Size(x.SslFiles)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// SSLFiles reference paths to certificates which can be read by the proxy off of its local filesystem
type SSLFiles struct {
	TlsCert string `protobuf:"bytes,1,opt,name=tls_cert,json=tlsCert,proto3" json:"tls_cert,omitempty"`
	TlsKey  string `protobuf:"bytes,2,opt,name=tls_key,json=tlsKey,proto3" json:"tls_key,omitempty"`
	// for client cert validation. optional
	RootCa string `protobuf:"bytes,3,opt,name=root_ca,json=rootCa,proto3" json:"root_ca,omitempty"`
}

func (m *SSLFiles) Reset()                    { *m = SSLFiles{} }
func (m *SSLFiles) String() string            { return proto.CompactTextString(m) }
func (*SSLFiles) ProtoMessage()               {}
func (*SSLFiles) Descriptor() ([]byte, []int) { return fileDescriptorProxy, []int{15} }

func (m *SSLFiles) GetTlsCert() string {
	if m != nil {
		return m.TlsCert
	}
	return ""
}

func (m *SSLFiles) GetTlsKey() string {
	if m != nil {
		return m.TlsKey
	}
	return ""
}

func (m *SSLFiles) GetRootCa() string {
	if m != nil {
		return m.RootCa
	}
	return ""
}

func init() {
	proto.RegisterType((*Proxy)(nil), "gloo.api.v1.Proxy")
	proto.RegisterType((*Listener)(nil), "gloo.api.v1.Listener")
	proto.RegisterType((*HttpListener)(nil), "gloo.api.v1.HttpListener")
	proto.RegisterType((*VirtualHost)(nil), "gloo.api.v1.VirtualHost")
	proto.RegisterType((*Route)(nil), "gloo.api.v1.Route")
	proto.RegisterType((*RouteAction)(nil), "gloo.api.v1.RouteAction")
	proto.RegisterType((*Destination)(nil), "gloo.api.v1.Destination")
	proto.RegisterType((*MultiDestination)(nil), "gloo.api.v1.MultiDestination")
	proto.RegisterType((*WeightedDestination)(nil), "gloo.api.v1.WeightedDestination")
	proto.RegisterType((*RedirectAction)(nil), "gloo.api.v1.RedirectAction")
	proto.RegisterType((*DirectResponseAction)(nil), "gloo.api.v1.DirectResponseAction")
	proto.RegisterType((*RouteMatcher)(nil), "gloo.api.v1.RouteMatcher")
	proto.RegisterType((*HeaderMatcher)(nil), "gloo.api.v1.HeaderMatcher")
	proto.RegisterType((*QueryParameterMatcher)(nil), "gloo.api.v1.QueryParameterMatcher")
	proto.RegisterType((*SSLConfig)(nil), "gloo.api.v1.SSLConfig")
	proto.RegisterType((*SSLFiles)(nil), "gloo.api.v1.SSLFiles")
	proto.RegisterEnum("gloo.api.v1.RedirectAction_RedirectResponseCode", RedirectAction_RedirectResponseCode_name, RedirectAction_RedirectResponseCode_value)
}
func (this *Proxy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Proxy)
	if !ok {
		that2, ok := that.(Proxy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Listeners) != len(that1.Listeners) {
		return false
	}
	for i := range this.Listeners {
		if !this.Listeners[i].Equal(that1.Listeners[i]) {
			return false
		}
	}
	if !this.Status.Equal(&that1.Status) {
		return false
	}
	if !this.Metadata.Equal(&that1.Metadata) {
		return false
	}
	return true
}
func (this *Listener) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Listener)
	if !ok {
		that2, ok := that.(Listener)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.BindAddress != that1.BindAddress {
		return false
	}
	if this.BindPort != that1.BindPort {
		return false
	}
	if that1.ListenerType == nil {
		if this.ListenerType != nil {
			return false
		}
	} else if this.ListenerType == nil {
		return false
	} else if !this.ListenerType.Equal(that1.ListenerType) {
		return false
	}
	if len(this.SslConfiguations) != len(that1.SslConfiguations) {
		return false
	}
	for i := range this.SslConfiguations {
		if !this.SslConfiguations[i].Equal(that1.SslConfiguations[i]) {
			return false
		}
	}
	return true
}
func (this *Listener_HttpListener) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Listener_HttpListener)
	if !ok {
		that2, ok := that.(Listener_HttpListener)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.HttpListener.Equal(that1.HttpListener) {
		return false
	}
	return true
}
func (this *HttpListener) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HttpListener)
	if !ok {
		that2, ok := that.(HttpListener)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.VirtualHosts) != len(that1.VirtualHosts) {
		return false
	}
	for i := range this.VirtualHosts {
		if !this.VirtualHosts[i].Equal(that1.VirtualHosts[i]) {
			return false
		}
	}
	if len(this.ListenerPlugins) != len(that1.ListenerPlugins) {
		return false
	}
	for i := range this.ListenerPlugins {
		if !this.ListenerPlugins[i].Equal(that1.ListenerPlugins[i]) {
			return false
		}
	}
	return true
}
func (this *VirtualHost) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*VirtualHost)
	if !ok {
		that2, ok := that.(VirtualHost)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if len(this.Domains) != len(that1.Domains) {
		return false
	}
	for i := range this.Domains {
		if this.Domains[i] != that1.Domains[i] {
			return false
		}
	}
	if len(this.Routes) != len(that1.Routes) {
		return false
	}
	for i := range this.Routes {
		if !this.Routes[i].Equal(that1.Routes[i]) {
			return false
		}
	}
	if len(this.VirtualHostPlugins) != len(that1.VirtualHostPlugins) {
		return false
	}
	for i := range this.VirtualHostPlugins {
		if !this.VirtualHostPlugins[i].Equal(that1.VirtualHostPlugins[i]) {
			return false
		}
	}
	return true
}
func (this *Route) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Route)
	if !ok {
		that2, ok := that.(Route)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Matcher.Equal(that1.Matcher) {
		return false
	}
	if that1.Action == nil {
		if this.Action != nil {
			return false
		}
	} else if this.Action == nil {
		return false
	} else if !this.Action.Equal(that1.Action) {
		return false
	}
	if len(this.RoutePlugins) != len(that1.RoutePlugins) {
		return false
	}
	for i := range this.RoutePlugins {
		if !this.RoutePlugins[i].Equal(that1.RoutePlugins[i]) {
			return false
		}
	}
	return true
}
func (this *Route_RouteAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Route_RouteAction)
	if !ok {
		that2, ok := that.(Route_RouteAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RouteAction.Equal(that1.RouteAction) {
		return false
	}
	return true
}
func (this *Route_RedirectAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Route_RedirectAction)
	if !ok {
		that2, ok := that.(Route_RedirectAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.RedirectAction.Equal(that1.RedirectAction) {
		return false
	}
	return true
}
func (this *Route_DirectResponseAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Route_DirectResponseAction)
	if !ok {
		that2, ok := that.(Route_DirectResponseAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.DirectResponseAction.Equal(that1.DirectResponseAction) {
		return false
	}
	return true
}
func (this *RouteAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteAction)
	if !ok {
		that2, ok := that.(RouteAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Destination == nil {
		if this.Destination != nil {
			return false
		}
	} else if this.Destination == nil {
		return false
	} else if !this.Destination.Equal(that1.Destination) {
		return false
	}
	return true
}
func (this *RouteAction_Single) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteAction_Single)
	if !ok {
		that2, ok := that.(RouteAction_Single)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Single.Equal(that1.Single) {
		return false
	}
	return true
}
func (this *RouteAction_Multi) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteAction_Multi)
	if !ok {
		that2, ok := that.(RouteAction_Multi)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Multi.Equal(that1.Multi) {
		return false
	}
	return true
}
func (this *Destination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Destination)
	if !ok {
		that2, ok := that.(Destination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UpstreamName != that1.UpstreamName {
		return false
	}
	if !this.DestinationSpec.Equal(that1.DestinationSpec) {
		return false
	}
	return true
}
func (this *MultiDestination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MultiDestination)
	if !ok {
		that2, ok := that.(MultiDestination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Destinations) != len(that1.Destinations) {
		return false
	}
	for i := range this.Destinations {
		if !this.Destinations[i].Equal(that1.Destinations[i]) {
			return false
		}
	}
	return true
}
func (this *WeightedDestination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*WeightedDestination)
	if !ok {
		that2, ok := that.(WeightedDestination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Destination.Equal(that1.Destination) {
		return false
	}
	if this.Weight != that1.Weight {
		return false
	}
	return true
}
func (this *RedirectAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RedirectAction)
	if !ok {
		that2, ok := that.(RedirectAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HostRedirect != that1.HostRedirect {
		return false
	}
	if that1.PathRewriteSpecifier == nil {
		if this.PathRewriteSpecifier != nil {
			return false
		}
	} else if this.PathRewriteSpecifier == nil {
		return false
	} else if !this.PathRewriteSpecifier.Equal(that1.PathRewriteSpecifier) {
		return false
	}
	if this.ResponseCode != that1.ResponseCode {
		return false
	}
	if this.HttpsRedirect != that1.HttpsRedirect {
		return false
	}
	if this.StripQuery != that1.StripQuery {
		return false
	}
	return true
}
func (this *RedirectAction_PathRedirect) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RedirectAction_PathRedirect)
	if !ok {
		that2, ok := that.(RedirectAction_PathRedirect)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PathRedirect != that1.PathRedirect {
		return false
	}
	return true
}
func (this *RedirectAction_PrefixRewrite) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RedirectAction_PrefixRewrite)
	if !ok {
		that2, ok := that.(RedirectAction_PrefixRewrite)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PrefixRewrite != that1.PrefixRewrite {
		return false
	}
	return true
}
func (this *DirectResponseAction) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DirectResponseAction)
	if !ok {
		that2, ok := that.(DirectResponseAction)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Body != that1.Body {
		return false
	}
	return true
}
func (this *RouteMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteMatcher)
	if !ok {
		that2, ok := that.(RouteMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.PathSpecifier == nil {
		if this.PathSpecifier != nil {
			return false
		}
	} else if this.PathSpecifier == nil {
		return false
	} else if !this.PathSpecifier.Equal(that1.PathSpecifier) {
		return false
	}
	if len(this.Headers) != len(that1.Headers) {
		return false
	}
	for i := range this.Headers {
		if !this.Headers[i].Equal(that1.Headers[i]) {
			return false
		}
	}
	if len(this.QueryParameters) != len(that1.QueryParameters) {
		return false
	}
	for i := range this.QueryParameters {
		if !this.QueryParameters[i].Equal(that1.QueryParameters[i]) {
			return false
		}
	}
	if len(this.Methods) != len(that1.Methods) {
		return false
	}
	for i := range this.Methods {
		if this.Methods[i] != that1.Methods[i] {
			return false
		}
	}
	return true
}
func (this *RouteMatcher_Prefix) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteMatcher_Prefix)
	if !ok {
		that2, ok := that.(RouteMatcher_Prefix)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Prefix != that1.Prefix {
		return false
	}
	return true
}
func (this *RouteMatcher_Exact) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteMatcher_Exact)
	if !ok {
		that2, ok := that.(RouteMatcher_Exact)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Exact != that1.Exact {
		return false
	}
	return true
}
func (this *RouteMatcher_Regex) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RouteMatcher_Regex)
	if !ok {
		that2, ok := that.(RouteMatcher_Regex)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Regex != that1.Regex {
		return false
	}
	return true
}
func (this *HeaderMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HeaderMatcher)
	if !ok {
		that2, ok := that.(HeaderMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Regex != that1.Regex {
		return false
	}
	return true
}
func (this *QueryParameterMatcher) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*QueryParameterMatcher)
	if !ok {
		that2, ok := that.(QueryParameterMatcher)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	if this.Regex != that1.Regex {
		return false
	}
	return true
}
func (this *SSLConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SSLConfig)
	if !ok {
		that2, ok := that.(SSLConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.SslSecrets == nil {
		if this.SslSecrets != nil {
			return false
		}
	} else if this.SslSecrets == nil {
		return false
	} else if !this.SslSecrets.Equal(that1.SslSecrets) {
		return false
	}
	if len(this.SniDomains) != len(that1.SniDomains) {
		return false
	}
	for i := range this.SniDomains {
		if this.SniDomains[i] != that1.SniDomains[i] {
			return false
		}
	}
	return true
}
func (this *SSLConfig_SecretRef) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SSLConfig_SecretRef)
	if !ok {
		that2, ok := that.(SSLConfig_SecretRef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SecretRef != that1.SecretRef {
		return false
	}
	return true
}
func (this *SSLConfig_SslFiles) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SSLConfig_SslFiles)
	if !ok {
		that2, ok := that.(SSLConfig_SslFiles)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SslFiles.Equal(that1.SslFiles) {
		return false
	}
	return true
}
func (this *SSLFiles) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SSLFiles)
	if !ok {
		that2, ok := that.(SSLFiles)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TlsCert != that1.TlsCert {
		return false
	}
	if this.TlsKey != that1.TlsKey {
		return false
	}
	if this.RootCa != that1.RootCa {
		return false
	}
	return true
}

func init() { proto.RegisterFile("proxy.proto", fileDescriptorProxy) }

var fileDescriptorProxy = []byte{
	// 1401 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x57, 0xcd, 0x6e, 0x1b, 0xb7,
	0x16, 0xb6, 0x2c, 0x4b, 0x96, 0x8e, 0x24, 0x5b, 0xe6, 0x95, 0x9d, 0x89, 0x73, 0x6f, 0xec, 0xcc,
	0x6d, 0x50, 0xa3, 0x40, 0xa5, 0xda, 0x71, 0x81, 0xc0, 0x40, 0x80, 0x5a, 0xb6, 0x12, 0x07, 0x8d,
	0x7f, 0x4a, 0x3b, 0x49, 0xdd, 0xcd, 0x60, 0xac, 0xa1, 0x24, 0x36, 0x23, 0x71, 0x42, 0x52, 0x8e,
	0x85, 0x3e, 0x40, 0xd1, 0x6d, 0x9f, 0xa2, 0xeb, 0x6e, 0xba, 0xec, 0xb6, 0xab, 0x3e, 0x42, 0x16,
	0x7d, 0x84, 0x02, 0xdd, 0x17, 0xfc, 0x19, 0x69, 0xc6, 0x96, 0xdb, 0x02, 0xdd, 0xd8, 0xc3, 0x8f,
	0xdf, 0x39, 0x3c, 0xe7, 0x3b, 0x3c, 0x24, 0x05, 0xa5, 0x88, 0xb3, 0xab, 0x51, 0x3d, 0xe2, 0x4c,
	0x32, 0x54, 0xea, 0x86, 0x8c, 0xd5, 0xfd, 0x88, 0xd6, 0x2f, 0x37, 0x57, 0x6b, 0x5d, 0xd6, 0x65,
	0x1a, 0x6f, 0xa8, 0x2f, 0x43, 0x59, 0xdd, 0xec, 0x52, 0xd9, 0x1b, 0x5e, 0xd4, 0xdb, 0xac, 0xdf,
	0x10, 0x2c, 0x64, 0x1f, 0x53, 0x66, 0xfe, 0xbf, 0xa1, 0xb2, 0xe1, 0x47, 0xb4, 0x71, 0xb9, 0xd9,
	0xe8, 0x13, 0xe9, 0x07, 0xbe, 0xf4, 0xad, 0x49, 0xe3, 0x1f, 0x98, 0x08, 0xe9, 0xcb, 0xa1, 0xb0,
	0x06, 0x95, 0x28, 0x1c, 0x76, 0xe9, 0xc0, 0x0e, 0xdd, 0x9f, 0x33, 0x90, 0x3b, 0x51, 0x51, 0xa2,
	0x47, 0x50, 0x0c, 0xa9, 0x90, 0x64, 0x40, 0xb8, 0x70, 0x66, 0xd7, 0xb3, 0x1b, 0xa5, 0xad, 0xe5,
	0x7a, 0x22, 0xe6, 0xfa, 0x0b, 0x3b, 0x8b, 0x27, 0x3c, 0xf4, 0x0c, 0xf2, 0xc6, 0xbb, 0x93, 0x5f,
	0xcf, 0x6c, 0x94, 0xb6, 0x6a, 0xf5, 0x36, 0xe3, 0xa4, 0xae, 0x22, 0xa8, 0x53, 0x56, 0x3f, 0xd5,
	0x73, 0xcd, 0xbb, 0xbf, 0xbc, 0x5f, 0x9b, 0xf9, 0xfd, 0xfd, 0xda, 0x92, 0x24, 0x42, 0x06, 0xb4,
	0xd3, 0xd9, 0x71, 0x69, 0x77, 0xc0, 0x38, 0x71, 0xb1, 0x35, 0x47, 0x8f, 0xa1, 0x10, 0x67, 0xe6,
	0xcc, 0x6b, 0x57, 0x2b, 0x69, 0x57, 0x87, 0x76, 0xb6, 0x39, 0xa7, 0x9c, 0xe1, 0x31, 0xdb, 0xfd,
	0x23, 0x03, 0x85, 0x38, 0x34, 0x84, 0x60, 0x6e, 0xe0, 0xf7, 0x89, 0x93, 0x59, 0xcf, 0x6c, 0x14,
	0xb1, 0xfe, 0x46, 0x0f, 0xa0, 0x7c, 0x41, 0x07, 0x81, 0xe7, 0x07, 0x01, 0x27, 0x42, 0xe5, 0xa6,
	0xe6, 0x4a, 0x0a, 0xdb, 0x35, 0x10, 0xba, 0x07, 0x45, 0x4d, 0x89, 0x18, 0x97, 0x4e, 0x76, 0x3d,
	0xb3, 0x51, 0xc1, 0x05, 0x05, 0x9c, 0x30, 0x2e, 0xd1, 0x67, 0x50, 0xe9, 0x49, 0x19, 0x79, 0x71,
	0xd6, 0xce, 0x9c, 0x8e, 0xef, 0x6e, 0x4a, 0x9c, 0x03, 0x29, 0xa3, 0x38, 0x8a, 0x83, 0x19, 0x5c,
	0xee, 0x25, 0xc6, 0x68, 0x0f, 0x96, 0x84, 0x08, 0xbd, 0x36, 0x1b, 0x74, 0x68, 0x77, 0xe8, 0x4b,
	0xca, 0x06, 0xc2, 0xc9, 0x69, 0x89, 0x57, 0x52, 0x5e, 0x4e, 0x4f, 0x5f, 0xec, 0x69, 0x12, 0xae,
	0x0a, 0x11, 0xee, 0x25, 0xf9, 0xcd, 0x05, 0x28, 0xc7, 0x0e, 0xcf, 0x46, 0x11, 0x71, 0xbf, 0x9b,
	0x85, 0x72, 0x72, 0x55, 0xf4, 0x04, 0x2a, 0x97, 0x94, 0xcb, 0xa1, 0x1f, 0x7a, 0x3d, 0x26, 0xa4,
	0x70, 0x32, 0x7a, 0x05, 0x27, 0xb5, 0xc2, 0x2b, 0xc3, 0x38, 0x60, 0x42, 0xe2, 0xf2, 0xe5, 0x64,
	0x20, 0xd0, 0x39, 0x54, 0xe3, 0x0c, 0x3d, 0xbb, 0x47, 0xec, 0x36, 0xa8, 0xdf, 0x9a, 0xe9, 0x78,
	0x4f, 0x9c, 0x18, 0x83, 0xd6, 0x40, 0xf2, 0x11, 0x5e, 0x0c, 0xd3, 0xe8, 0xaa, 0x07, 0xb5, 0x69,
	0x44, 0x54, 0x85, 0xec, 0x1b, 0x32, 0xb2, 0xc5, 0x52, 0x9f, 0x68, 0x13, 0x72, 0x97, 0x7e, 0x38,
	0x24, 0xba, 0x48, 0xa5, 0xad, 0x7b, 0x53, 0x37, 0xa0, 0xf1, 0x81, 0x0d, 0x73, 0x67, 0xf6, 0x71,
	0xc6, 0xfd, 0x71, 0x16, 0x4a, 0x89, 0xcc, 0xa6, 0x6e, 0x03, 0x07, 0xe6, 0x03, 0xd6, 0xf7, 0xe3,
	0xb4, 0x8a, 0x38, 0x1e, 0xa2, 0x8f, 0x20, 0xcf, 0xd9, 0x50, 0x12, 0xe1, 0x64, 0x75, 0xbe, 0x28,
	0xb5, 0x2a, 0x56, 0x53, 0xd8, 0x32, 0xd0, 0x05, 0xd4, 0x92, 0x22, 0x8f, 0x95, 0x9a, 0xd3, 0x96,
	0x9f, 0xdc, 0xa6, 0x75, 0xf2, 0x3b, 0xa5, 0x15, 0xba, 0xbc, 0x31, 0xb1, 0x4a, 0xe0, 0xce, 0x2d,
	0xf4, 0x29, 0x8a, 0x6d, 0xa7, 0x15, 0xbb, 0x7f, 0x5b, 0x04, 0x37, 0x45, 0xfb, 0x35, 0x0b, 0x39,
	0x9d, 0x1c, 0x7a, 0x04, 0xf3, 0x7d, 0x5f, 0xb6, 0x7b, 0x84, 0x6b, 0xcf, 0xd7, 0xf7, 0xb6, 0x26,
	0x1d, 0x1a, 0x02, 0x8e, 0x99, 0xe8, 0x09, 0x94, 0xb5, 0x26, 0x9e, 0xdf, 0x56, 0x1b, 0xd4, 0xae,
	0xef, 0xdc, 0xb4, 0xdc, 0xd5, 0xf3, 0x07, 0x33, 0xb8, 0xc4, 0x27, 0x43, 0xf4, 0x14, 0x16, 0x39,
	0x09, 0x28, 0x27, 0x6d, 0x19, 0x7b, 0xc8, 0x4e, 0xa9, 0x39, 0xb6, 0x9c, 0xb1, 0x93, 0x05, 0x9e,
	0x42, 0xd0, 0x39, 0xac, 0x58, 0x2f, 0x9c, 0x88, 0x88, 0x0d, 0xc4, 0x38, 0x20, 0xd3, 0xa6, 0x0f,
	0x52, 0xee, 0xf6, 0x35, 0x15, 0x5b, 0xe6, 0xd8, 0x69, 0x2d, 0x98, 0x82, 0xa3, 0xe7, 0x50, 0x31,
	0x19, 0xc6, 0x45, 0x36, 0x2d, 0xfb, 0xc1, 0xcd, 0x14, 0xcd, 0xdf, 0x54, 0x61, 0x8d, 0x38, 0x71,
	0x49, 0xcf, 0x61, 0xe9, 0x06, 0x65, 0x4a, 0x31, 0xeb, 0xe9, 0x62, 0x4e, 0x11, 0xf3, 0x46, 0x19,
	0x9b, 0x05, 0xc8, 0x9b, 0x84, 0xdd, 0x6f, 0x33, 0x50, 0x4a, 0x28, 0x8e, 0xb6, 0x20, 0x2f, 0xe8,
	0xa0, 0x1b, 0x12, 0x5b, 0xd5, 0xb4, 0xbb, 0x7d, 0x22, 0x24, 0x1d, 0xf8, 0x56, 0x01, 0xcb, 0x44,
	0x9f, 0x42, 0xae, 0x3f, 0x0c, 0x25, 0xb5, 0x11, 0xfc, 0x2f, 0x65, 0x72, 0xa8, 0x66, 0xd2, 0x76,
	0x86, 0xdd, 0xac, 0x40, 0x29, 0x98, 0xe0, 0xee, 0x37, 0x50, 0x4a, 0xd0, 0xd0, 0xff, 0xa1, 0x32,
	0x8c, 0x84, 0xe4, 0xc4, 0xef, 0x7b, 0x89, 0xbe, 0x2c, 0xc7, 0xe0, 0x91, 0xea, 0xcf, 0x67, 0x50,
	0x4d, 0xb8, 0xf0, 0x44, 0x44, 0xda, 0x36, 0x88, 0xff, 0xde, 0x16, 0xf7, 0x69, 0x44, 0xda, 0x78,
	0x31, 0x48, 0x03, 0xee, 0x97, 0x50, 0xbd, 0x1e, 0x28, 0xda, 0x87, 0x72, 0x82, 0x16, 0x1f, 0x8d,
	0xeb, 0x29, 0xc7, 0xaf, 0x09, 0xed, 0xf6, 0x24, 0x09, 0x12, 0x76, 0x38, 0x65, 0xe5, 0x52, 0xf8,
	0xcf, 0x14, 0x12, 0xda, 0x49, 0x25, 0xff, 0x77, 0x62, 0xe3, 0x24, 0x19, 0xad, 0x40, 0xfe, 0x9d,
	0x76, 0xa9, 0x73, 0xad, 0x60, 0x3b, 0x72, 0x7f, 0xca, 0xc2, 0x42, 0x7a, 0xef, 0x2b, 0x15, 0xf5,
	0x91, 0x13, 0x37, 0x40, 0xac, 0xa2, 0x02, 0x63, 0x2a, 0x7a, 0x08, 0x95, 0xc8, 0x97, 0xbd, 0x09,
	0x49, 0xdf, 0x76, 0xea, 0x46, 0x52, 0xf0, 0x98, 0xf6, 0x21, 0x2c, 0x44, 0x9c, 0x74, 0xe8, 0x95,
	0xc7, 0xc9, 0x3b, 0x4e, 0x25, 0x71, 0x72, 0x96, 0x57, 0x31, 0x38, 0x36, 0x30, 0x7a, 0x09, 0x95,
	0x71, 0x5f, 0xb5, 0x59, 0x40, 0x74, 0x93, 0x2e, 0x5c, 0x3b, 0xe8, 0xd2, 0x81, 0x8e, 0x87, 0x71,
	0x3b, 0xed, 0xb1, 0x80, 0xe0, 0x32, 0x4f, 0x8c, 0xd0, 0x43, 0x58, 0x50, 0x37, 0xa4, 0x98, 0xc4,
	0xa9, 0xba, 0xb5, 0x80, 0xf5, 0x4d, 0x2b, 0xc6, 0x61, 0xae, 0x41, 0x49, 0x48, 0x4e, 0x23, 0xef,
	0xed, 0x90, 0xf0, 0x91, 0x7e, 0x63, 0x14, 0x30, 0x68, 0xe8, 0x0b, 0x85, 0xb8, 0xef, 0xa0, 0x36,
	0x6d, 0x35, 0xb4, 0x0c, 0x4b, 0x87, 0xc7, 0xaf, 0x5a, 0xfb, 0xde, 0x49, 0x0b, 0x1f, 0xee, 0x1e,
	0xb5, 0x8e, 0xce, 0x5e, 0x9c, 0x57, 0x67, 0x50, 0x11, 0x72, 0x4f, 0x8f, 0x5f, 0x1e, 0xed, 0x57,
	0x33, 0xa8, 0x02, 0xc5, 0xd3, 0x56, 0xcb, 0x3b, 0x3e, 0x3b, 0x68, 0xe1, 0xea, 0x2c, 0x5a, 0x01,
	0x74, 0xd6, 0x3a, 0x3c, 0x39, 0xc6, 0xbb, 0xf8, 0xdc, 0xc3, 0xad, 0xfd, 0xe7, 0xb8, 0xb5, 0x77,
	0x56, 0xcd, 0x2a, 0x7c, 0xec, 0x62, 0x82, 0xcf, 0x35, 0x1d, 0x58, 0xb1, 0x3a, 0x6b, 0x9d, 0xf4,
	0x76, 0xa5, 0x1d, 0x4a, 0xb8, 0xdb, 0x84, 0xda, 0xb4, 0x53, 0x46, 0x55, 0xda, 0x3e, 0x95, 0x32,
	0xa6, 0xd2, 0xf6, 0xe5, 0x83, 0x60, 0xee, 0x82, 0x05, 0x23, 0xfb, 0x2c, 0xd1, 0xdf, 0xfa, 0x6e,
	0x4f, 0x9e, 0xba, 0xc8, 0x81, 0xbc, 0xa9, 0x8b, 0x29, 0xba, 0x6a, 0x58, 0x33, 0x46, 0x2b, 0x90,
	0x23, 0x57, 0x7e, 0xa2, 0xd0, 0x66, 0xa8, 0x70, 0x4e, 0xba, 0xe4, 0x4a, 0x17, 0x4c, 0xe3, 0x7a,
	0x88, 0xb6, 0x61, 0xbe, 0x47, 0xfc, 0x40, 0x3d, 0xf2, 0xf2, 0xba, 0x09, 0x56, 0xd3, 0xb7, 0xbb,
	0x9e, 0x1b, 0x1f, 0xf6, 0x96, 0x8a, 0x0e, 0xa1, 0xaa, 0x4b, 0xe0, 0x45, 0x3e, 0xf7, 0xfb, 0x44,
	0x2a, 0xf3, 0x79, 0x6d, 0xee, 0xa6, 0xcc, 0x75, 0x55, 0x4e, 0x62, 0x4e, 0xec, 0x66, 0xf1, 0x6d,
	0x0a, 0x16, 0xea, 0x2e, 0xee, 0x13, 0xd9, 0x63, 0x81, 0x70, 0x0a, 0xe6, 0x2e, 0xb6, 0xc3, 0x66,
	0x15, 0x16, 0xb4, 0xae, 0x13, 0x3d, 0x8f, 0xa1, 0x92, 0x0a, 0x6a, 0xea, 0xe5, 0x5e, 0x4b, 0x1e,
	0x9c, 0x45, 0x7b, 0x3c, 0x2a, 0x74, 0xa2, 0x41, 0xc1, 0x2a, 0xe0, 0xbe, 0x86, 0xe5, 0xa9, 0x61,
	0xfe, 0x6b, 0xc7, 0xdf, 0x67, 0xa0, 0x38, 0x7e, 0xc1, 0xa1, 0x35, 0x00, 0x41, 0xda, 0x9c, 0xa8,
	0x86, 0xed, 0x8c, 0xcb, 0x56, 0x34, 0x18, 0x26, 0x1d, 0xb4, 0x0d, 0x45, 0xf5, 0x2a, 0xec, 0xd0,
	0x90, 0x08, 0x7b, 0xd2, 0x2d, 0x5f, 0x7f, 0x0d, 0x3e, 0x55, 0x93, 0x07, 0x33, 0xb8, 0x20, 0x44,
	0xa8, 0xbf, 0x75, 0x4b, 0x0c, 0xa8, 0x17, 0x3f, 0x65, 0xb2, 0x5a, 0x3e, 0x10, 0x03, 0xba, 0x6f,
	0x10, 0x75, 0x14, 0x2b, 0xb7, 0x66, 0x1d, 0xe1, 0xbe, 0x86, 0x42, 0xec, 0x07, 0xdd, 0x85, 0x82,
	0x0c, 0x85, 0xd7, 0x26, 0x3c, 0x3e, 0x3c, 0xe6, 0x65, 0x28, 0xf6, 0x08, 0x97, 0xe8, 0x0e, 0xa8,
	0x4f, 0x4f, 0xdd, 0x47, 0x26, 0xd3, 0xbc, 0x0c, 0xc5, 0xe7, 0x64, 0xa4, 0x26, 0x38, 0x63, 0xd2,
	0x6b, 0xfb, 0x66, 0x27, 0xa9, 0x97, 0x10, 0x93, 0x7b, 0x7e, 0x73, 0xe7, 0x87, 0xdf, 0xee, 0x67,
	0xbe, 0xda, 0xfe, 0xab, 0xdf, 0x1f, 0x11, 0x67, 0x5f, 0x93, 0xb6, 0x14, 0x0d, 0x95, 0x55, 0x23,
	0x7a, 0xd3, 0xb5, 0xbf, 0x48, 0x2e, 0xf2, 0xfa, 0xc7, 0xc7, 0xa3, 0x3f, 0x03, 0x00, 0x00, 0xff,
	0xff, 0xb7, 0x9e, 0xf1, 0x6e, 0x21, 0x0d, 0x00, 0x00,
}
