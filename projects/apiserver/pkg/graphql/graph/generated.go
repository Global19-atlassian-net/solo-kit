// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	context "context"
	fmt "fmt"
	strconv "strconv"

	graphql "github.com/99designs/gqlgen/graphql"
	introspection "github.com/99designs/gqlgen/graphql/introspection"
	customtypes "github.com/solo-io/solo-kit/projects/apiserver/pkg/graphql/customtypes"
	models "github.com/solo-io/solo-kit/projects/apiserver/pkg/graphql/models"
	gqlparser "github.com/vektah/gqlparser"
	ast "github.com/vektah/gqlparser/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
}

type ResolverRoot interface {
	ArtifactMutation() ArtifactMutationResolver
	ArtifactQuery() ArtifactQueryResolver
	Mutation() MutationResolver
	Query() QueryResolver
	ResolverMapMutation() ResolverMapMutationResolver
	ResolverMapQuery() ResolverMapQueryResolver
	SchemaMutation() SchemaMutationResolver
	SchemaQuery() SchemaQueryResolver
	SecretMutation() SecretMutationResolver
	SecretQuery() SecretQueryResolver
	UpstreamMutation() UpstreamMutationResolver
	UpstreamQuery() UpstreamQueryResolver
	VirtualServiceMutation() VirtualServiceMutationResolver
	VirtualServiceQuery() VirtualServiceQueryResolver
}

type DirectiveRoot struct {
}
type ArtifactMutationResolver interface {
	Create(ctx context.Context, obj *customtypes.ArtifactMutation, artifact models.InputArtifact) (*models.Artifact, error)
	Update(ctx context.Context, obj *customtypes.ArtifactMutation, artifact models.InputArtifact) (*models.Artifact, error)
	Delete(ctx context.Context, obj *customtypes.ArtifactMutation, name string) (*models.Artifact, error)
}
type ArtifactQueryResolver interface {
	List(ctx context.Context, obj *customtypes.ArtifactQuery, selector *models.InputMapStringString) ([]*models.Artifact, error)
	Get(ctx context.Context, obj *customtypes.ArtifactQuery, name string) (*models.Artifact, error)
}
type MutationResolver interface {
	Upstreams(ctx context.Context, namespace string) (customtypes.UpstreamMutation, error)
	VirtualServices(ctx context.Context, namespace string) (customtypes.VirtualServiceMutation, error)
	ResolverMaps(ctx context.Context, namespace string) (customtypes.ResolverMapMutation, error)
	Schemas(ctx context.Context, namespace string) (customtypes.SchemaMutation, error)
	Secrets(ctx context.Context, namespace string) (customtypes.SecretMutation, error)
	Artifacts(ctx context.Context, namespace string) (customtypes.ArtifactMutation, error)
}
type QueryResolver interface {
	GetOAuthEndpoint(ctx context.Context) (models.OAuthEndpoint, error)
	Upstreams(ctx context.Context, namespace string) (customtypes.UpstreamQuery, error)
	VirtualServices(ctx context.Context, namespace string) (customtypes.VirtualServiceQuery, error)
	ResolverMaps(ctx context.Context, namespace string) (customtypes.ResolverMapQuery, error)
	Schemas(ctx context.Context, namespace string) (customtypes.SchemaQuery, error)
	Secrets(ctx context.Context, namespace string) (customtypes.SecretQuery, error)
	Artifacts(ctx context.Context, namespace string) (customtypes.ArtifactQuery, error)
}
type ResolverMapMutationResolver interface {
	Create(ctx context.Context, obj *customtypes.ResolverMapMutation, resolverMap models.InputResolverMap) (*models.ResolverMap, error)
	Update(ctx context.Context, obj *customtypes.ResolverMapMutation, resolverMap models.InputResolverMap) (*models.ResolverMap, error)
	Delete(ctx context.Context, obj *customtypes.ResolverMapMutation, name string) (*models.ResolverMap, error)
	SetResolver(ctx context.Context, obj *customtypes.ResolverMapMutation, resolverMapName string, resourceVersion string, typeName string, fieldName string, glooResolver models.InputGlooResolver) (*models.ResolverMap, error)
}
type ResolverMapQueryResolver interface {
	List(ctx context.Context, obj *customtypes.ResolverMapQuery, selector *models.InputMapStringString) ([]*models.ResolverMap, error)
	Get(ctx context.Context, obj *customtypes.ResolverMapQuery, name string) (*models.ResolverMap, error)
}
type SchemaMutationResolver interface {
	Create(ctx context.Context, obj *customtypes.SchemaMutation, schema models.InputSchema) (*models.Schema, error)
	Update(ctx context.Context, obj *customtypes.SchemaMutation, schema models.InputSchema) (*models.Schema, error)
	Delete(ctx context.Context, obj *customtypes.SchemaMutation, name string) (*models.Schema, error)
}
type SchemaQueryResolver interface {
	List(ctx context.Context, obj *customtypes.SchemaQuery, selector *models.InputMapStringString) ([]*models.Schema, error)
	Get(ctx context.Context, obj *customtypes.SchemaQuery, name string) (*models.Schema, error)
}
type SecretMutationResolver interface {
	Create(ctx context.Context, obj *customtypes.SecretMutation, secret models.InputSecret) (*models.Secret, error)
	Update(ctx context.Context, obj *customtypes.SecretMutation, secret models.InputSecret) (*models.Secret, error)
	Delete(ctx context.Context, obj *customtypes.SecretMutation, name string) (*models.Secret, error)
}
type SecretQueryResolver interface {
	List(ctx context.Context, obj *customtypes.SecretQuery, selector *models.InputMapStringString) ([]*models.Secret, error)
	Get(ctx context.Context, obj *customtypes.SecretQuery, name string) (*models.Secret, error)
}
type UpstreamMutationResolver interface {
	Create(ctx context.Context, obj *customtypes.UpstreamMutation, upstream models.InputUpstream) (*models.Upstream, error)
	Update(ctx context.Context, obj *customtypes.UpstreamMutation, upstream models.InputUpstream) (*models.Upstream, error)
	Delete(ctx context.Context, obj *customtypes.UpstreamMutation, name string) (*models.Upstream, error)
}
type UpstreamQueryResolver interface {
	List(ctx context.Context, obj *customtypes.UpstreamQuery, selector *models.InputMapStringString) ([]*models.Upstream, error)
	Get(ctx context.Context, obj *customtypes.UpstreamQuery, name string) (*models.Upstream, error)
}
type VirtualServiceMutationResolver interface {
	Create(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualService models.InputVirtualService) (*models.VirtualService, error)
	Update(ctx context.Context, obj *customtypes.VirtualServiceMutation, name string, resourceVersion string, virtualService models.InputUpdateVirtualService) (*models.VirtualService, error)
	Delete(ctx context.Context, obj *customtypes.VirtualServiceMutation, name string) (*models.VirtualService, error)
	AddRoute(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualServiceName string, resourceVersion string, index int, route models.InputRoute) (*models.VirtualService, error)
	UpdateRoute(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualServiceName string, resourceVersion string, index int, route models.InputRoute) (*models.VirtualService, error)
	DeleteRoute(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualServiceName string, resourceVersion string, index int) (*models.VirtualService, error)
	SwapRoutes(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualServiceName string, resourceVersion string, index1 int, index2 int) (*models.VirtualService, error)
	ShiftRoutes(ctx context.Context, obj *customtypes.VirtualServiceMutation, virtualServiceName string, resourceVersion string, fromIndex int, toIndex int) (*models.VirtualService, error)
}
type VirtualServiceQueryResolver interface {
	List(ctx context.Context, obj *customtypes.VirtualServiceQuery, selector *models.InputMapStringString) ([]*models.VirtualService, error)
	Get(ctx context.Context, obj *customtypes.VirtualServiceQuery, name string) (*models.VirtualService, error)
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Query(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Query(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:   buf,
		Errors: ec.Errors,
	}
}

func (e *executableSchema) Mutation(ctx context.Context, op *ast.OperationDefinition) *graphql.Response {
	ec := executionContext{graphql.GetRequestContext(ctx), e}

	buf := ec.RequestMiddleware(ctx, func(ctx context.Context) []byte {
		data := ec._Mutation(ctx, op.SelectionSet)
		var buf bytes.Buffer
		data.MarshalGQL(&buf)
		return buf.Bytes()
	})

	return &graphql.Response{
		Data:   buf,
		Errors: ec.Errors,
	}
}

func (e *executableSchema) Subscription(ctx context.Context, op *ast.OperationDefinition) func() *graphql.Response {
	return graphql.OneShot(graphql.ErrorResponse(ctx, "subscriptions are not supported"))
}

type executionContext struct {
	*graphql.RequestContext
	*executableSchema
}

var artifactImplementors = []string{"Artifact"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Artifact(ctx context.Context, sel ast.SelectionSet, obj *models.Artifact) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, artifactImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Artifact")
		case "data":
			out.Values[i] = ec._Artifact_data(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._Artifact_metadata(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Artifact_data(ctx context.Context, field graphql.CollectedField, obj *models.Artifact) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Artifact"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Data, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Artifact_metadata(ctx context.Context, field graphql.CollectedField, obj *models.Artifact) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Artifact"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Metadata, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.Metadata)
	return ec._Metadata(ctx, field.Selections, &res)
}

var artifactMutationImplementors = []string{"ArtifactMutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ArtifactMutation(ctx context.Context, sel ast.SelectionSet, obj *customtypes.ArtifactMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, artifactMutationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArtifactMutation")
		case "create":
			out.Values[i] = ec._ArtifactMutation_create(ctx, field, obj)
		case "update":
			out.Values[i] = ec._ArtifactMutation_update(ctx, field, obj)
		case "delete":
			out.Values[i] = ec._ArtifactMutation_delete(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _ArtifactMutation_create(ctx context.Context, field graphql.CollectedField, obj *customtypes.ArtifactMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 models.InputArtifact
	if tmp, ok := rawArgs["artifact"]; ok {
		var err error
		arg0, err = UnmarshalInputArtifact(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["artifact"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "ArtifactMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.ArtifactMutation().Create(ctx, obj, args["artifact"].(models.InputArtifact))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.Artifact)
		if res == nil {
			return graphql.Null
		}
		return ec._Artifact(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _ArtifactMutation_update(ctx context.Context, field graphql.CollectedField, obj *customtypes.ArtifactMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 models.InputArtifact
	if tmp, ok := rawArgs["artifact"]; ok {
		var err error
		arg0, err = UnmarshalInputArtifact(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["artifact"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "ArtifactMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.ArtifactMutation().Update(ctx, obj, args["artifact"].(models.InputArtifact))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.Artifact)
		if res == nil {
			return graphql.Null
		}
		return ec._Artifact(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _ArtifactMutation_delete(ctx context.Context, field graphql.CollectedField, obj *customtypes.ArtifactMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "ArtifactMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.ArtifactMutation().Delete(ctx, obj, args["name"].(string))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.Artifact)
		if res == nil {
			return graphql.Null
		}
		return ec._Artifact(ctx, field.Selections, res)
	})
}

var artifactQueryImplementors = []string{"ArtifactQuery"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ArtifactQuery(ctx context.Context, sel ast.SelectionSet, obj *customtypes.ArtifactQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, artifactQueryImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ArtifactQuery")
		case "list":
			out.Values[i] = ec._ArtifactQuery_list(ctx, field, obj)
		case "get":
			out.Values[i] = ec._ArtifactQuery_get(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _ArtifactQuery_list(ctx context.Context, field graphql.CollectedField, obj *customtypes.ArtifactQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 *models.InputMapStringString
	if tmp, ok := rawArgs["selector"]; ok {
		var err error
		var ptr1 models.InputMapStringString
		if tmp != nil {
			ptr1, err = UnmarshalInputMapStringString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["selector"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "ArtifactQuery",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.ArtifactQuery().List(ctx, obj, args["selector"].(*models.InputMapStringString))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.([]*models.Artifact)
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler {
				rctx := graphql.GetResolverContext(ctx)
				rctx.PushIndex(idx1)
				defer rctx.Pop()
				if res[idx1] == nil {
					return graphql.Null
				}
				return ec._Artifact(ctx, field.Selections, res[idx1])
			}())
		}
		return arr1
	})
}

func (ec *executionContext) _ArtifactQuery_get(ctx context.Context, field graphql.CollectedField, obj *customtypes.ArtifactQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "ArtifactQuery",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.ArtifactQuery().Get(ctx, obj, args["name"].(string))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.Artifact)
		if res == nil {
			return graphql.Null
		}
		return ec._Artifact(ctx, field.Selections, res)
	})
}

var awsDestinationSpecImplementors = []string{"AwsDestinationSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AwsDestinationSpec(ctx context.Context, sel ast.SelectionSet, obj *models.AwsDestinationSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, awsDestinationSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AwsDestinationSpec")
		case "logicalName":
			out.Values[i] = ec._AwsDestinationSpec_logicalName(ctx, field, obj)
		case "invocationStyle":
			out.Values[i] = ec._AwsDestinationSpec_invocationStyle(ctx, field, obj)
		case "responseTransformation":
			out.Values[i] = ec._AwsDestinationSpec_responseTransformation(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _AwsDestinationSpec_logicalName(ctx context.Context, field graphql.CollectedField, obj *models.AwsDestinationSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AwsDestinationSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.LogicalName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _AwsDestinationSpec_invocationStyle(ctx context.Context, field graphql.CollectedField, obj *models.AwsDestinationSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AwsDestinationSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.InvocationStyle, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.AwsLambdaInvocationStyle)
	return res
}

func (ec *executionContext) _AwsDestinationSpec_responseTransformation(ctx context.Context, field graphql.CollectedField, obj *models.AwsDestinationSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AwsDestinationSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.ResponseTransformation, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	return graphql.MarshalBoolean(res)
}

var awsLambdaFunctionImplementors = []string{"AwsLambdaFunction"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AwsLambdaFunction(ctx context.Context, sel ast.SelectionSet, obj *models.AwsLambdaFunction) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, awsLambdaFunctionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AwsLambdaFunction")
		case "logicalName":
			out.Values[i] = ec._AwsLambdaFunction_logicalName(ctx, field, obj)
		case "functionName":
			out.Values[i] = ec._AwsLambdaFunction_functionName(ctx, field, obj)
		case "qualifier":
			out.Values[i] = ec._AwsLambdaFunction_qualifier(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _AwsLambdaFunction_logicalName(ctx context.Context, field graphql.CollectedField, obj *models.AwsLambdaFunction) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AwsLambdaFunction"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.LogicalName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _AwsLambdaFunction_functionName(ctx context.Context, field graphql.CollectedField, obj *models.AwsLambdaFunction) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AwsLambdaFunction"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.FunctionName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _AwsLambdaFunction_qualifier(ctx context.Context, field graphql.CollectedField, obj *models.AwsLambdaFunction) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AwsLambdaFunction"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Qualifier, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

var awsSecretImplementors = []string{"AwsSecret"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AwsSecret(ctx context.Context, sel ast.SelectionSet, obj *models.AwsSecret) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, awsSecretImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AwsSecret")
		case "accessKey":
			out.Values[i] = ec._AwsSecret_accessKey(ctx, field, obj)
		case "secretKey":
			out.Values[i] = ec._AwsSecret_secretKey(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _AwsSecret_accessKey(ctx context.Context, field graphql.CollectedField, obj *models.AwsSecret) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AwsSecret"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.AccessKey, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _AwsSecret_secretKey(ctx context.Context, field graphql.CollectedField, obj *models.AwsSecret) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AwsSecret"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.SecretKey, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

var awsUpstreamSpecImplementors = []string{"AwsUpstreamSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AwsUpstreamSpec(ctx context.Context, sel ast.SelectionSet, obj *models.AwsUpstreamSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, awsUpstreamSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AwsUpstreamSpec")
		case "region":
			out.Values[i] = ec._AwsUpstreamSpec_region(ctx, field, obj)
		case "secretRef":
			out.Values[i] = ec._AwsUpstreamSpec_secretRef(ctx, field, obj)
		case "functions":
			out.Values[i] = ec._AwsUpstreamSpec_functions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _AwsUpstreamSpec_region(ctx context.Context, field graphql.CollectedField, obj *models.AwsUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AwsUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Region, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _AwsUpstreamSpec_secretRef(ctx context.Context, field graphql.CollectedField, obj *models.AwsUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AwsUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.SecretRef, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.ResourceRef)
	return ec._ResourceRef(ctx, field.Selections, &res)
}

func (ec *executionContext) _AwsUpstreamSpec_functions(ctx context.Context, field graphql.CollectedField, obj *models.AwsUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AwsUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Functions, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.AwsLambdaFunction)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._AwsLambdaFunction(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var azureDestinationSpecImplementors = []string{"AzureDestinationSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AzureDestinationSpec(ctx context.Context, sel ast.SelectionSet, obj *models.AzureDestinationSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, azureDestinationSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AzureDestinationSpec")
		case "functionName":
			out.Values[i] = ec._AzureDestinationSpec_functionName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _AzureDestinationSpec_functionName(ctx context.Context, field graphql.CollectedField, obj *models.AzureDestinationSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AzureDestinationSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.FunctionName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

var azureFunctionImplementors = []string{"AzureFunction"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AzureFunction(ctx context.Context, sel ast.SelectionSet, obj *models.AzureFunction) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, azureFunctionImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AzureFunction")
		case "functionName":
			out.Values[i] = ec._AzureFunction_functionName(ctx, field, obj)
		case "authLevel":
			out.Values[i] = ec._AzureFunction_authLevel(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _AzureFunction_functionName(ctx context.Context, field graphql.CollectedField, obj *models.AzureFunction) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AzureFunction"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.FunctionName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _AzureFunction_authLevel(ctx context.Context, field graphql.CollectedField, obj *models.AzureFunction) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AzureFunction"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.AuthLevel, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.AzureFnAuthLevel)
	return res
}

var azureSecretImplementors = []string{"AzureSecret"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AzureSecret(ctx context.Context, sel ast.SelectionSet, obj *models.AzureSecret) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, azureSecretImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AzureSecret")
		case "apiKeys":
			out.Values[i] = ec._AzureSecret_apiKeys(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _AzureSecret_apiKeys(ctx context.Context, field graphql.CollectedField, obj *models.AzureSecret) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AzureSecret"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.APIKeys, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MapStringString)
	if res == nil {
		return graphql.Null
	}
	return ec._MapStringString(ctx, field.Selections, res)
}

var azureUpstreamSpecImplementors = []string{"AzureUpstreamSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _AzureUpstreamSpec(ctx context.Context, sel ast.SelectionSet, obj *models.AzureUpstreamSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, azureUpstreamSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("AzureUpstreamSpec")
		case "functionAppName":
			out.Values[i] = ec._AzureUpstreamSpec_functionAppName(ctx, field, obj)
		case "secretRef":
			out.Values[i] = ec._AzureUpstreamSpec_secretRef(ctx, field, obj)
		case "functions":
			out.Values[i] = ec._AzureUpstreamSpec_functions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _AzureUpstreamSpec_functionAppName(ctx context.Context, field graphql.CollectedField, obj *models.AzureUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AzureUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.FunctionAppName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _AzureUpstreamSpec_secretRef(ctx context.Context, field graphql.CollectedField, obj *models.AzureUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AzureUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.SecretRef, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.ResourceRef)
	return ec._ResourceRef(ctx, field.Selections, &res)
}

func (ec *executionContext) _AzureUpstreamSpec_functions(ctx context.Context, field graphql.CollectedField, obj *models.AzureUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "AzureUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Functions, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.AzureFunction)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._AzureFunction(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var fieldResolverImplementors = []string{"FieldResolver"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _FieldResolver(ctx context.Context, sel ast.SelectionSet, obj *models.FieldResolver) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, fieldResolverImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("FieldResolver")
		case "fieldName":
			out.Values[i] = ec._FieldResolver_fieldName(ctx, field, obj)
		case "resolver":
			out.Values[i] = ec._FieldResolver_resolver(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _FieldResolver_fieldName(ctx context.Context, field graphql.CollectedField, obj *models.FieldResolver) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "FieldResolver"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.FieldName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _FieldResolver_resolver(ctx context.Context, field graphql.CollectedField, obj *models.FieldResolver) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "FieldResolver"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Resolver, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.Resolver)
	return ec._Resolver(ctx, field.Selections, &res)
}

var gRPCServiceSpecImplementors = []string{"GRPCServiceSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _GRPCServiceSpec(ctx context.Context, sel ast.SelectionSet, obj *models.GRPCServiceSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, gRPCServiceSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GRPCServiceSpec")
		case "empty":
			out.Values[i] = ec._GRPCServiceSpec_empty(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _GRPCServiceSpec_empty(ctx context.Context, field graphql.CollectedField, obj *models.GRPCServiceSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "GRPCServiceSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Empty, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var glooResolverImplementors = []string{"GlooResolver"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _GlooResolver(ctx context.Context, sel ast.SelectionSet, obj *models.GlooResolver) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, glooResolverImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("GlooResolver")
		case "requestTemplate":
			out.Values[i] = ec._GlooResolver_requestTemplate(ctx, field, obj)
		case "responseTemplate":
			out.Values[i] = ec._GlooResolver_responseTemplate(ctx, field, obj)
		case "destination":
			out.Values[i] = ec._GlooResolver_destination(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _GlooResolver_requestTemplate(ctx context.Context, field graphql.CollectedField, obj *models.GlooResolver) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "GlooResolver"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.RequestTemplate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.RequestTemplate)
	if res == nil {
		return graphql.Null
	}
	return ec._RequestTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) _GlooResolver_responseTemplate(ctx context.Context, field graphql.CollectedField, obj *models.GlooResolver) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "GlooResolver"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.ResponseTemplate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.ResponseTemplate)
	if res == nil {
		return graphql.Null
	}
	return ec._ResponseTemplate(ctx, field.Selections, res)
}

func (ec *executionContext) _GlooResolver_destination(ctx context.Context, field graphql.CollectedField, obj *models.GlooResolver) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "GlooResolver"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Destination, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.Destination)
	return ec._Destination(ctx, field.Selections, &res)
}

var keyValueMatcherImplementors = []string{"KeyValueMatcher"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _KeyValueMatcher(ctx context.Context, sel ast.SelectionSet, obj *models.KeyValueMatcher) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, keyValueMatcherImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KeyValueMatcher")
		case "name":
			out.Values[i] = ec._KeyValueMatcher_name(ctx, field, obj)
		case "value":
			out.Values[i] = ec._KeyValueMatcher_value(ctx, field, obj)
		case "isRegex":
			out.Values[i] = ec._KeyValueMatcher_isRegex(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _KeyValueMatcher_name(ctx context.Context, field graphql.CollectedField, obj *models.KeyValueMatcher) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "KeyValueMatcher"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _KeyValueMatcher_value(ctx context.Context, field graphql.CollectedField, obj *models.KeyValueMatcher) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "KeyValueMatcher"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Value, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _KeyValueMatcher_isRegex(ctx context.Context, field graphql.CollectedField, obj *models.KeyValueMatcher) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "KeyValueMatcher"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.IsRegex, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	return graphql.MarshalBoolean(res)
}

var kubeUpstreamSpecImplementors = []string{"KubeUpstreamSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _KubeUpstreamSpec(ctx context.Context, sel ast.SelectionSet, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, kubeUpstreamSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("KubeUpstreamSpec")
		case "serviceName":
			out.Values[i] = ec._KubeUpstreamSpec_serviceName(ctx, field, obj)
		case "serviceNamespace":
			out.Values[i] = ec._KubeUpstreamSpec_serviceNamespace(ctx, field, obj)
		case "servicePort":
			out.Values[i] = ec._KubeUpstreamSpec_servicePort(ctx, field, obj)
		case "selector":
			out.Values[i] = ec._KubeUpstreamSpec_selector(ctx, field, obj)
		case "serviceSpec":
			out.Values[i] = ec._KubeUpstreamSpec_serviceSpec(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _KubeUpstreamSpec_serviceName(ctx context.Context, field graphql.CollectedField, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "KubeUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.ServiceName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _KubeUpstreamSpec_serviceNamespace(ctx context.Context, field graphql.CollectedField, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "KubeUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.ServiceNamespace, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _KubeUpstreamSpec_servicePort(ctx context.Context, field graphql.CollectedField, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "KubeUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.ServicePort, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	return graphql.MarshalInt(res)
}

func (ec *executionContext) _KubeUpstreamSpec_selector(ctx context.Context, field graphql.CollectedField, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "KubeUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Selector, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MapStringString)
	if res == nil {
		return graphql.Null
	}
	return ec._MapStringString(ctx, field.Selections, res)
}

func (ec *executionContext) _KubeUpstreamSpec_serviceSpec(ctx context.Context, field graphql.CollectedField, obj *models.KubeUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "KubeUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.ServiceSpec, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.ServiceSpec)
	return ec._ServiceSpec(ctx, field.Selections, &res)
}

var mapStringStringImplementors = []string{"MapStringString"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _MapStringString(ctx context.Context, sel ast.SelectionSet, obj *models.MapStringString) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, mapStringStringImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MapStringString")
		case "values":
			out.Values[i] = ec._MapStringString_values(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _MapStringString_values(ctx context.Context, field graphql.CollectedField, obj *models.MapStringString) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "MapStringString"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Values, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.Value)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._Value(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var matcherImplementors = []string{"Matcher"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Matcher(ctx context.Context, sel ast.SelectionSet, obj *models.Matcher) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, matcherImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Matcher")
		case "pathMatch":
			out.Values[i] = ec._Matcher_pathMatch(ctx, field, obj)
		case "pathMatchType":
			out.Values[i] = ec._Matcher_pathMatchType(ctx, field, obj)
		case "headers":
			out.Values[i] = ec._Matcher_headers(ctx, field, obj)
		case "queryParameters":
			out.Values[i] = ec._Matcher_queryParameters(ctx, field, obj)
		case "methods":
			out.Values[i] = ec._Matcher_methods(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Matcher_pathMatch(ctx context.Context, field graphql.CollectedField, obj *models.Matcher) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Matcher"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.PathMatch, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Matcher_pathMatchType(ctx context.Context, field graphql.CollectedField, obj *models.Matcher) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Matcher"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.PathMatchType, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.PathMatchType)
	return res
}

func (ec *executionContext) _Matcher_headers(ctx context.Context, field graphql.CollectedField, obj *models.Matcher) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Matcher"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Headers, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.KeyValueMatcher)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._KeyValueMatcher(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _Matcher_queryParameters(ctx context.Context, field graphql.CollectedField, obj *models.Matcher) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Matcher"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.QueryParameters, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.KeyValueMatcher)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._KeyValueMatcher(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _Matcher_methods(ctx context.Context, field graphql.CollectedField, obj *models.Matcher) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Matcher"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Methods, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return graphql.MarshalString(res[idx1])
		}())
	}
	return arr1
}

var metadataImplementors = []string{"Metadata"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Metadata(ctx context.Context, sel ast.SelectionSet, obj *models.Metadata) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, metadataImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Metadata")
		case "name":
			out.Values[i] = ec._Metadata_name(ctx, field, obj)
		case "namespace":
			out.Values[i] = ec._Metadata_namespace(ctx, field, obj)
		case "resourceVersion":
			out.Values[i] = ec._Metadata_resourceVersion(ctx, field, obj)
		case "labels":
			out.Values[i] = ec._Metadata_labels(ctx, field, obj)
		case "annotations":
			out.Values[i] = ec._Metadata_annotations(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Metadata_name(ctx context.Context, field graphql.CollectedField, obj *models.Metadata) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Metadata"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Metadata_namespace(ctx context.Context, field graphql.CollectedField, obj *models.Metadata) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Metadata"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Namespace, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Metadata_resourceVersion(ctx context.Context, field graphql.CollectedField, obj *models.Metadata) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Metadata"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.ResourceVersion, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Metadata_labels(ctx context.Context, field graphql.CollectedField, obj *models.Metadata) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Metadata"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Labels, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MapStringString)
	if res == nil {
		return graphql.Null
	}
	return ec._MapStringString(ctx, field.Selections, res)
}

func (ec *executionContext) _Metadata_annotations(ctx context.Context, field graphql.CollectedField, obj *models.Metadata) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Metadata"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Annotations, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MapStringString)
	if res == nil {
		return graphql.Null
	}
	return ec._MapStringString(ctx, field.Selections, res)
}

var multiDestinationImplementors = []string{"MultiDestination"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _MultiDestination(ctx context.Context, sel ast.SelectionSet, obj *models.MultiDestination) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, multiDestinationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("MultiDestination")
		case "destinations":
			out.Values[i] = ec._MultiDestination_destinations(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _MultiDestination_destinations(ctx context.Context, field graphql.CollectedField, obj *models.MultiDestination) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "MultiDestination"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Destinations, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.WeightedDestination)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._WeightedDestination(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var mutationImplementors = []string{"Mutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Mutation(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, mutationImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Mutation",
	})

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Mutation")
		case "upstreams":
			out.Values[i] = ec._Mutation_upstreams(ctx, field)
		case "virtualServices":
			out.Values[i] = ec._Mutation_virtualServices(ctx, field)
		case "resolverMaps":
			out.Values[i] = ec._Mutation_resolverMaps(ctx, field)
		case "schemas":
			out.Values[i] = ec._Mutation_schemas(ctx, field)
		case "secrets":
			out.Values[i] = ec._Mutation_secrets(ctx, field)
		case "artifacts":
			out.Values[i] = ec._Mutation_artifacts(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Mutation_upstreams(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["namespace"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation().Upstreams(ctx, args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(customtypes.UpstreamMutation)
	return ec._UpstreamMutation(ctx, field.Selections, &res)
}

func (ec *executionContext) _Mutation_virtualServices(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["namespace"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation().VirtualServices(ctx, args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(customtypes.VirtualServiceMutation)
	return ec._VirtualServiceMutation(ctx, field.Selections, &res)
}

func (ec *executionContext) _Mutation_resolverMaps(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["namespace"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation().ResolverMaps(ctx, args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(customtypes.ResolverMapMutation)
	return ec._ResolverMapMutation(ctx, field.Selections, &res)
}

func (ec *executionContext) _Mutation_schemas(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["namespace"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation().Schemas(ctx, args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(customtypes.SchemaMutation)
	return ec._SchemaMutation(ctx, field.Selections, &res)
}

func (ec *executionContext) _Mutation_secrets(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["namespace"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation().Secrets(ctx, args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(customtypes.SecretMutation)
	return ec._SecretMutation(ctx, field.Selections, &res)
}

func (ec *executionContext) _Mutation_artifacts(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["namespace"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Mutation"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.resolvers.Mutation().Artifacts(ctx, args["namespace"].(string))
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(customtypes.ArtifactMutation)
	return ec._ArtifactMutation(ctx, field.Selections, &res)
}

var nodeJSResolverImplementors = []string{"NodeJSResolver"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _NodeJSResolver(ctx context.Context, sel ast.SelectionSet, obj *models.NodeJSResolver) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, nodeJSResolverImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("NodeJSResolver")
		case "empty":
			out.Values[i] = ec._NodeJSResolver_empty(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _NodeJSResolver_empty(ctx context.Context, field graphql.CollectedField, obj *models.NodeJSResolver) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "NodeJSResolver"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Empty, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var oAuthEndpointImplementors = []string{"OAuthEndpoint"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _OAuthEndpoint(ctx context.Context, sel ast.SelectionSet, obj *models.OAuthEndpoint) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, oAuthEndpointImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("OAuthEndpoint")
		case "url":
			out.Values[i] = ec._OAuthEndpoint_url(ctx, field, obj)
		case "clientName":
			out.Values[i] = ec._OAuthEndpoint_clientName(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _OAuthEndpoint_url(ctx context.Context, field graphql.CollectedField, obj *models.OAuthEndpoint) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "OAuthEndpoint"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.URL, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _OAuthEndpoint_clientName(ctx context.Context, field graphql.CollectedField, obj *models.OAuthEndpoint) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "OAuthEndpoint"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.ClientName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

var queryImplementors = []string{"Query"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Query(ctx context.Context, sel ast.SelectionSet) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, queryImplementors)

	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
	})

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Query")
		case "getOAuthEndpoint":
			out.Values[i] = ec._Query_getOAuthEndpoint(ctx, field)
		case "upstreams":
			out.Values[i] = ec._Query_upstreams(ctx, field)
		case "virtualServices":
			out.Values[i] = ec._Query_virtualServices(ctx, field)
		case "resolverMaps":
			out.Values[i] = ec._Query_resolverMaps(ctx, field)
		case "schemas":
			out.Values[i] = ec._Query_schemas(ctx, field)
		case "secrets":
			out.Values[i] = ec._Query_secrets(ctx, field)
		case "artifacts":
			out.Values[i] = ec._Query_artifacts(ctx, field)
		case "__type":
			out.Values[i] = ec._Query___type(ctx, field)
		case "__schema":
			out.Values[i] = ec._Query___schema(ctx, field)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Query_getOAuthEndpoint(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   nil,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query().GetOAuthEndpoint(ctx)
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(models.OAuthEndpoint)
		return ec._OAuthEndpoint(ctx, field.Selections, &res)
	})
}

func (ec *executionContext) _Query_upstreams(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["namespace"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query().Upstreams(ctx, args["namespace"].(string))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(customtypes.UpstreamQuery)
		return ec._UpstreamQuery(ctx, field.Selections, &res)
	})
}

func (ec *executionContext) _Query_virtualServices(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["namespace"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query().VirtualServices(ctx, args["namespace"].(string))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(customtypes.VirtualServiceQuery)
		return ec._VirtualServiceQuery(ctx, field.Selections, &res)
	})
}

func (ec *executionContext) _Query_resolverMaps(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["namespace"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query().ResolverMaps(ctx, args["namespace"].(string))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(customtypes.ResolverMapQuery)
		return ec._ResolverMapQuery(ctx, field.Selections, &res)
	})
}

func (ec *executionContext) _Query_schemas(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["namespace"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query().Schemas(ctx, args["namespace"].(string))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(customtypes.SchemaQuery)
		return ec._SchemaQuery(ctx, field.Selections, &res)
	})
}

func (ec *executionContext) _Query_secrets(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["namespace"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query().Secrets(ctx, args["namespace"].(string))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(customtypes.SecretQuery)
		return ec._SecretQuery(ctx, field.Selections, &res)
	})
}

func (ec *executionContext) _Query_artifacts(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["namespace"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["namespace"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "Query",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.Query().Artifacts(ctx, args["namespace"].(string))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(customtypes.ArtifactQuery)
		return ec._ArtifactQuery(ctx, field.Selections, &res)
	})
}

func (ec *executionContext) _Query___type(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Query"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.introspectType(args["name"].(string)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) _Query___schema(ctx context.Context, field graphql.CollectedField) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Query"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return ec.introspectSchema(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Schema)
	if res == nil {
		return graphql.Null
	}
	return ec.___Schema(ctx, field.Selections, res)
}

var requestTemplateImplementors = []string{"RequestTemplate"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _RequestTemplate(ctx context.Context, sel ast.SelectionSet, obj *models.RequestTemplate) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, requestTemplateImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RequestTemplate")
		case "verb":
			out.Values[i] = ec._RequestTemplate_verb(ctx, field, obj)
		case "path":
			out.Values[i] = ec._RequestTemplate_path(ctx, field, obj)
		case "body":
			out.Values[i] = ec._RequestTemplate_body(ctx, field, obj)
		case "headers":
			out.Values[i] = ec._RequestTemplate_headers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _RequestTemplate_verb(ctx context.Context, field graphql.CollectedField, obj *models.RequestTemplate) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "RequestTemplate"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Verb, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _RequestTemplate_path(ctx context.Context, field graphql.CollectedField, obj *models.RequestTemplate) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "RequestTemplate"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Path, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _RequestTemplate_body(ctx context.Context, field graphql.CollectedField, obj *models.RequestTemplate) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "RequestTemplate"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Body, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _RequestTemplate_headers(ctx context.Context, field graphql.CollectedField, obj *models.RequestTemplate) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "RequestTemplate"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Headers, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MapStringString)
	if res == nil {
		return graphql.Null
	}
	return ec._MapStringString(ctx, field.Selections, res)
}

var resolverMapImplementors = []string{"ResolverMap"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResolverMap(ctx context.Context, sel ast.SelectionSet, obj *models.ResolverMap) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resolverMapImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResolverMap")
		case "types":
			out.Values[i] = ec._ResolverMap_types(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._ResolverMap_metadata(ctx, field, obj)
		case "status":
			out.Values[i] = ec._ResolverMap_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _ResolverMap_types(ctx context.Context, field graphql.CollectedField, obj *models.ResolverMap) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "ResolverMap"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Types, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.TypeResolver)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._TypeResolver(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _ResolverMap_metadata(ctx context.Context, field graphql.CollectedField, obj *models.ResolverMap) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "ResolverMap"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Metadata, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.Metadata)
	return ec._Metadata(ctx, field.Selections, &res)
}

func (ec *executionContext) _ResolverMap_status(ctx context.Context, field graphql.CollectedField, obj *models.ResolverMap) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "ResolverMap"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Status, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.Status)
	return ec._Status(ctx, field.Selections, &res)
}

var resolverMapMutationImplementors = []string{"ResolverMapMutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResolverMapMutation(ctx context.Context, sel ast.SelectionSet, obj *customtypes.ResolverMapMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resolverMapMutationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResolverMapMutation")
		case "create":
			out.Values[i] = ec._ResolverMapMutation_create(ctx, field, obj)
		case "update":
			out.Values[i] = ec._ResolverMapMutation_update(ctx, field, obj)
		case "delete":
			out.Values[i] = ec._ResolverMapMutation_delete(ctx, field, obj)
		case "setResolver":
			out.Values[i] = ec._ResolverMapMutation_setResolver(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _ResolverMapMutation_create(ctx context.Context, field graphql.CollectedField, obj *customtypes.ResolverMapMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 models.InputResolverMap
	if tmp, ok := rawArgs["resolverMap"]; ok {
		var err error
		arg0, err = UnmarshalInputResolverMap(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["resolverMap"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "ResolverMapMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.ResolverMapMutation().Create(ctx, obj, args["resolverMap"].(models.InputResolverMap))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.ResolverMap)
		if res == nil {
			return graphql.Null
		}
		return ec._ResolverMap(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _ResolverMapMutation_update(ctx context.Context, field graphql.CollectedField, obj *customtypes.ResolverMapMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 models.InputResolverMap
	if tmp, ok := rawArgs["resolverMap"]; ok {
		var err error
		arg0, err = UnmarshalInputResolverMap(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["resolverMap"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "ResolverMapMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.ResolverMapMutation().Update(ctx, obj, args["resolverMap"].(models.InputResolverMap))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.ResolverMap)
		if res == nil {
			return graphql.Null
		}
		return ec._ResolverMap(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _ResolverMapMutation_delete(ctx context.Context, field graphql.CollectedField, obj *customtypes.ResolverMapMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "ResolverMapMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.ResolverMapMutation().Delete(ctx, obj, args["name"].(string))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.ResolverMap)
		if res == nil {
			return graphql.Null
		}
		return ec._ResolverMap(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _ResolverMapMutation_setResolver(ctx context.Context, field graphql.CollectedField, obj *customtypes.ResolverMapMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["resolverMapName"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["resolverMapName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["resourceVersion"] = arg1
	var arg2 string
	if tmp, ok := rawArgs["typeName"]; ok {
		var err error
		arg2, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["typeName"] = arg2
	var arg3 string
	if tmp, ok := rawArgs["fieldName"]; ok {
		var err error
		arg3, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["fieldName"] = arg3
	var arg4 models.InputGlooResolver
	if tmp, ok := rawArgs["glooResolver"]; ok {
		var err error
		arg4, err = UnmarshalInputGlooResolver(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["glooResolver"] = arg4
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "ResolverMapMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.ResolverMapMutation().SetResolver(ctx, obj, args["resolverMapName"].(string), args["resourceVersion"].(string), args["typeName"].(string), args["fieldName"].(string), args["glooResolver"].(models.InputGlooResolver))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.ResolverMap)
		if res == nil {
			return graphql.Null
		}
		return ec._ResolverMap(ctx, field.Selections, res)
	})
}

var resolverMapQueryImplementors = []string{"ResolverMapQuery"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResolverMapQuery(ctx context.Context, sel ast.SelectionSet, obj *customtypes.ResolverMapQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resolverMapQueryImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResolverMapQuery")
		case "list":
			out.Values[i] = ec._ResolverMapQuery_list(ctx, field, obj)
		case "get":
			out.Values[i] = ec._ResolverMapQuery_get(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _ResolverMapQuery_list(ctx context.Context, field graphql.CollectedField, obj *customtypes.ResolverMapQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 *models.InputMapStringString
	if tmp, ok := rawArgs["selector"]; ok {
		var err error
		var ptr1 models.InputMapStringString
		if tmp != nil {
			ptr1, err = UnmarshalInputMapStringString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["selector"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "ResolverMapQuery",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.ResolverMapQuery().List(ctx, obj, args["selector"].(*models.InputMapStringString))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.([]*models.ResolverMap)
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler {
				rctx := graphql.GetResolverContext(ctx)
				rctx.PushIndex(idx1)
				defer rctx.Pop()
				if res[idx1] == nil {
					return graphql.Null
				}
				return ec._ResolverMap(ctx, field.Selections, res[idx1])
			}())
		}
		return arr1
	})
}

func (ec *executionContext) _ResolverMapQuery_get(ctx context.Context, field graphql.CollectedField, obj *customtypes.ResolverMapQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "ResolverMapQuery",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.ResolverMapQuery().Get(ctx, obj, args["name"].(string))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.ResolverMap)
		if res == nil {
			return graphql.Null
		}
		return ec._ResolverMap(ctx, field.Selections, res)
	})
}

var resourceRefImplementors = []string{"ResourceRef"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResourceRef(ctx context.Context, sel ast.SelectionSet, obj *models.ResourceRef) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, resourceRefImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResourceRef")
		case "name":
			out.Values[i] = ec._ResourceRef_name(ctx, field, obj)
		case "namespace":
			out.Values[i] = ec._ResourceRef_namespace(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _ResourceRef_name(ctx context.Context, field graphql.CollectedField, obj *models.ResourceRef) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "ResourceRef"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _ResourceRef_namespace(ctx context.Context, field graphql.CollectedField, obj *models.ResourceRef) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "ResourceRef"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Namespace, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

var responseTemplateImplementors = []string{"ResponseTemplate"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _ResponseTemplate(ctx context.Context, sel ast.SelectionSet, obj *models.ResponseTemplate) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, responseTemplateImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("ResponseTemplate")
		case "body":
			out.Values[i] = ec._ResponseTemplate_body(ctx, field, obj)
		case "headers":
			out.Values[i] = ec._ResponseTemplate_headers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _ResponseTemplate_body(ctx context.Context, field graphql.CollectedField, obj *models.ResponseTemplate) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "ResponseTemplate"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Body, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _ResponseTemplate_headers(ctx context.Context, field graphql.CollectedField, obj *models.ResponseTemplate) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "ResponseTemplate"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Headers, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MapStringString)
	if res == nil {
		return graphql.Null
	}
	return ec._MapStringString(ctx, field.Selections, res)
}

var restDestinationSpecImplementors = []string{"RestDestinationSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _RestDestinationSpec(ctx context.Context, sel ast.SelectionSet, obj *models.RestDestinationSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, restDestinationSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RestDestinationSpec")
		case "functionName":
			out.Values[i] = ec._RestDestinationSpec_functionName(ctx, field, obj)
		case "parameters":
			out.Values[i] = ec._RestDestinationSpec_parameters(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _RestDestinationSpec_functionName(ctx context.Context, field graphql.CollectedField, obj *models.RestDestinationSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "RestDestinationSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.FunctionName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _RestDestinationSpec_parameters(ctx context.Context, field graphql.CollectedField, obj *models.RestDestinationSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "RestDestinationSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Parameters, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.TransformationParameters)
	if res == nil {
		return graphql.Null
	}
	return ec._TransformationParameters(ctx, field.Selections, res)
}

var restServiceSpecImplementors = []string{"RestServiceSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _RestServiceSpec(ctx context.Context, sel ast.SelectionSet, obj *models.RestServiceSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, restServiceSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RestServiceSpec")
		case "functions":
			out.Values[i] = ec._RestServiceSpec_functions(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _RestServiceSpec_functions(ctx context.Context, field graphql.CollectedField, obj *models.RestServiceSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "RestServiceSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Functions, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.Transformation)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._Transformation(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var routeImplementors = []string{"Route"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Route(ctx context.Context, sel ast.SelectionSet, obj *models.Route) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, routeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Route")
		case "matcher":
			out.Values[i] = ec._Route_matcher(ctx, field, obj)
		case "destination":
			out.Values[i] = ec._Route_destination(ctx, field, obj)
		case "plugins":
			out.Values[i] = ec._Route_plugins(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Route_matcher(ctx context.Context, field graphql.CollectedField, obj *models.Route) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Route"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Matcher, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.Matcher)
	return ec._Matcher(ctx, field.Selections, &res)
}

func (ec *executionContext) _Route_destination(ctx context.Context, field graphql.CollectedField, obj *models.Route) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Route"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Destination, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.Destination)
	return ec._Destination(ctx, field.Selections, &res)
}

func (ec *executionContext) _Route_plugins(ctx context.Context, field graphql.CollectedField, obj *models.Route) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Route"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Plugins, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.RoutePlugins)
	if res == nil {
		return graphql.Null
	}
	return ec._RoutePlugins(ctx, field.Selections, res)
}

var routePluginsImplementors = []string{"RoutePlugins"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _RoutePlugins(ctx context.Context, sel ast.SelectionSet, obj *models.RoutePlugins) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, routePluginsImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("RoutePlugins")
		case "empty":
			out.Values[i] = ec._RoutePlugins_empty(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _RoutePlugins_empty(ctx context.Context, field graphql.CollectedField, obj *models.RoutePlugins) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "RoutePlugins"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Empty, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var schemaImplementors = []string{"Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Schema(ctx context.Context, sel ast.SelectionSet, obj *models.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, schemaImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Schema")
		case "inlineSchema":
			out.Values[i] = ec._Schema_inlineSchema(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._Schema_metadata(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Schema_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Schema_inlineSchema(ctx context.Context, field graphql.CollectedField, obj *models.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.InlineSchema, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Schema_metadata(ctx context.Context, field graphql.CollectedField, obj *models.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Metadata, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.Metadata)
	return ec._Metadata(ctx, field.Selections, &res)
}

func (ec *executionContext) _Schema_status(ctx context.Context, field graphql.CollectedField, obj *models.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Status, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.Status)
	return ec._Status(ctx, field.Selections, &res)
}

var schemaMutationImplementors = []string{"SchemaMutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SchemaMutation(ctx context.Context, sel ast.SelectionSet, obj *customtypes.SchemaMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, schemaMutationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SchemaMutation")
		case "create":
			out.Values[i] = ec._SchemaMutation_create(ctx, field, obj)
		case "update":
			out.Values[i] = ec._SchemaMutation_update(ctx, field, obj)
		case "delete":
			out.Values[i] = ec._SchemaMutation_delete(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _SchemaMutation_create(ctx context.Context, field graphql.CollectedField, obj *customtypes.SchemaMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 models.InputSchema
	if tmp, ok := rawArgs["schema"]; ok {
		var err error
		arg0, err = UnmarshalInputSchema(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["schema"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "SchemaMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.SchemaMutation().Create(ctx, obj, args["schema"].(models.InputSchema))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.Schema)
		if res == nil {
			return graphql.Null
		}
		return ec._Schema(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _SchemaMutation_update(ctx context.Context, field graphql.CollectedField, obj *customtypes.SchemaMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 models.InputSchema
	if tmp, ok := rawArgs["schema"]; ok {
		var err error
		arg0, err = UnmarshalInputSchema(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["schema"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "SchemaMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.SchemaMutation().Update(ctx, obj, args["schema"].(models.InputSchema))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.Schema)
		if res == nil {
			return graphql.Null
		}
		return ec._Schema(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _SchemaMutation_delete(ctx context.Context, field graphql.CollectedField, obj *customtypes.SchemaMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "SchemaMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.SchemaMutation().Delete(ctx, obj, args["name"].(string))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.Schema)
		if res == nil {
			return graphql.Null
		}
		return ec._Schema(ctx, field.Selections, res)
	})
}

var schemaQueryImplementors = []string{"SchemaQuery"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SchemaQuery(ctx context.Context, sel ast.SelectionSet, obj *customtypes.SchemaQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, schemaQueryImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SchemaQuery")
		case "list":
			out.Values[i] = ec._SchemaQuery_list(ctx, field, obj)
		case "get":
			out.Values[i] = ec._SchemaQuery_get(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _SchemaQuery_list(ctx context.Context, field graphql.CollectedField, obj *customtypes.SchemaQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 *models.InputMapStringString
	if tmp, ok := rawArgs["selector"]; ok {
		var err error
		var ptr1 models.InputMapStringString
		if tmp != nil {
			ptr1, err = UnmarshalInputMapStringString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["selector"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "SchemaQuery",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.SchemaQuery().List(ctx, obj, args["selector"].(*models.InputMapStringString))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.([]*models.Schema)
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler {
				rctx := graphql.GetResolverContext(ctx)
				rctx.PushIndex(idx1)
				defer rctx.Pop()
				if res[idx1] == nil {
					return graphql.Null
				}
				return ec._Schema(ctx, field.Selections, res[idx1])
			}())
		}
		return arr1
	})
}

func (ec *executionContext) _SchemaQuery_get(ctx context.Context, field graphql.CollectedField, obj *customtypes.SchemaQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "SchemaQuery",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.SchemaQuery().Get(ctx, obj, args["name"].(string))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.Schema)
		if res == nil {
			return graphql.Null
		}
		return ec._Schema(ctx, field.Selections, res)
	})
}

var secretImplementors = []string{"Secret"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Secret(ctx context.Context, sel ast.SelectionSet, obj *models.Secret) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, secretImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Secret")
		case "kind":
			out.Values[i] = ec._Secret_kind(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._Secret_metadata(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Secret_kind(ctx context.Context, field graphql.CollectedField, obj *models.Secret) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Secret"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Kind, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.SecretKind)
	return ec._SecretKind(ctx, field.Selections, &res)
}

func (ec *executionContext) _Secret_metadata(ctx context.Context, field graphql.CollectedField, obj *models.Secret) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Secret"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Metadata, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.Metadata)
	return ec._Metadata(ctx, field.Selections, &res)
}

var secretMutationImplementors = []string{"SecretMutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SecretMutation(ctx context.Context, sel ast.SelectionSet, obj *customtypes.SecretMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, secretMutationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SecretMutation")
		case "create":
			out.Values[i] = ec._SecretMutation_create(ctx, field, obj)
		case "update":
			out.Values[i] = ec._SecretMutation_update(ctx, field, obj)
		case "delete":
			out.Values[i] = ec._SecretMutation_delete(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _SecretMutation_create(ctx context.Context, field graphql.CollectedField, obj *customtypes.SecretMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 models.InputSecret
	if tmp, ok := rawArgs["secret"]; ok {
		var err error
		arg0, err = UnmarshalInputSecret(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["secret"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "SecretMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.SecretMutation().Create(ctx, obj, args["secret"].(models.InputSecret))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.Secret)
		if res == nil {
			return graphql.Null
		}
		return ec._Secret(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _SecretMutation_update(ctx context.Context, field graphql.CollectedField, obj *customtypes.SecretMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 models.InputSecret
	if tmp, ok := rawArgs["secret"]; ok {
		var err error
		arg0, err = UnmarshalInputSecret(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["secret"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "SecretMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.SecretMutation().Update(ctx, obj, args["secret"].(models.InputSecret))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.Secret)
		if res == nil {
			return graphql.Null
		}
		return ec._Secret(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _SecretMutation_delete(ctx context.Context, field graphql.CollectedField, obj *customtypes.SecretMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "SecretMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.SecretMutation().Delete(ctx, obj, args["name"].(string))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.Secret)
		if res == nil {
			return graphql.Null
		}
		return ec._Secret(ctx, field.Selections, res)
	})
}

var secretQueryImplementors = []string{"SecretQuery"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SecretQuery(ctx context.Context, sel ast.SelectionSet, obj *customtypes.SecretQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, secretQueryImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SecretQuery")
		case "list":
			out.Values[i] = ec._SecretQuery_list(ctx, field, obj)
		case "get":
			out.Values[i] = ec._SecretQuery_get(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _SecretQuery_list(ctx context.Context, field graphql.CollectedField, obj *customtypes.SecretQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 *models.InputMapStringString
	if tmp, ok := rawArgs["selector"]; ok {
		var err error
		var ptr1 models.InputMapStringString
		if tmp != nil {
			ptr1, err = UnmarshalInputMapStringString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["selector"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "SecretQuery",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.SecretQuery().List(ctx, obj, args["selector"].(*models.InputMapStringString))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.([]*models.Secret)
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler {
				rctx := graphql.GetResolverContext(ctx)
				rctx.PushIndex(idx1)
				defer rctx.Pop()
				if res[idx1] == nil {
					return graphql.Null
				}
				return ec._Secret(ctx, field.Selections, res[idx1])
			}())
		}
		return arr1
	})
}

func (ec *executionContext) _SecretQuery_get(ctx context.Context, field graphql.CollectedField, obj *customtypes.SecretQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "SecretQuery",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.SecretQuery().Get(ctx, obj, args["name"].(string))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.Secret)
		if res == nil {
			return graphql.Null
		}
		return ec._Secret(ctx, field.Selections, res)
	})
}

var singleDestinationImplementors = []string{"SingleDestination"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SingleDestination(ctx context.Context, sel ast.SelectionSet, obj *models.SingleDestination) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, singleDestinationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SingleDestination")
		case "upstream":
			out.Values[i] = ec._SingleDestination_upstream(ctx, field, obj)
		case "destinationSpec":
			out.Values[i] = ec._SingleDestination_destinationSpec(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _SingleDestination_upstream(ctx context.Context, field graphql.CollectedField, obj *models.SingleDestination) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "SingleDestination"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Upstream, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.ResourceRef)
	return ec._ResourceRef(ctx, field.Selections, &res)
}

func (ec *executionContext) _SingleDestination_destinationSpec(ctx context.Context, field graphql.CollectedField, obj *models.SingleDestination) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "SingleDestination"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.DestinationSpec, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.DestinationSpec)
	return ec._DestinationSpec(ctx, field.Selections, &res)
}

var sslConfigImplementors = []string{"SslConfig"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _SslConfig(ctx context.Context, sel ast.SelectionSet, obj *models.SslConfig) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, sslConfigImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("SslConfig")
		case "secretRef":
			out.Values[i] = ec._SslConfig_secretRef(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _SslConfig_secretRef(ctx context.Context, field graphql.CollectedField, obj *models.SslConfig) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "SslConfig"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.SecretRef, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.ResourceRef)
	return ec._ResourceRef(ctx, field.Selections, &res)
}

var staticHostImplementors = []string{"StaticHost"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _StaticHost(ctx context.Context, sel ast.SelectionSet, obj *models.StaticHost) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, staticHostImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StaticHost")
		case "addr":
			out.Values[i] = ec._StaticHost_addr(ctx, field, obj)
		case "port":
			out.Values[i] = ec._StaticHost_port(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _StaticHost_addr(ctx context.Context, field graphql.CollectedField, obj *models.StaticHost) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "StaticHost"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Addr, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _StaticHost_port(ctx context.Context, field graphql.CollectedField, obj *models.StaticHost) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "StaticHost"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Port, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	return graphql.MarshalInt(res)
}

var staticUpstreamSpecImplementors = []string{"StaticUpstreamSpec"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _StaticUpstreamSpec(ctx context.Context, sel ast.SelectionSet, obj *models.StaticUpstreamSpec) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, staticUpstreamSpecImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("StaticUpstreamSpec")
		case "hosts":
			out.Values[i] = ec._StaticUpstreamSpec_hosts(ctx, field, obj)
		case "serviceSpec":
			out.Values[i] = ec._StaticUpstreamSpec_serviceSpec(ctx, field, obj)
		case "useTls":
			out.Values[i] = ec._StaticUpstreamSpec_useTls(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _StaticUpstreamSpec_hosts(ctx context.Context, field graphql.CollectedField, obj *models.StaticUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "StaticUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Hosts, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.StaticHost)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._StaticHost(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _StaticUpstreamSpec_serviceSpec(ctx context.Context, field graphql.CollectedField, obj *models.StaticUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "StaticUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.ServiceSpec, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.ServiceSpec)
	return ec._ServiceSpec(ctx, field.Selections, &res)
}

func (ec *executionContext) _StaticUpstreamSpec_useTls(ctx context.Context, field graphql.CollectedField, obj *models.StaticUpstreamSpec) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "StaticUpstreamSpec"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.UseTLS, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	return graphql.MarshalBoolean(res)
}

var statusImplementors = []string{"Status"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Status(ctx context.Context, sel ast.SelectionSet, obj *models.Status) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, statusImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Status")
		case "state":
			out.Values[i] = ec._Status_state(ctx, field, obj)
		case "reason":
			out.Values[i] = ec._Status_reason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Status_state(ctx context.Context, field graphql.CollectedField, obj *models.Status) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Status"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.State, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.State)
	return res
}

func (ec *executionContext) _Status_reason(ctx context.Context, field graphql.CollectedField, obj *models.Status) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Status"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Reason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var templateResolverImplementors = []string{"TemplateResolver"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _TemplateResolver(ctx context.Context, sel ast.SelectionSet, obj *models.TemplateResolver) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, templateResolverImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TemplateResolver")
		case "inlineTemplate":
			out.Values[i] = ec._TemplateResolver_inlineTemplate(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _TemplateResolver_inlineTemplate(ctx context.Context, field graphql.CollectedField, obj *models.TemplateResolver) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "TemplateResolver"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.InlineTemplate, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var tlsSecretImplementors = []string{"TlsSecret"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _TlsSecret(ctx context.Context, sel ast.SelectionSet, obj *models.TlsSecret) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, tlsSecretImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TlsSecret")
		case "certChain":
			out.Values[i] = ec._TlsSecret_certChain(ctx, field, obj)
		case "privateKey":
			out.Values[i] = ec._TlsSecret_privateKey(ctx, field, obj)
		case "rootCa":
			out.Values[i] = ec._TlsSecret_rootCa(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _TlsSecret_certChain(ctx context.Context, field graphql.CollectedField, obj *models.TlsSecret) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "TlsSecret"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.CertChain, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _TlsSecret_privateKey(ctx context.Context, field graphql.CollectedField, obj *models.TlsSecret) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "TlsSecret"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.PrivateKey, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _TlsSecret_rootCa(ctx context.Context, field graphql.CollectedField, obj *models.TlsSecret) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "TlsSecret"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.RootCa, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

var transformationImplementors = []string{"Transformation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Transformation(ctx context.Context, sel ast.SelectionSet, obj *models.Transformation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, transformationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Transformation")
		case "functionName":
			out.Values[i] = ec._Transformation_functionName(ctx, field, obj)
		case "body":
			out.Values[i] = ec._Transformation_body(ctx, field, obj)
		case "headers":
			out.Values[i] = ec._Transformation_headers(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Transformation_functionName(ctx context.Context, field graphql.CollectedField, obj *models.Transformation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Transformation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.FunctionName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Transformation_body(ctx context.Context, field graphql.CollectedField, obj *models.Transformation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Transformation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Body, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) _Transformation_headers(ctx context.Context, field graphql.CollectedField, obj *models.Transformation) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Transformation"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Headers, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MapStringString)
	if res == nil {
		return graphql.Null
	}
	return ec._MapStringString(ctx, field.Selections, res)
}

var transformationParametersImplementors = []string{"TransformationParameters"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _TransformationParameters(ctx context.Context, sel ast.SelectionSet, obj *models.TransformationParameters) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, transformationParametersImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TransformationParameters")
		case "headers":
			out.Values[i] = ec._TransformationParameters_headers(ctx, field, obj)
		case "path":
			out.Values[i] = ec._TransformationParameters_path(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _TransformationParameters_headers(ctx context.Context, field graphql.CollectedField, obj *models.TransformationParameters) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "TransformationParameters"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Headers, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.MapStringString)
	if res == nil {
		return graphql.Null
	}
	return ec._MapStringString(ctx, field.Selections, res)
}

func (ec *executionContext) _TransformationParameters_path(ctx context.Context, field graphql.CollectedField, obj *models.TransformationParameters) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "TransformationParameters"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Path, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var typeResolverImplementors = []string{"TypeResolver"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _TypeResolver(ctx context.Context, sel ast.SelectionSet, obj *models.TypeResolver) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, typeResolverImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("TypeResolver")
		case "typeName":
			out.Values[i] = ec._TypeResolver_typeName(ctx, field, obj)
		case "fields":
			out.Values[i] = ec._TypeResolver_fields(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _TypeResolver_typeName(ctx context.Context, field graphql.CollectedField, obj *models.TypeResolver) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "TypeResolver"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.TypeName, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _TypeResolver_fields(ctx context.Context, field graphql.CollectedField, obj *models.TypeResolver) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "TypeResolver"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Fields, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.FieldResolver)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._FieldResolver(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var upstreamImplementors = []string{"Upstream"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Upstream(ctx context.Context, sel ast.SelectionSet, obj *models.Upstream) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, upstreamImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Upstream")
		case "spec":
			out.Values[i] = ec._Upstream_spec(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._Upstream_metadata(ctx, field, obj)
		case "status":
			out.Values[i] = ec._Upstream_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Upstream_spec(ctx context.Context, field graphql.CollectedField, obj *models.Upstream) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Upstream"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Spec, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.UpstreamSpec)
	return ec._UpstreamSpec(ctx, field.Selections, &res)
}

func (ec *executionContext) _Upstream_metadata(ctx context.Context, field graphql.CollectedField, obj *models.Upstream) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Upstream"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Metadata, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.Metadata)
	return ec._Metadata(ctx, field.Selections, &res)
}

func (ec *executionContext) _Upstream_status(ctx context.Context, field graphql.CollectedField, obj *models.Upstream) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Upstream"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Status, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.Status)
	return ec._Status(ctx, field.Selections, &res)
}

var upstreamMutationImplementors = []string{"UpstreamMutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UpstreamMutation(ctx context.Context, sel ast.SelectionSet, obj *customtypes.UpstreamMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, upstreamMutationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpstreamMutation")
		case "create":
			out.Values[i] = ec._UpstreamMutation_create(ctx, field, obj)
		case "update":
			out.Values[i] = ec._UpstreamMutation_update(ctx, field, obj)
		case "delete":
			out.Values[i] = ec._UpstreamMutation_delete(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _UpstreamMutation_create(ctx context.Context, field graphql.CollectedField, obj *customtypes.UpstreamMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 models.InputUpstream
	if tmp, ok := rawArgs["upstream"]; ok {
		var err error
		arg0, err = UnmarshalInputUpstream(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["upstream"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "UpstreamMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.UpstreamMutation().Create(ctx, obj, args["upstream"].(models.InputUpstream))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.Upstream)
		if res == nil {
			return graphql.Null
		}
		return ec._Upstream(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _UpstreamMutation_update(ctx context.Context, field graphql.CollectedField, obj *customtypes.UpstreamMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 models.InputUpstream
	if tmp, ok := rawArgs["upstream"]; ok {
		var err error
		arg0, err = UnmarshalInputUpstream(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["upstream"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "UpstreamMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.UpstreamMutation().Update(ctx, obj, args["upstream"].(models.InputUpstream))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.Upstream)
		if res == nil {
			return graphql.Null
		}
		return ec._Upstream(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _UpstreamMutation_delete(ctx context.Context, field graphql.CollectedField, obj *customtypes.UpstreamMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "UpstreamMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.UpstreamMutation().Delete(ctx, obj, args["name"].(string))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.Upstream)
		if res == nil {
			return graphql.Null
		}
		return ec._Upstream(ctx, field.Selections, res)
	})
}

var upstreamQueryImplementors = []string{"UpstreamQuery"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _UpstreamQuery(ctx context.Context, sel ast.SelectionSet, obj *customtypes.UpstreamQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, upstreamQueryImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("UpstreamQuery")
		case "list":
			out.Values[i] = ec._UpstreamQuery_list(ctx, field, obj)
		case "get":
			out.Values[i] = ec._UpstreamQuery_get(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _UpstreamQuery_list(ctx context.Context, field graphql.CollectedField, obj *customtypes.UpstreamQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 *models.InputMapStringString
	if tmp, ok := rawArgs["selector"]; ok {
		var err error
		var ptr1 models.InputMapStringString
		if tmp != nil {
			ptr1, err = UnmarshalInputMapStringString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["selector"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "UpstreamQuery",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.UpstreamQuery().List(ctx, obj, args["selector"].(*models.InputMapStringString))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.([]*models.Upstream)
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler {
				rctx := graphql.GetResolverContext(ctx)
				rctx.PushIndex(idx1)
				defer rctx.Pop()
				if res[idx1] == nil {
					return graphql.Null
				}
				return ec._Upstream(ctx, field.Selections, res[idx1])
			}())
		}
		return arr1
	})
}

func (ec *executionContext) _UpstreamQuery_get(ctx context.Context, field graphql.CollectedField, obj *customtypes.UpstreamQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "UpstreamQuery",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.UpstreamQuery().Get(ctx, obj, args["name"].(string))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.Upstream)
		if res == nil {
			return graphql.Null
		}
		return ec._Upstream(ctx, field.Selections, res)
	})
}

var valueImplementors = []string{"Value"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _Value(ctx context.Context, sel ast.SelectionSet, obj *models.Value) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, valueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("Value")
		case "key":
			out.Values[i] = ec._Value_key(ctx, field, obj)
		case "value":
			out.Values[i] = ec._Value_value(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _Value_key(ctx context.Context, field graphql.CollectedField, obj *models.Value) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Value"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Key, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) _Value_value(ctx context.Context, field graphql.CollectedField, obj *models.Value) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "Value"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Value, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

var virtualServiceImplementors = []string{"VirtualService"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _VirtualService(ctx context.Context, sel ast.SelectionSet, obj *models.VirtualService) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, virtualServiceImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VirtualService")
		case "domains":
			out.Values[i] = ec._VirtualService_domains(ctx, field, obj)
		case "routes":
			out.Values[i] = ec._VirtualService_routes(ctx, field, obj)
		case "sslConfig":
			out.Values[i] = ec._VirtualService_sslConfig(ctx, field, obj)
		case "plugins":
			out.Values[i] = ec._VirtualService_plugins(ctx, field, obj)
		case "metadata":
			out.Values[i] = ec._VirtualService_metadata(ctx, field, obj)
		case "status":
			out.Values[i] = ec._VirtualService_status(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _VirtualService_domains(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "VirtualService"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Domains, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return graphql.MarshalString(res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _VirtualService_routes(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "VirtualService"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Routes, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]models.Route)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec._Route(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) _VirtualService_sslConfig(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "VirtualService"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.SslConfig, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.SslConfig)
	if res == nil {
		return graphql.Null
	}
	return ec._SslConfig(ctx, field.Selections, res)
}

func (ec *executionContext) _VirtualService_plugins(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "VirtualService"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Plugins, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*models.VirtualServicePlugins)
	if res == nil {
		return graphql.Null
	}
	return ec._VirtualServicePlugins(ctx, field.Selections, res)
}

func (ec *executionContext) _VirtualService_metadata(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "VirtualService"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Metadata, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.Metadata)
	return ec._Metadata(ctx, field.Selections, &res)
}

func (ec *executionContext) _VirtualService_status(ctx context.Context, field graphql.CollectedField, obj *models.VirtualService) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "VirtualService"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Status, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.Status)
	return ec._Status(ctx, field.Selections, &res)
}

var virtualServiceMutationImplementors = []string{"VirtualServiceMutation"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _VirtualServiceMutation(ctx context.Context, sel ast.SelectionSet, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, virtualServiceMutationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VirtualServiceMutation")
		case "create":
			out.Values[i] = ec._VirtualServiceMutation_create(ctx, field, obj)
		case "update":
			out.Values[i] = ec._VirtualServiceMutation_update(ctx, field, obj)
		case "delete":
			out.Values[i] = ec._VirtualServiceMutation_delete(ctx, field, obj)
		case "addRoute":
			out.Values[i] = ec._VirtualServiceMutation_addRoute(ctx, field, obj)
		case "updateRoute":
			out.Values[i] = ec._VirtualServiceMutation_updateRoute(ctx, field, obj)
		case "deleteRoute":
			out.Values[i] = ec._VirtualServiceMutation_deleteRoute(ctx, field, obj)
		case "swapRoutes":
			out.Values[i] = ec._VirtualServiceMutation_swapRoutes(ctx, field, obj)
		case "shiftRoutes":
			out.Values[i] = ec._VirtualServiceMutation_shiftRoutes(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _VirtualServiceMutation_create(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 models.InputVirtualService
	if tmp, ok := rawArgs["virtualService"]; ok {
		var err error
		arg0, err = UnmarshalInputVirtualService(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["virtualService"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.VirtualServiceMutation().Create(ctx, obj, args["virtualService"].(models.InputVirtualService))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.VirtualService)
		if res == nil {
			return graphql.Null
		}
		return ec._VirtualService(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _VirtualServiceMutation_update(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["resourceVersion"] = arg1
	var arg2 models.InputUpdateVirtualService
	if tmp, ok := rawArgs["virtualService"]; ok {
		var err error
		arg2, err = UnmarshalInputUpdateVirtualService(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["virtualService"] = arg2
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.VirtualServiceMutation().Update(ctx, obj, args["name"].(string), args["resourceVersion"].(string), args["virtualService"].(models.InputUpdateVirtualService))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.VirtualService)
		if res == nil {
			return graphql.Null
		}
		return ec._VirtualService(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _VirtualServiceMutation_delete(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.VirtualServiceMutation().Delete(ctx, obj, args["name"].(string))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.VirtualService)
		if res == nil {
			return graphql.Null
		}
		return ec._VirtualService(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _VirtualServiceMutation_addRoute(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["virtualServiceName"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["virtualServiceName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["resourceVersion"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["index"]; ok {
		var err error
		arg2, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["index"] = arg2
	var arg3 models.InputRoute
	if tmp, ok := rawArgs["route"]; ok {
		var err error
		arg3, err = UnmarshalInputRoute(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["route"] = arg3
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.VirtualServiceMutation().AddRoute(ctx, obj, args["virtualServiceName"].(string), args["resourceVersion"].(string), args["index"].(int), args["route"].(models.InputRoute))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.VirtualService)
		if res == nil {
			return graphql.Null
		}
		return ec._VirtualService(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _VirtualServiceMutation_updateRoute(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["virtualServiceName"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["virtualServiceName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["resourceVersion"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["index"]; ok {
		var err error
		arg2, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["index"] = arg2
	var arg3 models.InputRoute
	if tmp, ok := rawArgs["route"]; ok {
		var err error
		arg3, err = UnmarshalInputRoute(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["route"] = arg3
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.VirtualServiceMutation().UpdateRoute(ctx, obj, args["virtualServiceName"].(string), args["resourceVersion"].(string), args["index"].(int), args["route"].(models.InputRoute))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.VirtualService)
		if res == nil {
			return graphql.Null
		}
		return ec._VirtualService(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _VirtualServiceMutation_deleteRoute(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["virtualServiceName"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["virtualServiceName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["resourceVersion"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["index"]; ok {
		var err error
		arg2, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["index"] = arg2
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.VirtualServiceMutation().DeleteRoute(ctx, obj, args["virtualServiceName"].(string), args["resourceVersion"].(string), args["index"].(int))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.VirtualService)
		if res == nil {
			return graphql.Null
		}
		return ec._VirtualService(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _VirtualServiceMutation_swapRoutes(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["virtualServiceName"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["virtualServiceName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["resourceVersion"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["index1"]; ok {
		var err error
		arg2, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["index1"] = arg2
	var arg3 int
	if tmp, ok := rawArgs["index2"]; ok {
		var err error
		arg3, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["index2"] = arg3
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.VirtualServiceMutation().SwapRoutes(ctx, obj, args["virtualServiceName"].(string), args["resourceVersion"].(string), args["index1"].(int), args["index2"].(int))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.VirtualService)
		if res == nil {
			return graphql.Null
		}
		return ec._VirtualService(ctx, field.Selections, res)
	})
}

func (ec *executionContext) _VirtualServiceMutation_shiftRoutes(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceMutation) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["virtualServiceName"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["virtualServiceName"] = arg0
	var arg1 string
	if tmp, ok := rawArgs["resourceVersion"]; ok {
		var err error
		arg1, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["resourceVersion"] = arg1
	var arg2 int
	if tmp, ok := rawArgs["fromIndex"]; ok {
		var err error
		arg2, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["fromIndex"] = arg2
	var arg3 int
	if tmp, ok := rawArgs["toIndex"]; ok {
		var err error
		arg3, err = graphql.UnmarshalInt(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["toIndex"] = arg3
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "VirtualServiceMutation",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.VirtualServiceMutation().ShiftRoutes(ctx, obj, args["virtualServiceName"].(string), args["resourceVersion"].(string), args["fromIndex"].(int), args["toIndex"].(int))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.VirtualService)
		if res == nil {
			return graphql.Null
		}
		return ec._VirtualService(ctx, field.Selections, res)
	})
}

var virtualServicePluginsImplementors = []string{"VirtualServicePlugins"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _VirtualServicePlugins(ctx context.Context, sel ast.SelectionSet, obj *models.VirtualServicePlugins) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, virtualServicePluginsImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VirtualServicePlugins")
		case "empty":
			out.Values[i] = ec._VirtualServicePlugins_empty(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _VirtualServicePlugins_empty(ctx context.Context, field graphql.CollectedField, obj *models.VirtualServicePlugins) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "VirtualServicePlugins"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Empty, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var virtualServiceQueryImplementors = []string{"VirtualServiceQuery"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _VirtualServiceQuery(ctx context.Context, sel ast.SelectionSet, obj *customtypes.VirtualServiceQuery) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, virtualServiceQueryImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("VirtualServiceQuery")
		case "list":
			out.Values[i] = ec._VirtualServiceQuery_list(ctx, field, obj)
		case "get":
			out.Values[i] = ec._VirtualServiceQuery_get(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _VirtualServiceQuery_list(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 *models.InputMapStringString
	if tmp, ok := rawArgs["selector"]; ok {
		var err error
		var ptr1 models.InputMapStringString
		if tmp != nil {
			ptr1, err = UnmarshalInputMapStringString(tmp)
			arg0 = &ptr1
		}

		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["selector"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "VirtualServiceQuery",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.VirtualServiceQuery().List(ctx, obj, args["selector"].(*models.InputMapStringString))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.([]*models.VirtualService)
		arr1 := graphql.Array{}
		for idx1 := range res {
			arr1 = append(arr1, func() graphql.Marshaler {
				rctx := graphql.GetResolverContext(ctx)
				rctx.PushIndex(idx1)
				defer rctx.Pop()
				if res[idx1] == nil {
					return graphql.Null
				}
				return ec._VirtualService(ctx, field.Selections, res[idx1])
			}())
		}
		return arr1
	})
}

func (ec *executionContext) _VirtualServiceQuery_get(ctx context.Context, field graphql.CollectedField, obj *customtypes.VirtualServiceQuery) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 string
	if tmp, ok := rawArgs["name"]; ok {
		var err error
		arg0, err = graphql.UnmarshalString(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["name"] = arg0
	ctx = graphql.WithResolverContext(ctx, &graphql.ResolverContext{
		Object: "VirtualServiceQuery",
		Args:   args,
		Field:  field,
	})
	return graphql.Defer(func() (ret graphql.Marshaler) {
		defer func() {
			if r := recover(); r != nil {
				userErr := ec.Recover(ctx, r)
				ec.Error(ctx, userErr)
				ret = graphql.Null
			}
		}()

		resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
			return ec.resolvers.VirtualServiceQuery().Get(ctx, obj, args["name"].(string))
		})
		if resTmp == nil {
			return graphql.Null
		}
		res := resTmp.(*models.VirtualService)
		if res == nil {
			return graphql.Null
		}
		return ec._VirtualService(ctx, field.Selections, res)
	})
}

var weightedDestinationImplementors = []string{"WeightedDestination"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) _WeightedDestination(ctx context.Context, sel ast.SelectionSet, obj *models.WeightedDestination) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, weightedDestinationImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("WeightedDestination")
		case "destination":
			out.Values[i] = ec._WeightedDestination_destination(ctx, field, obj)
		case "weight":
			out.Values[i] = ec._WeightedDestination_weight(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) _WeightedDestination_destination(ctx context.Context, field graphql.CollectedField, obj *models.WeightedDestination) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "WeightedDestination"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Destination, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(models.SingleDestination)
	return ec._SingleDestination(ctx, field.Selections, &res)
}

func (ec *executionContext) _WeightedDestination_weight(ctx context.Context, field graphql.CollectedField, obj *models.WeightedDestination) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "WeightedDestination"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Weight, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(int)
	return graphql.MarshalInt(res)
}

var __DirectiveImplementors = []string{"__Directive"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Directive(ctx context.Context, sel ast.SelectionSet, obj *introspection.Directive) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __DirectiveImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Directive")
		case "name":
			out.Values[i] = ec.___Directive_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Directive_description(ctx, field, obj)
		case "locations":
			out.Values[i] = ec.___Directive_locations(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Directive_args(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Directive_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Directive_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Directive_locations(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Locations, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]string)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return graphql.MarshalString(res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Directive_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Directive) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Directive"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Args, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var __EnumValueImplementors = []string{"__EnumValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___EnumValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.EnumValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __EnumValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__EnumValue")
		case "name":
			out.Values[i] = ec.___EnumValue_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___EnumValue_description(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___EnumValue_isDeprecated(ctx, field, obj)
		case "deprecationReason":
			out.Values[i] = ec.___EnumValue_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___EnumValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___EnumValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___EnumValue_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.IsDeprecated, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) ___EnumValue_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.EnumValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__EnumValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.DeprecationReason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

var __FieldImplementors = []string{"__Field"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Field(ctx context.Context, sel ast.SelectionSet, obj *introspection.Field) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __FieldImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Field")
		case "name":
			out.Values[i] = ec.___Field_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Field_description(ctx, field, obj)
		case "args":
			out.Values[i] = ec.___Field_args(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___Field_type(ctx, field, obj)
		case "isDeprecated":
			out.Values[i] = ec.___Field_isDeprecated(ctx, field, obj)
		case "deprecationReason":
			out.Values[i] = ec.___Field_deprecationReason(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Field_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Field_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Field_args(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Args, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Field_type(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Type, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___Field_isDeprecated(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.IsDeprecated, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(bool)
	return graphql.MarshalBoolean(res)
}

func (ec *executionContext) ___Field_deprecationReason(ctx context.Context, field graphql.CollectedField, obj *introspection.Field) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Field"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.DeprecationReason, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

var __InputValueImplementors = []string{"__InputValue"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___InputValue(ctx context.Context, sel ast.SelectionSet, obj *introspection.InputValue) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __InputValueImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__InputValue")
		case "name":
			out.Values[i] = ec.___InputValue_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___InputValue_description(ctx, field, obj)
		case "type":
			out.Values[i] = ec.___InputValue_type(ctx, field, obj)
		case "defaultValue":
			out.Values[i] = ec.___InputValue_defaultValue(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___InputValue_name(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Name, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___InputValue_description(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Description, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___InputValue_type(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Type, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___InputValue_defaultValue(ctx context.Context, field graphql.CollectedField, obj *introspection.InputValue) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__InputValue"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.DefaultValue, nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

var __SchemaImplementors = []string{"__Schema"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Schema(ctx context.Context, sel ast.SelectionSet, obj *introspection.Schema) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __SchemaImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Schema")
		case "types":
			out.Values[i] = ec.___Schema_types(ctx, field, obj)
		case "queryType":
			out.Values[i] = ec.___Schema_queryType(ctx, field, obj)
		case "mutationType":
			out.Values[i] = ec.___Schema_mutationType(ctx, field, obj)
		case "subscriptionType":
			out.Values[i] = ec.___Schema_subscriptionType(ctx, field, obj)
		case "directives":
			out.Values[i] = ec.___Schema_directives(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Schema_types(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Types(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Schema_queryType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.QueryType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_mutationType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.MutationType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_subscriptionType(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.SubscriptionType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) ___Schema_directives(ctx context.Context, field graphql.CollectedField, obj *introspection.Schema) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Schema"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Directives(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Directive)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Directive(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

var __TypeImplementors = []string{"__Type"}

// nolint: gocyclo, errcheck, gas, goconst
func (ec *executionContext) ___Type(ctx context.Context, sel ast.SelectionSet, obj *introspection.Type) graphql.Marshaler {
	fields := graphql.CollectFields(ctx, sel, __TypeImplementors)

	out := graphql.NewOrderedMap(len(fields))
	for i, field := range fields {
		out.Keys[i] = field.Alias

		switch field.Name {
		case "__typename":
			out.Values[i] = graphql.MarshalString("__Type")
		case "kind":
			out.Values[i] = ec.___Type_kind(ctx, field, obj)
		case "name":
			out.Values[i] = ec.___Type_name(ctx, field, obj)
		case "description":
			out.Values[i] = ec.___Type_description(ctx, field, obj)
		case "fields":
			out.Values[i] = ec.___Type_fields(ctx, field, obj)
		case "interfaces":
			out.Values[i] = ec.___Type_interfaces(ctx, field, obj)
		case "possibleTypes":
			out.Values[i] = ec.___Type_possibleTypes(ctx, field, obj)
		case "enumValues":
			out.Values[i] = ec.___Type_enumValues(ctx, field, obj)
		case "inputFields":
			out.Values[i] = ec.___Type_inputFields(ctx, field, obj)
		case "ofType":
			out.Values[i] = ec.___Type_ofType(ctx, field, obj)
		default:
			panic("unknown field " + strconv.Quote(field.Name))
		}
	}

	return out
}

func (ec *executionContext) ___Type_kind(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Kind(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Type_name(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Name(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*string)
	if res == nil {
		return graphql.Null
	}
	return graphql.MarshalString(*res)
}

func (ec *executionContext) ___Type_description(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Description(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(string)
	return graphql.MarshalString(res)
}

func (ec *executionContext) ___Type_fields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["includeDeprecated"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Fields(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Field)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Field(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_interfaces(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.Interfaces(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_possibleTypes(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.PossibleTypes(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.Type)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___Type(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_enumValues(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rawArgs := field.ArgumentMap(ec.Variables)
	args := map[string]interface{}{}
	var arg0 bool
	if tmp, ok := rawArgs["includeDeprecated"]; ok {
		var err error
		arg0, err = graphql.UnmarshalBoolean(tmp)
		if err != nil {
			ec.Error(ctx, err)
			return graphql.Null
		}
	}
	args["includeDeprecated"] = arg0
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = args
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.EnumValues(args["includeDeprecated"].(bool)), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.EnumValue)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___EnumValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_inputFields(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.InputFields(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.([]introspection.InputValue)
	arr1 := graphql.Array{}
	for idx1 := range res {
		arr1 = append(arr1, func() graphql.Marshaler {
			rctx := graphql.GetResolverContext(ctx)
			rctx.PushIndex(idx1)
			defer rctx.Pop()
			return ec.___InputValue(ctx, field.Selections, &res[idx1])
		}())
	}
	return arr1
}

func (ec *executionContext) ___Type_ofType(ctx context.Context, field graphql.CollectedField, obj *introspection.Type) graphql.Marshaler {
	rctx := graphql.GetResolverContext(ctx)
	rctx.Object = "__Type"
	rctx.Args = nil
	rctx.Field = field
	rctx.PushField(field.Alias)
	defer rctx.Pop()
	resTmp := ec.FieldMiddleware(ctx, func(ctx context.Context) (interface{}, error) {
		return obj.OfType(), nil
	})
	if resTmp == nil {
		return graphql.Null
	}
	res := resTmp.(*introspection.Type)
	if res == nil {
		return graphql.Null
	}
	return ec.___Type(ctx, field.Selections, res)
}

func (ec *executionContext) _Destination(ctx context.Context, sel ast.SelectionSet, obj *models.Destination) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.MultiDestination:
		return ec._MultiDestination(ctx, sel, &obj)
	case *models.MultiDestination:
		return ec._MultiDestination(ctx, sel, obj)
	case models.SingleDestination:
		return ec._SingleDestination(ctx, sel, &obj)
	case *models.SingleDestination:
		return ec._SingleDestination(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _DestinationSpec(ctx context.Context, sel ast.SelectionSet, obj *models.DestinationSpec) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.AwsDestinationSpec:
		return ec._AwsDestinationSpec(ctx, sel, &obj)
	case *models.AwsDestinationSpec:
		return ec._AwsDestinationSpec(ctx, sel, obj)
	case models.AzureDestinationSpec:
		return ec._AzureDestinationSpec(ctx, sel, &obj)
	case *models.AzureDestinationSpec:
		return ec._AzureDestinationSpec(ctx, sel, obj)
	case models.RestDestinationSpec:
		return ec._RestDestinationSpec(ctx, sel, &obj)
	case *models.RestDestinationSpec:
		return ec._RestDestinationSpec(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _Resolver(ctx context.Context, sel ast.SelectionSet, obj *models.Resolver) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.GlooResolver:
		return ec._GlooResolver(ctx, sel, &obj)
	case *models.GlooResolver:
		return ec._GlooResolver(ctx, sel, obj)
	case models.TemplateResolver:
		return ec._TemplateResolver(ctx, sel, &obj)
	case *models.TemplateResolver:
		return ec._TemplateResolver(ctx, sel, obj)
	case models.NodeJSResolver:
		return ec._NodeJSResolver(ctx, sel, &obj)
	case *models.NodeJSResolver:
		return ec._NodeJSResolver(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _SecretKind(ctx context.Context, sel ast.SelectionSet, obj *models.SecretKind) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.AwsSecret:
		return ec._AwsSecret(ctx, sel, &obj)
	case *models.AwsSecret:
		return ec._AwsSecret(ctx, sel, obj)
	case models.AzureSecret:
		return ec._AzureSecret(ctx, sel, &obj)
	case *models.AzureSecret:
		return ec._AzureSecret(ctx, sel, obj)
	case models.TlsSecret:
		return ec._TlsSecret(ctx, sel, &obj)
	case *models.TlsSecret:
		return ec._TlsSecret(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _ServiceSpec(ctx context.Context, sel ast.SelectionSet, obj *models.ServiceSpec) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.RestServiceSpec:
		return ec._RestServiceSpec(ctx, sel, &obj)
	case *models.RestServiceSpec:
		return ec._RestServiceSpec(ctx, sel, obj)
	case models.GRPCServiceSpec:
		return ec._GRPCServiceSpec(ctx, sel, &obj)
	case *models.GRPCServiceSpec:
		return ec._GRPCServiceSpec(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func (ec *executionContext) _UpstreamSpec(ctx context.Context, sel ast.SelectionSet, obj *models.UpstreamSpec) graphql.Marshaler {
	switch obj := (*obj).(type) {
	case nil:
		return graphql.Null
	case models.AwsUpstreamSpec:
		return ec._AwsUpstreamSpec(ctx, sel, &obj)
	case *models.AwsUpstreamSpec:
		return ec._AwsUpstreamSpec(ctx, sel, obj)
	case models.AzureUpstreamSpec:
		return ec._AzureUpstreamSpec(ctx, sel, &obj)
	case *models.AzureUpstreamSpec:
		return ec._AzureUpstreamSpec(ctx, sel, obj)
	case models.KubeUpstreamSpec:
		return ec._KubeUpstreamSpec(ctx, sel, &obj)
	case *models.KubeUpstreamSpec:
		return ec._KubeUpstreamSpec(ctx, sel, obj)
	case models.StaticUpstreamSpec:
		return ec._StaticUpstreamSpec(ctx, sel, &obj)
	case *models.StaticUpstreamSpec:
		return ec._StaticUpstreamSpec(ctx, sel, obj)
	default:
		panic(fmt.Errorf("unexpected type %T", obj))
	}
}

func UnmarshalInputArtifact(v interface{}) (models.InputArtifact, error) {
	var it models.InputArtifact
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "data":
			var err error
			it.Data, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			it.Metadata, err = UnmarshalInputMetadata(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAwsDestinationSpec(v interface{}) (models.InputAwsDestinationSpec, error) {
	var it models.InputAwsDestinationSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "logicalName":
			var err error
			it.LogicalName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "invocationStyle":
			var err error
			err = (&it.InvocationStyle).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "responseTransformation":
			var err error
			it.ResponseTransformation, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAwsLambdaFunction(v interface{}) (models.InputAwsLambdaFunction, error) {
	var it models.InputAwsLambdaFunction
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "logicalName":
			var err error
			it.LogicalName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "functionName":
			var err error
			it.FunctionName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "qualifier":
			var err error
			it.Qualifier, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAwsSecret(v interface{}) (models.InputAwsSecret, error) {
	var it models.InputAwsSecret
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "accessKey":
			var err error
			it.AccessKey, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "secretKey":
			var err error
			it.SecretKey, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAwsUpstreamSpec(v interface{}) (models.InputAwsUpstreamSpec, error) {
	var it models.InputAwsUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "region":
			var err error
			it.Region, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "secretRef":
			var err error
			it.SecretRef, err = UnmarshalInputResourceRef(v)
			if err != nil {
				return it, err
			}
		case "functions":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Functions = make([]models.InputAwsLambdaFunction, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Functions[idx1], err = UnmarshalInputAwsLambdaFunction(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAzureDestinationSpec(v interface{}) (models.InputAzureDestinationSpec, error) {
	var it models.InputAzureDestinationSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functionName":
			var err error
			it.FunctionName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAzureFunction(v interface{}) (models.InputAzureFunction, error) {
	var it models.InputAzureFunction
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functionName":
			var err error
			it.FunctionName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "authLevel":
			var err error
			it.AuthLevel, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAzureSecret(v interface{}) (models.InputAzureSecret, error) {
	var it models.InputAzureSecret
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "apiKeys":
			var err error
			it.APIKeys, err = UnmarshalInputMapStringString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputAzureUpstreamSpec(v interface{}) (models.InputAzureUpstreamSpec, error) {
	var it models.InputAzureUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functionAppName":
			var err error
			it.FunctionAppName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "secretRef":
			var err error
			var ptr1 models.InputResourceRef
			if v != nil {
				ptr1, err = UnmarshalInputResourceRef(v)
				it.SecretRef = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "functions":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Functions = make([]models.InputAzureFunction, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Functions[idx1], err = UnmarshalInputAzureFunction(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputDestination(v interface{}) (models.InputDestination, error) {
	var it models.InputDestination
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "singleDestination":
			var err error
			var ptr1 models.InputSingleDestination
			if v != nil {
				ptr1, err = UnmarshalInputSingleDestination(v)
				it.SingleDestination = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "multiDestination":
			var err error
			var ptr1 models.InputMultiDestination
			if v != nil {
				ptr1, err = UnmarshalInputMultiDestination(v)
				it.MultiDestination = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputDestinationSpec(v interface{}) (models.InputDestinationSpec, error) {
	var it models.InputDestinationSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "aws":
			var err error
			var ptr1 models.InputAwsDestinationSpec
			if v != nil {
				ptr1, err = UnmarshalInputAwsDestinationSpec(v)
				it.Aws = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "azure":
			var err error
			var ptr1 models.InputAzureDestinationSpec
			if v != nil {
				ptr1, err = UnmarshalInputAzureDestinationSpec(v)
				it.Azure = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "rest":
			var err error
			var ptr1 models.InputRestDestinationSpec
			if v != nil {
				ptr1, err = UnmarshalInputRestDestinationSpec(v)
				it.Rest = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputFieldResolver(v interface{}) (models.InputFieldResolver, error) {
	var it models.InputFieldResolver
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "fieldName":
			var err error
			it.FieldName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "resolver":
			var err error
			it.Resolver, err = UnmarshalInputResolver(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputGRPCServiceSpec(v interface{}) (models.InputGRPCServiceSpec, error) {
	var it models.InputGRPCServiceSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "empty":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Empty = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputGlooResolver(v interface{}) (models.InputGlooResolver, error) {
	var it models.InputGlooResolver
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "requestTemplate":
			var err error
			var ptr1 models.InputRequestTemplate
			if v != nil {
				ptr1, err = UnmarshalInputRequestTemplate(v)
				it.RequestTemplate = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "responseTemplate":
			var err error
			var ptr1 models.InputResponseTemplate
			if v != nil {
				ptr1, err = UnmarshalInputResponseTemplate(v)
				it.ResponseTemplate = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "destination":
			var err error
			it.Destination, err = UnmarshalInputDestination(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputKeyValueMatcher(v interface{}) (models.InputKeyValueMatcher, error) {
	var it models.InputKeyValueMatcher
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error
			it.Value, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "isRegex":
			var err error
			it.IsRegex, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputKubeUpstreamSpec(v interface{}) (models.InputKubeUpstreamSpec, error) {
	var it models.InputKubeUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "serviceName":
			var err error
			it.ServiceName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "serviceNamespace":
			var err error
			it.ServiceNamespace, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "servicePort":
			var err error
			it.ServicePort, err = graphql.UnmarshalInt(v)
			if err != nil {
				return it, err
			}
		case "selector":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Selector = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "serviceSpec":
			var err error
			var ptr1 models.InputServiceSpec
			if v != nil {
				ptr1, err = UnmarshalInputServiceSpec(v)
				it.ServiceSpec = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputMapStringString(v interface{}) (models.InputMapStringString, error) {
	var it models.InputMapStringString
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "values":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Values = make([]models.InputValue, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Values[idx1], err = UnmarshalInputValue(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputMatcher(v interface{}) (models.InputMatcher, error) {
	var it models.InputMatcher
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "pathMatch":
			var err error
			it.PathMatch, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "pathMatchType":
			var err error
			err = (&it.PathMatchType).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "headers":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Headers = make([]models.InputKeyValueMatcher, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Headers[idx1], err = UnmarshalInputKeyValueMatcher(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "queryParameters":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.QueryParameters = make([]models.InputKeyValueMatcher, len(rawIf1))
			for idx1 := range rawIf1 {
				it.QueryParameters[idx1], err = UnmarshalInputKeyValueMatcher(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "methods":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Methods = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Methods[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputMetadata(v interface{}) (models.InputMetadata, error) {
	var it models.InputMetadata
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "namespace":
			var err error
			it.Namespace, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "resourceVersion":
			var err error
			it.ResourceVersion, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "labels":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Labels = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "annotations":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Annotations = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputMultiDestination(v interface{}) (models.InputMultiDestination, error) {
	var it models.InputMultiDestination
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "destinations":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Destinations = make([]models.InputWeightedDestination, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Destinations[idx1], err = UnmarshalInputWeightedDestination(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputNodeJSResolver(v interface{}) (models.InputNodeJSResolver, error) {
	var it models.InputNodeJSResolver
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "empty":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Empty = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputRequestTemplate(v interface{}) (models.InputRequestTemplate, error) {
	var it models.InputRequestTemplate
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "verb":
			var err error
			it.Verb, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "path":
			var err error
			it.Path, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "body":
			var err error
			it.Body, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "headers":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Headers = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputResolver(v interface{}) (models.InputResolver, error) {
	var it models.InputResolver
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "glooResolver":
			var err error
			var ptr1 models.InputGlooResolver
			if v != nil {
				ptr1, err = UnmarshalInputGlooResolver(v)
				it.GlooResolver = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "templateResolver":
			var err error
			var ptr1 models.InputTemplateResolver
			if v != nil {
				ptr1, err = UnmarshalInputTemplateResolver(v)
				it.TemplateResolver = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "nodeResolver":
			var err error
			var ptr1 models.InputNodeJSResolver
			if v != nil {
				ptr1, err = UnmarshalInputNodeJSResolver(v)
				it.NodeResolver = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputResolverMap(v interface{}) (models.InputResolverMap, error) {
	var it models.InputResolverMap
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "types":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Types = make([]models.InputTypeResolver, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Types[idx1], err = UnmarshalInputTypeResolver(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			it.Metadata, err = UnmarshalInputMetadata(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputResourceRef(v interface{}) (models.InputResourceRef, error) {
	var it models.InputResourceRef
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			it.Name, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "namespace":
			var err error
			it.Namespace, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputResponseTemplate(v interface{}) (models.InputResponseTemplate, error) {
	var it models.InputResponseTemplate
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "body":
			var err error
			it.Body, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "headers":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Headers = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputRestDestinationSpec(v interface{}) (models.InputRestDestinationSpec, error) {
	var it models.InputRestDestinationSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functionName":
			var err error
			it.FunctionName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "parameters":
			var err error
			var ptr1 models.InputTransformationParameters
			if v != nil {
				ptr1, err = UnmarshalInputTransformationParameters(v)
				it.Parameters = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputRestServiceSpec(v interface{}) (models.InputRestServiceSpec, error) {
	var it models.InputRestServiceSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functions":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Functions = make([]models.InputTransformation, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Functions[idx1], err = UnmarshalInputTransformation(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "inlineSwaggerDoc":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.InlineSwaggerDoc = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputRoute(v interface{}) (models.InputRoute, error) {
	var it models.InputRoute
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "matcher":
			var err error
			it.Matcher, err = UnmarshalInputMatcher(v)
			if err != nil {
				return it, err
			}
		case "destination":
			var err error
			it.Destination, err = UnmarshalInputDestination(v)
			if err != nil {
				return it, err
			}
		case "plugins":
			var err error
			var ptr1 models.InputRoutePlugins
			if v != nil {
				ptr1, err = UnmarshalInputRoutePlugins(v)
				it.Plugins = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputRoutePlugins(v interface{}) (models.InputRoutePlugins, error) {
	var it models.InputRoutePlugins
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "empty":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Empty = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputSchema(v interface{}) (models.InputSchema, error) {
	var it models.InputSchema
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "inlineSchema":
			var err error
			it.InlineSchema, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			it.Metadata, err = UnmarshalInputMetadata(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputSecret(v interface{}) (models.InputSecret, error) {
	var it models.InputSecret
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "kind":
			var err error
			it.Kind, err = UnmarshalInputSecretKind(v)
			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			it.Metadata, err = UnmarshalInputMetadata(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputSecretKind(v interface{}) (models.InputSecretKind, error) {
	var it models.InputSecretKind
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "aws":
			var err error
			var ptr1 models.InputAwsSecret
			if v != nil {
				ptr1, err = UnmarshalInputAwsSecret(v)
				it.Aws = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "azure":
			var err error
			var ptr1 models.InputAzureSecret
			if v != nil {
				ptr1, err = UnmarshalInputAzureSecret(v)
				it.Azure = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "tls":
			var err error
			var ptr1 models.InputTlsSecret
			if v != nil {
				ptr1, err = UnmarshalInputTlsSecret(v)
				it.TLS = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputServiceSpec(v interface{}) (models.InputServiceSpec, error) {
	var it models.InputServiceSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "rest":
			var err error
			var ptr1 models.InputRestServiceSpec
			if v != nil {
				ptr1, err = UnmarshalInputRestServiceSpec(v)
				it.Rest = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "grpc":
			var err error
			var ptr1 models.InputGRPCServiceSpec
			if v != nil {
				ptr1, err = UnmarshalInputGRPCServiceSpec(v)
				it.Grpc = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputSingleDestination(v interface{}) (models.InputSingleDestination, error) {
	var it models.InputSingleDestination
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "upstream":
			var err error
			it.Upstream, err = UnmarshalInputResourceRef(v)
			if err != nil {
				return it, err
			}
		case "destinationSpec":
			var err error
			var ptr1 models.InputDestinationSpec
			if v != nil {
				ptr1, err = UnmarshalInputDestinationSpec(v)
				it.DestinationSpec = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputSslConfig(v interface{}) (models.InputSslConfig, error) {
	var it models.InputSslConfig
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "secretRef":
			var err error
			it.SecretRef, err = UnmarshalInputResourceRef(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputStaticHost(v interface{}) (models.InputStaticHost, error) {
	var it models.InputStaticHost
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "addr":
			var err error
			it.Addr, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "port":
			var err error
			it.Port, err = graphql.UnmarshalInt(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputStaticUpstreamSpec(v interface{}) (models.InputStaticUpstreamSpec, error) {
	var it models.InputStaticUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "hosts":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Hosts = make([]models.InputStaticHost, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Hosts[idx1], err = UnmarshalInputStaticHost(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "serviceSpec":
			var err error
			var ptr1 models.InputServiceSpec
			if v != nil {
				ptr1, err = UnmarshalInputServiceSpec(v)
				it.ServiceSpec = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "useTls":
			var err error
			it.UseTLS, err = graphql.UnmarshalBoolean(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputStatus(v interface{}) (models.InputStatus, error) {
	var it models.InputStatus
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "state":
			var err error
			err = (&it.State).UnmarshalGQL(v)
			if err != nil {
				return it, err
			}
		case "reason":
			var err error
			it.Reason, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputTemplateResolver(v interface{}) (models.InputTemplateResolver, error) {
	var it models.InputTemplateResolver
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "empty":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Empty = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputTlsSecret(v interface{}) (models.InputTlsSecret, error) {
	var it models.InputTlsSecret
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "certChain":
			var err error
			it.CertChain, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "privateKey":
			var err error
			it.PrivateKey, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "rootCa":
			var err error
			it.RootCa, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputTransformation(v interface{}) (models.InputTransformation, error) {
	var it models.InputTransformation
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "functionName":
			var err error
			it.FunctionName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "body":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Body = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "headers":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Headers = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputTransformationParameters(v interface{}) (models.InputTransformationParameters, error) {
	var it models.InputTransformationParameters
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "headers":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Headers = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "path":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Path = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputTypeResolver(v interface{}) (models.InputTypeResolver, error) {
	var it models.InputTypeResolver
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "typeName":
			var err error
			it.TypeName, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "fields":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Fields = make([]models.InputFieldResolver, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Fields[idx1], err = UnmarshalInputFieldResolver(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputUpdateMetadata(v interface{}) (models.InputUpdateMetadata, error) {
	var it models.InputUpdateMetadata
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "name":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Name = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "labels":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Labels = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "annotations":
			var err error
			var ptr1 models.InputMapStringString
			if v != nil {
				ptr1, err = UnmarshalInputMapStringString(v)
				it.Annotations = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputUpdateVirtualService(v interface{}) (models.InputUpdateVirtualService, error) {
	var it models.InputUpdateVirtualService
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "domains":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Domains = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Domains[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "sslConfig":
			var err error
			var ptr1 models.InputSslConfig
			if v != nil {
				ptr1, err = UnmarshalInputSslConfig(v)
				it.SslConfig = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "plugins":
			var err error
			var ptr1 models.InputVirtualServicePlugins
			if v != nil {
				ptr1, err = UnmarshalInputVirtualServicePlugins(v)
				it.Plugins = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			var ptr1 models.InputUpdateMetadata
			if v != nil {
				ptr1, err = UnmarshalInputUpdateMetadata(v)
				it.Metadata = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputUpstream(v interface{}) (models.InputUpstream, error) {
	var it models.InputUpstream
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "spec":
			var err error
			it.Spec, err = UnmarshalInputUpstreamSpec(v)
			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			it.Metadata, err = UnmarshalInputMetadata(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputUpstreamSpec(v interface{}) (models.InputUpstreamSpec, error) {
	var it models.InputUpstreamSpec
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "aws":
			var err error
			var ptr1 models.InputAwsUpstreamSpec
			if v != nil {
				ptr1, err = UnmarshalInputAwsUpstreamSpec(v)
				it.Aws = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "azure":
			var err error
			var ptr1 models.InputAzureUpstreamSpec
			if v != nil {
				ptr1, err = UnmarshalInputAzureUpstreamSpec(v)
				it.Azure = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "kube":
			var err error
			var ptr1 models.InputKubeUpstreamSpec
			if v != nil {
				ptr1, err = UnmarshalInputKubeUpstreamSpec(v)
				it.Kube = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "static":
			var err error
			var ptr1 models.InputStaticUpstreamSpec
			if v != nil {
				ptr1, err = UnmarshalInputStaticUpstreamSpec(v)
				it.Static = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputValue(v interface{}) (models.InputValue, error) {
	var it models.InputValue
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "key":
			var err error
			it.Key, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		case "value":
			var err error
			it.Value, err = graphql.UnmarshalString(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputVirtualService(v interface{}) (models.InputVirtualService, error) {
	var it models.InputVirtualService
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "domains":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Domains = make([]string, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Domains[idx1], err = graphql.UnmarshalString(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "routes":
			var err error
			var rawIf1 []interface{}
			if v != nil {
				if tmp1, ok := v.([]interface{}); ok {
					rawIf1 = tmp1
				} else {
					rawIf1 = []interface{}{v}
				}
			}
			it.Routes = make([]models.InputRoute, len(rawIf1))
			for idx1 := range rawIf1 {
				it.Routes[idx1], err = UnmarshalInputRoute(rawIf1[idx1])
			}
			if err != nil {
				return it, err
			}
		case "sslConfig":
			var err error
			var ptr1 models.InputSslConfig
			if v != nil {
				ptr1, err = UnmarshalInputSslConfig(v)
				it.SslConfig = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "plugins":
			var err error
			var ptr1 models.InputVirtualServicePlugins
			if v != nil {
				ptr1, err = UnmarshalInputVirtualServicePlugins(v)
				it.Plugins = &ptr1
			}

			if err != nil {
				return it, err
			}
		case "metadata":
			var err error
			it.Metadata, err = UnmarshalInputMetadata(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputVirtualServicePlugins(v interface{}) (models.InputVirtualServicePlugins, error) {
	var it models.InputVirtualServicePlugins
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "empty":
			var err error
			var ptr1 string
			if v != nil {
				ptr1, err = graphql.UnmarshalString(v)
				it.Empty = &ptr1
			}

			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func UnmarshalInputWeightedDestination(v interface{}) (models.InputWeightedDestination, error) {
	var it models.InputWeightedDestination
	var asMap = v.(map[string]interface{})

	for k, v := range asMap {
		switch k {
		case "destination":
			var err error
			it.Destination, err = UnmarshalInputSingleDestination(v)
			if err != nil {
				return it, err
			}
		case "weight":
			var err error
			it.Weight, err = graphql.UnmarshalInt(v)
			if err != nil {
				return it, err
			}
		}
	}

	return it, nil
}

func (ec *executionContext) FieldMiddleware(ctx context.Context, next graphql.Resolver) interface{} {
	res, err := ec.ResolverMiddleware(ctx, next)
	if err != nil {
		ec.Error(ctx, err)
		return nil
	}
	return res
}

func (ec *executionContext) introspectSchema() *introspection.Schema {
	return introspection.WrapSchema(parsedSchema)
}

func (ec *executionContext) introspectType(name string) *introspection.Type {
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name])
}

var parsedSchema = gqlparser.MustLoadSchema(
	&ast.Source{Name: "schema.graphql", Input: `# Top Level
schema {
    query: Query
    mutation: Mutation
}

type Query {
    getOAuthEndpoint: OAuthEndpoint!

    upstreams(namespace: String!):       UpstreamQuery!
    virtualServices(namespace: String!): VirtualServiceQuery!
    resolverMaps(namespace: String!): ResolverMapQuery!
    schemas(namespace: String!): SchemaQuery!
    secrets(namespace: String!): SecretQuery!
    artifacts(namespace: String!): ArtifactQuery!
}

type OAuthEndpoint {
    url: String!
    clientName: String!
}

type Mutation {
    upstreams(namespace: String!):       UpstreamMutation!
    virtualServices(namespace: String!): VirtualServiceMutation!
    resolverMaps(namespace: String!): ResolverMapMutation!
    schemas(namespace: String!): SchemaMutation!
    secrets(namespace: String!): SecretMutation!
    artifacts(namespace: String!): ArtifactMutation!
}

type UpstreamQuery {
    list(selector: InputMapStringString): [Upstream]
    get(name: String!):                Upstream
}


type UpstreamMutation {
    create(upstream: InputUpstream!): Upstream
    update(upstream: InputUpstream!): Upstream
    delete(name: String!): Upstream
}


type VirtualServiceQuery {
    list(selector: InputMapStringString): [VirtualService]
    get(name: String!):                VirtualService
}


type VirtualServiceMutation {
    create(virtualService: InputVirtualService!): VirtualService
    update(name: String!, resourceVersion: String!, virtualService: InputUpdateVirtualService!): VirtualService
    delete(name: String!): VirtualService

    addRoute(virtualServiceName: String!, resourceVersion: String!, index: Int!, route: InputRoute!) : VirtualService
    updateRoute(virtualServiceName: String!, resourceVersion: String!, index: Int!, route: InputRoute!) : VirtualService
    deleteRoute(virtualServiceName: String!, resourceVersion: String!, index: Int!) : VirtualService
    swapRoutes(virtualServiceName: String!, resourceVersion: String!, index1: Int!, index2: Int!) : VirtualService
    shiftRoutes(virtualServiceName: String!, resourceVersion: String!, fromIndex: Int!, toIndex: Int!) : VirtualService
}


type ResolverMapQuery {
    list(selector: InputMapStringString): [ResolverMap]
    get(name: String!):                ResolverMap
}

type ResolverMapMutation {
    create(resolverMap: InputResolverMap!): ResolverMap
    update(resolverMap: InputResolverMap!): ResolverMap
    delete(name: String!): ResolverMap
    setResolver(resolverMapName: String!, resourceVersion: String!, typeName: String!, fieldName: String!, glooResolver: InputGlooResolver!): ResolverMap
}

type SchemaQuery {
    list(selector: InputMapStringString): [Schema]
    get(name: String!):                Schema
}

type SchemaMutation {
    create(schema: InputSchema!): Schema
    update(schema: InputSchema!): Schema
    delete(name: String!): Schema
}

type SecretQuery {
    list(selector: InputMapStringString): [Secret]
    get(name: String!):                Secret
}

type SecretMutation {
    create(secret: InputSecret!): Secret
    update(secret: InputSecret!): Secret
    delete(name: String!): Secret
}

type ArtifactQuery {
    list(selector: InputMapStringString): [Artifact]
    get(name: String!):                Artifact
}

type ArtifactMutation {
    create(artifact: InputArtifact!): Artifact
    update(artifact: InputArtifact!): Artifact
    delete(name: String!): Artifact
}

# Upstream
# Upstream
# Upstream
# Upstream

type Upstream {
    spec:     UpstreamSpec!
    metadata: Metadata!
    status:   Status!
}

union UpstreamSpec = AwsUpstreamSpec | AzureUpstreamSpec | KubeUpstreamSpec | StaticUpstreamSpec

type AwsUpstreamSpec {
    region:    String!
    secretRef: ResourceRef!
    functions: [AwsLambdaFunction!]
}

type AzureUpstreamSpec {
    functionAppName: String!
    secretRef:       ResourceRef!
    functions:       [AzureFunction!]
}

type KubeUpstreamSpec {
    serviceName:      String!
    serviceNamespace: String!
    servicePort:      Int!
    selector:         MapStringString
    serviceSpec:      ServiceSpec
}

type StaticUpstreamSpec {
    hosts:        [StaticHost!]
    serviceSpec:  ServiceSpec
    useTls:       Boolean!
}

type StaticHost {
    addr: String!
    port: Int!
}

type AwsLambdaFunction {
    logicalName:  String!
    functionName: String!
    qualifier:    String!
}

type AzureFunction {
    functionName: String!
    authLevel:    AzureFnAuthLevel!
}

union ServiceSpec = RestServiceSpec | GRPCServiceSpec

# Not implemented yet
type RestServiceSpec  {
    functions: [Transformation!]
}

type Transformation {
    functionName: String!
    body: String
    headers: MapStringString
}

# Not implemented yet
type GRPCServiceSpec {
    empty: String
}


# Upstream Mutation
# Upstream Mutation
# Upstream Mutation
# Upstream Mutation

input InputUpstream {
    spec:     InputUpstreamSpec!
    metadata: InputMetadata!
}

input InputUpstreamSpec {
    # oneof: aws | azure | kube | static
    aws: InputAwsUpstreamSpec
    azure: InputAzureUpstreamSpec
    kube: InputKubeUpstreamSpec
    static: InputStaticUpstreamSpec
}

input InputAwsUpstreamSpec {
    region:    String!
    secretRef: InputResourceRef!
    functions: [InputAwsLambdaFunction!]
}

input InputAzureUpstreamSpec {
    functionAppName: String!
    secretRef:       InputResourceRef
    functions:       [InputAzureFunction!]
}

input InputKubeUpstreamSpec {
    serviceName:      String!
    serviceNamespace: String!
    servicePort:      Int!
    selector:         InputMapStringString
    serviceSpec:      InputServiceSpec
}

input InputStaticUpstreamSpec {
    hosts:        [InputStaticHost!]
    serviceSpec:  InputServiceSpec
    useTls:       Boolean!
}

input InputStaticHost {
    addr: String!
    port: Int!
}

input InputAwsLambdaFunction {
    logicalName:  String!
    functionName: String!
    qualifier:    String!
}

input InputAzureFunction {
    functionName: String!
    authLevel:    String!
}

input InputServiceSpec  {
    # oneof: Rest | grpc
    rest: InputRestServiceSpec
    grpc:    InputGRPCServiceSpec
}

input InputRestServiceSpec  {
    functions: [InputTransformation!]
    inlineSwaggerDoc: String
}

input InputTransformation {
    functionName: String!
    body: String
    headers: InputMapStringString
}


# Not implemented yet
input InputGRPCServiceSpec {
    empty: String
}

input InputMetadata {
    name:            String!
    namespace:       String!
    resourceVersion: String!
    labels:          InputMapStringString
    annotations:     InputMapStringString
}

input InputUpdateMetadata {
    name:            String
    labels:          InputMapStringString
    annotations:     InputMapStringString
}

input InputStatus {
    state:  State!
    reason: String!
}






## VirtualService
## VirtualService
## VirtualService
## VirtualService
## VirtualService
## VirtualService

type VirtualService {
    domains: [String!]
    routes:  [Route!]
    sslConfig: SslConfig
    plugins: VirtualServicePlugins

    metadata: Metadata!
    status:   Status!
}


type Route {
    matcher: Matcher!
    destination: Destination!
    plugins: RoutePlugins
}

# not implemented
type VirtualServicePlugins {
    empty: String
}

type Matcher {
    pathMatch: String!
    pathMatchType: PathMatchType!
    headers: [KeyValueMatcher!]
    queryParameters: [KeyValueMatcher!]
    methods: [String!]
}

type KeyValueMatcher {
    name: String!
    value: String!
    isRegex: Boolean!
}

union Destination = MultiDestination | SingleDestination

type MultiDestination {
    destinations: [WeightedDestination!]
}

type WeightedDestination {
    destination: SingleDestination!
    weight: Int!
}

type SingleDestination {
    upstream: ResourceRef!
    destinationSpec: DestinationSpec
}

union DestinationSpec = AwsDestinationSpec | AzureDestinationSpec | RestDestinationSpec

type AwsDestinationSpec {
    logicalName: String!
    invocationStyle: AwsLambdaInvocationStyle!
    responseTransformation: Boolean!
}

type AzureDestinationSpec {
    functionName: String!
}

type RestDestinationSpec {
    functionName: String!
    parameters: TransformationParameters
}

type TransformationParameters {
    headers: MapStringString
    path: String
}

type SslConfig {
    secretRef: ResourceRef!
}

# not implemented
type RoutePlugins {
    empty: String
}

# InputVirtualService
# InputVirtualService
# InputVirtualService
# InputVirtualService

input InputVirtualService {
    domains: [String!]
    routes:  [InputRoute!]
    sslConfig: InputSslConfig
    plugins: InputVirtualServicePlugins
    metadata: InputMetadata!
}

input InputUpdateVirtualService {
    domains: [String!]
    sslConfig: InputSslConfig
    plugins: InputVirtualServicePlugins
    metadata: InputUpdateMetadata
}

input InputRoute {
    matcher: InputMatcher!
    destination: InputDestination!
    plugins: InputRoutePlugins
}

# not implemented
input InputVirtualServicePlugins {
    empty: String
}

input InputMatcher {
    pathMatch: String!
    pathMatchType: PathMatchType!
    headers: [InputKeyValueMatcher!]
    queryParameters: [InputKeyValueMatcher!]
    methods: [String!]
}

input InputKeyValueMatcher {
    name: String!
    value: String!
    isRegex: Boolean!
}

input InputDestination {
    # oneof: MultiDestination, SingleDestination
    singleDestination: InputSingleDestination
    multiDestination: InputMultiDestination
}

input InputMultiDestination {
    destinations: [InputWeightedDestination!]
}

input InputWeightedDestination {
    destination: InputSingleDestination!
    weight: Int!
}

input InputSingleDestination {
    upstream: InputResourceRef!
    destinationSpec: InputDestinationSpec
}

input InputDestinationSpec {
    # oneof: aws | azure
    aws: InputAwsDestinationSpec
    azure: InputAzureDestinationSpec
    rest: InputRestDestinationSpec
}

input InputRestDestinationSpec {
    functionName: String!
    parameters: InputTransformationParameters
}

input InputTransformationParameters {
    headers: InputMapStringString
    path: String
}

input InputAwsDestinationSpec {
    logicalName: String!
    invocationStyle: AwsLambdaInvocationStyle!
    responseTransformation: Boolean!
}

input InputAzureDestinationSpec {
    functionName: String!
}

input InputSslConfig {
    secretRef: InputResourceRef!
}


# not implemented
input InputRoutePlugins {
    empty: String
}


## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap
## ResolverMap


type ResolverMap {
    # can't do maps, thanks facebook
    # the trick with type resolvers is the typeNames must be unique!
    # this converts to a map in the server
    # what a novel idea for a type system. maps... who would have thunk it?
    types: [TypeResolver!]!
    metadata: Metadata!
    status:   Status!
}

type TypeResolver {
    typeName: String!
    # again, the fieldNames within this array must be unique
    fields: [FieldResolver!]!
}

type FieldResolver {
    fieldName: String!
    resolver: Resolver!
}

union Resolver = GlooResolver | TemplateResolver | NodeJSResolver

type GlooResolver {
    requestTemplate: RequestTemplate
    responseTemplate: ResponseTemplate
    destination: Destination!
}

type RequestTemplate {
    verb: String!
    path: String!
    body: String!
    headers: MapStringString
}

type ResponseTemplate {
    body: String!
    headers: MapStringString
}

type TemplateResolver {
    inlineTemplate: String
}

type NodeJSResolver {
    empty: String
}



input InputResolverMap {
    # can't do maps, thanks facebook
    # the trick with type resolvers is the typeNames must be unique!
    # this converts to a map in the server
    # what a novel idea for a type system. maps... who would have thunk it?
    types: [InputTypeResolver!]!
    metadata: InputMetadata!
}

input InputTypeResolver {
    typeName: String!
    # again, the fieldNames within this array must be unique
    fields: [InputFieldResolver!]!
}

input InputFieldResolver {
    fieldName: String!
    resolver: InputResolver!
}

input InputResolver {
    # oneof: gloo, template, node
    glooResolver: InputGlooResolver
    templateResolver: InputTemplateResolver
    nodeResolver: InputNodeJSResolver
}

input InputGlooResolver {
    requestTemplate: InputRequestTemplate
    responseTemplate: InputResponseTemplate
    destination: InputDestination!
}

input InputRequestTemplate {
    verb: String!
    path: String!
    body: String!
    headers: InputMapStringString
}

input InputResponseTemplate {
    body: String!
    headers: InputMapStringString
}
input InputTemplateResolver {
    empty: String
}
input InputNodeJSResolver {
    empty: String
}


## Schema
## Schema
## Schema
## Schema
## Schema

type Schema {
    inlineSchema: String!
    metadata: Metadata!
    status: Status!
}

input InputSchema {
    inlineSchema: String!
    metadata: InputMetadata!
}


## Secret
## Secret
## Secret
## Secret
## Secret
## Secret

type Secret {
    kind: SecretKind!
    metadata: Metadata!
}

union SecretKind = AwsSecret | AzureSecret | TlsSecret

type AwsSecret {
    accessKey: String!
    secretKey: String!
}

type AzureSecret {
    apiKeys: MapStringString
}

type TlsSecret {
    certChain: String!
    privateKey: String!
    rootCa: String! # note: it is okay to leave this as an empty string
}

input InputSecret {
    kind: InputSecretKind!
    metadata: InputMetadata!
}

input InputSecretKind {
    # oneof: aws, azure, tls
    aws: InputAwsSecret
    azure: InputAzureSecret
    tls: InputTlsSecret
}

input InputAwsSecret {
    accessKey: String!
    secretKey: String!
}

input InputAzureSecret {
    apiKeys: InputMapStringString!
}

input InputTlsSecret {
    certChain: String!
    privateKey: String!
    rootCa: String! # note: it is okay to leave this as an empty string
}

## Artifact
## Artifact
## Artifact
## Artifact
## Artifact

type Artifact {
    data: String!
    metadata: Metadata!
}

input InputArtifact {
    data: String!
    metadata: InputMetadata!
}



# Common output types
# Common output types
# Common output types
# Common output types
# Common output types

type Metadata {
    name:            String!
    namespace:       String!
    resourceVersion: String!
    labels:          MapStringString
    annotations:     MapStringString
}

type Status {
    state:  State!
    reason: String
}

type ResourceRef {
    name: String!
    namespace: String!
}

input InputResourceRef {
    name: String!
    namespace: String!
}


# Scalars / Extra

enum State {
    PENDING
    ACCEPTED
    REJECTED
}

enum AzureFnAuthLevel {
    ANONYMOUS
    FUNCTION
    ADMIN
}


type MapStringString {
    values: [Value!]
}

input InputMapStringString {
    values: [InputValue!]
}

type Value {
    key: String!
    value: String!
}

input InputValue {
    key: String!
    value: String!
}

enum PathMatchType {
    PREFIX
    REGEX
    EXACT
}

enum AwsLambdaInvocationStyle {
    SYNC
    ASYNC
}
`},
)
